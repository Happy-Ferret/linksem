open import Basic_classes
open import Bool
open import List
open import Num
open import String

open import Bitstring
open import Elf_section_header
open import Elf_types
open import Error
open import Show

(** Symbol table indices *)

(** Symbol table index is a subscript into the symbol table, which holds
  * information needed to locate and relocate a program's symbolic definitions
  * and references.  Index 0 designates both the first entry in the table and
  * serves as the undefined symbol index.  [stn_undef] is a mnemonic for that
  * undefined symbol.
  *)
let stn_undef : nat = 0

(** Symbol bindings *)

(** [elf32_st_bind] unpacks the binding information from the [st_info] field
  * in the record type below.
  *)
let elf32_st_bind i =
  nat_of_unsigned_char (unsigned_char_rshift i 4)
(** [elf64_st_bind] unpacks the binding information from the [st_info] field
  * in the record type below.
  *)
let elf64_st_bind i =
  nat_of_unsigned_char (unsigned_char_rshift i 4)
(** [elf32_st_type] unpacks the type information from the [e32_st_info] field
  * in the record type below.
  *)
let elf32_st_type i =
  nat_of_unsigned_char (unsigned_char_land i (unsigned_char_of_nat 15)) (* 0xf *)
(** [elf64_st_type] unpacks the type information from the [e64_st_info] field
  * in the record type below.
  *)
let elf64_st_type i =
  nat_of_unsigned_char (unsigned_char_land i (unsigned_char_of_nat 15)) (* 0xf *)
(** [elf32_st_info] unpacks other information from the [e32_st_info] field in the
  * record type below.
  *)
let elf32_st_info b t =
  let left   = unsigned_char_lshift b 4 in
  let right  = unsigned_char_land t (unsigned_char_of_nat 15)  in (* 0xf *)
  let result = unsigned_char_plus left right in
    nat_of_unsigned_char result
(** [elf64_st_info] unpacks other information from the [e64_st_info] field in the
  * record type below.
  *)
let elf64_st_info b t =
  let left   = unsigned_char_lshift b 4 in
  let right  = unsigned_char_land t (unsigned_char_of_nat 15)  in (* 0xf *)
  let result = unsigned_char_plus left right in
    nat_of_unsigned_char result
(** [stb_local]: local symbols are not visible outside the object file
  * containing their definition.
  *)
let stb_local : nat = 0
(** [stb_global]: global symbols are visible to all object files being combined.
  *)
let stb_global : nat = 1
(** [stb_weak]: weak symbols resemble global symbols but their definitions have
  * lower precedence.
  *)
let stb_weak : nat = 2
(** [stb_loos]: start of the range reserved for operating-system specific
  * semantics.
  *)
let stb_loos : nat = 10
(** [stb_hios]: end of the range reserved for operating-system specific
  * semantics.
  *)
let stb_hios : nat = 12
(** [stb_loproc]: start of the range reserved for processor specific semantics.
  *)
let stb_loproc : nat = 13
(** [stb_hiproc]: end of the range reserved for processor specific semantics.
  *)
let stb_hiproc : nat = 15

(** Symbol types. *)

(** [stt_notype]: the symbol's type is not specified.
  *)
let stt_notype : nat = 0
(** [stt_object]: the symbol is associated with a data object, such as a
  * variable, an array, and so on.
  *)
let stt_object : nat = 1
(** [stt_func]: the symbol is associated with a function or other executable
  * code.
  *)
let stt_func : nat = 2
(** [stt_section]: the symbol is associated with a section.
  *)
let stt_section : nat = 3
(** [stt_file]: the symbol's name gives the name of the source file associated
  * with the object file.  Must have [stb_local] binding and its section index
  * must be [shn_abs].  It must also precede the other [stb_local] symbols for
  * the file, is present.
  *)
let stt_file : nat = 4
(** [stt_common]: labels an unitialised common block.
  *)
let stt_common : nat = 5
(** [stt_tls]: specifies a thread local storage (TLS) entity.  Gives the
  * assigned offset of the symbol, not its address.  TLS symbols may only be
  * referenced by special TLS relocations and TLS relocations may only reference
  * symbols with type [stt_tls].
  *)
let stt_tls : nat = 6
(** [stt_loos]: start of the range reserved for operating-system specific
  * semantics.
  *)
let stt_loos : nat = 10
(** [stt_hios]: end of the range reserved for operating-system specific
  * semantics.
  *)
let stt_hios : nat = 12
(** [stt_loproc]: start of the range reserved for processor specific
  * semantics.
  *)
let stt_loproc : nat = 13
(** [stt_hiproc]: end of the range reserved for processor specific semantics.
  *)
let stt_hiproc : nat = 15

(** Symbol visibility. *)

(** [elf32_st_visibility] unpacks visibility information from the [e32_st_other]
  * field in the record type below.
  *)
val elf32_st_visibility : unsigned_char -> nat
let elf32_st_visibility o =
  nat_of_unsigned_char (unsigned_char_land o (unsigned_char_of_nat 3)) (* 0x3 *)

(** [stv_default]: symbol visibility is as specified by the symbol's binding
  * type.  Global and weak symbols are visible outside their defining component
  * (executable or shared object file).  Local symbols are hidden.  Global and
  * weak symbols are also pre-emptable: they may be pre-empted by definitions
  * of the same name in another component.
  *)
let stv_default : nat = 0
(** [stv_internal]: meaning may be further defined by processor supplements to
  * further constrain hidden symbols.  An internal symbol in a relocatable file
  * must be either removed or converted to [stb_local] when the relocatable
  * object is included in an executable or shared object by the linker.
  *)
let stv_internal : nat = 1
(** [stv_hidden]: a symbol in the current component is hidden if its name is not
  * visible to other components, necessarily protecting the symbol.  A hidden
  * object may still be referenced from another component if its address is
  * passed outside.  A hidden symbol in a relocatable object must be either
  * removed or converted to [stb_local] when the relocatable file is included in
  * an executable or shared object by the linker.
  *)
let stv_hidden : nat = 2
(** [stv_protected]: a protected symbol is visible in other components but is
  * not pre-emptable, so that any reference to such a symbol from within the
  * defining component must be resolved to the definition in that component.
  * A symbol with [stb_local] binding must not have [stv_protected] visibility.
  * If a symbol definition with [stv_protected] visibility from a shared object
  * file is taken as resolving a reference from an executable or another shared
  * object, the [shn_undef] symbol table entry created has [stv_default]
  * visibility.
  *)
let stv_protected : nat = 3

(** The symbol table entry type. *)

type elf32_symbol_table_entry =
  <| elf32_st_name  : elf32_word
   ; elf32_st_value : elf32_addr
   ; elf32_st_size  : elf32_word
   ; elf32_st_info  : unsigned_char
   ; elf32_st_other : unsigned_char
   ; elf32_st_shndx : elf32_half
   |>
   
let string_of_elf32_symbol_table_entry entry =
	foldr (^) "" [
		"\t"; "Name: "; show entry.elf32_st_name
	]
   
let read_elf32_symbol_table_entry bitstring : error elf32_symbol_table_entry =
	read_elf32_word bitstring >>= fun (name, bitstring) ->
	read_elf32_addr bitstring >>= fun (value, bitstring) ->
	read_elf32_word bitstring >>= fun (size, bitstring) ->
	read_unsigned_char bitstring >>= fun (info, bitstring) ->
	read_unsigned_char bitstring >>= fun (other, bitstring) ->
	read_elf32_half bitstring >>= fun (shndx, bitstring) ->
	let entry = <| elf32_st_name = name; elf32_st_value = value; elf32_st_size = size; elf32_st_info = info; elf32_st_other = other; elf32_st_shndx = shndx |> in
	return entry
	
let rec read_elf32_symbol_table_entries offset_sizes bs =
	match offset_sizes with
		| []    -> return []
		| x::xs ->
			let (offset, size) = x in
			let (_, relevant)  = Bitstring.partition offset bs in
			let (cut, _)       = Bitstring.partition size relevant in
			read_elf32_symbol_table_entry cut >>= fun head ->
			read_elf32_symbol_table_entries xs bs >>= fun tail ->
			return (head::tail)
	end

type elf32_symbol_table = list elf32_symbol_table_entry

let read_elf32_symbol_table sections bs : error elf32_symbol_table =
	let symtabs = List.filter (fun sect -> nat_of_elf32_word sect.elf32_sh_type = sht_symtab || nat_of_elf32_word sect.elf32_sh_type = sht_dynsym) sections in
	let offsets_sizes = List.map (fun sect ->
		let offset = (nat_of_elf32_off sect.elf32_sh_offset) * 8 in
		let size   = (nat_of_elf32_word sect.elf32_sh_size) * 8 in
			(offset, size)) sections
		in
			read_elf32_symbol_table_entries offsets_sizes bs
			
let string_of_elf32_symbol_table tbl =
	"Symbol tables:" ^ "\n" ^
		foldr (^) "\t" (List.map string_of_elf32_symbol_table_entry tbl)
