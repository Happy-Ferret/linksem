(* can a location list be referenced from multiple compilation units, with different base addresses? *)

open import Basic_classes
open import Bool
open import Function
open import Maybe
open import Num
open import String

open import List (* TODO: check why this is not imported in ELF *)


open import Byte_sequence
open import Error
open import Hex_printing
open import Missing_pervasives
open import Show

open import Default_printing

open import Endianness
open import String_table

open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint


(** ***************** experimental DWARF reading *********** *)

(** debug *)

(* workaround debug.lem linking *)
val print_endline : string -> unit
declare ocaml target_rep function print_endline = `print_endline`

let my_debug s = () (*print_endline s*)
let my_debug2 s = () (*print_endline s*)
let my_debug3 s = () (*print_endline s*)
let my_debug4 s = () (*print_endline s*)
let my_debug5 s = print_endline s


(** hex parsing *)

(* should be in lem, either built-in or in pervasives *)

val natural_of_char : char -> natural 
let natural_of_char c =
  let naturalOrd c' = naturalFromNat (String_extra.ord c') in
  let n = naturalOrd c in 
  if n >= naturalOrd #'0' && n <= naturalOrd #'9' then n - naturalOrd #'0' 
  else if n >= naturalOrd #'A' && n <= naturalOrd #'F' then n - naturalOrd #'A' + 10
  else if n >= naturalOrd #'a' && n <= naturalOrd #'f' then n - naturalOrd #'a' + 10
  else Assert_extra.failwith ("natural_of_char argument #'" ^ String.toString [c] ^ "' not in 0-9,A-F,a-f")

val natural_of_hex' : list char -> natural
let rec natural_of_hex' cs = 
  match cs with
  | c :: cs' -> natural_of_char c + 16 * natural_of_hex' cs'
  | [] -> 0
  end

val natural_of_hex : string -> natural
let natural_of_hex s =
  let cs = String.toCharList s in
  match cs with
  | #'0'::#'x'::cs' -> 
      match cs' with
      | c :: _ -> natural_of_hex' (List.reverse cs')
      | [] -> Assert_extra.failwith ("natural_of_hex argument \"" ^ s ^ "\" has no digits")
      end
  | _ -> Assert_extra.failwith ("natural_of_hex argument \"" ^ s ^ "\" does not begin 0x")
  end

(** more missing pervasives *)

(* quick hacky workaround: this is in String.lem, in src_lem_library, but the linker doesn't find it *)
val myconcat : string -> list string -> string
let rec myconcat sep ss =
  match ss with
    | [] -> ""
    | s :: ss' ->
      match ss' with
      | [] -> s
      | _ -> s ^ sep ^ myconcat sep ss'
      end
  end

val myhead : forall 'a. list 'a -> 'a
let myhead l = match l with | x::xs -> x | [] -> Assert_extra.failwith "myhead of empty list" end


val myfindNonPure : forall 'a. ('a -> bool) -> list 'a -> 'a 
let myfindNonPure P l = match (List.find P l) with 
  | Just e      -> e
  | Nothing     -> Assert_extra.failwith "myfindNonPure"
end

val myfindmaybe : forall 'a 'b.  ('a -> maybe 'b) -> list 'a -> maybe 'b
let rec myfindmaybe f xs = 
  match xs with
  | [] -> Nothing
  | x::xs' -> match f x with Just y -> Just y | Nothing -> myfindmaybe f xs' end
  end

(* natural version of List.index *)
val index_natural : forall 'a. list 'a -> natural -> maybe 'a
let rec index_natural l n = match l with 
  | []      -> Nothing
  | x :: xs -> if n = 0 then Just x else index_natural xs (n-1)
end

let partialNaturalFromInteger (i:integer) : natural =
 if i<0 then Assert_extra.failwith "partialNaturalFromInteger" else naturalFromInteger i

(*
val shift_left_big_int : big_int -> int -> big_int
shift_left_big_int b n returns b shifted left by n bits. Equivalent to multiplication by 2^n.
val shift_right_big_int : big_int -> int -> big_int
shift_right_big_int b n returns b shifted right by n bits. Equivalent to division by 2^n with the result being rounded towards minus infinity.
*)
val natural_nat_shift_left : natural -> nat -> natural 
declare ocaml    target_rep function natural_nat_shift_left = `Nat_big_num.shift_left`

val natural_nat_shift_right : natural -> nat -> natural 
declare ocaml    target_rep function natural_nat_shift_right = `Nat_big_num.shift_right`

val bytes_of_natural: endianness -> natural (*size*) -> natural (*value*) -> list byte
let bytes_of_natural en size n =
  if size = 8 then 
    bytes_of_elf64_xword en (elf64_xword_of_natural n)
  else if size = 4 then 
    bytes_of_elf32_word en (elf32_word_of_natural n)
  else
    Assert_extra.failwith "bytes_of_natural given size that is not 4 or 8"

(** basic pretty printing *)

let pphex n = "0x" ^ unsafe_hex_string_of_natural 0 n

let ppbytes xs = show (List.map (fun x -> show x) xs)

let rec ppbytes2 n xs = match xs with | [] -> "" | x::xs' -> "<"^pphex n^">  "^show x^"\n"^ppbytes2 (n+1) xs' end

(* workaround: from String *)
val mytoString : list char -> string
declare ocaml    target_rep function mytoString = `Xstring.implode`

let string_of_bytes bs = mytoString (List.map Missing_pervasives.char_of_byte bs)


(** dwarf encodings *)

(* these encoding tables are pasted from the DWARF 4 specification *)

(* tag encoding *)
let tag_encodings = [
  ("DW_TAG_array_type"               , natural_of_hex "0x01"  ); 
  ("DW_TAG_class_type"               , natural_of_hex "0x02"  ); 
  ("DW_TAG_entry_point"              , natural_of_hex "0x03"  ); 
  ("DW_TAG_enumeration_type"         , natural_of_hex "0x04"  ); 
  ("DW_TAG_formal_parameter"         , natural_of_hex "0x05"  ); 
  ("DW_TAG_imported_declaration"     , natural_of_hex "0x08"  ); 
  ("DW_TAG_label"                    , natural_of_hex "0x0a"  ); 
  ("DW_TAG_lexical_block"            , natural_of_hex "0x0b"  ); 
  ("DW_TAG_member"                   , natural_of_hex "0x0d"  ); 
  ("DW_TAG_pointer_type"             , natural_of_hex "0x0f"  ); 
  ("DW_TAG_reference_type"           , natural_of_hex "0x10"  ); 
  ("DW_TAG_compile_unit"             , natural_of_hex "0x11"  ); 
  ("DW_TAG_string_type"              , natural_of_hex "0x12"  ); 
  ("DW_TAG_structure_type"           , natural_of_hex "0x13"  ); 
  ("DW_TAG_subroutine_type"          , natural_of_hex "0x15"  ); 
  ("DW_TAG_typedef"                  , natural_of_hex "0x16"  ); 
  ("DW_TAG_union_type"               , natural_of_hex "0x17"  ); 
  ("DW_TAG_unspecified_parameters"   , natural_of_hex "0x18"  ); 
  ("DW_TAG_variant"                  , natural_of_hex "0x19"  ); 
  ("DW_TAG_common_block"             , natural_of_hex "0x1a"  ); 
  ("DW_TAG_common_inclusion"         , natural_of_hex "0x1b"  ); 
  ("DW_TAG_inheritance"              , natural_of_hex "0x1c"  ); 
  ("DW_TAG_inlined_subroutine"       , natural_of_hex "0x1d"  ); 
  ("DW_TAG_module"                   , natural_of_hex "0x1e"  ); 
  ("DW_TAG_ptr_to_member_type"       , natural_of_hex "0x1f"  ); 
  ("DW_TAG_set_type"                 , natural_of_hex "0x20"  ); 
  ("DW_TAG_subrange_type"            , natural_of_hex "0x21"  ); 
  ("DW_TAG_with_stmt"                , natural_of_hex "0x22"  ); 
  ("DW_TAG_access_declaration"       , natural_of_hex "0x23"  ); 
  ("DW_TAG_base_type"                , natural_of_hex "0x24"  ); 
  ("DW_TAG_catch_block"              , natural_of_hex "0x25"  ); 
  ("DW_TAG_const_type"               , natural_of_hex "0x26"  ); 
  ("DW_TAG_constant"                 , natural_of_hex "0x27"  ); 
  ("DW_TAG_enumerator"               , natural_of_hex "0x28"  ); 
  ("DW_TAG_file_type"                , natural_of_hex "0x29"  ); 
  ("DW_TAG_friend"                   , natural_of_hex "0x2a"  ); 
  ("DW_TAG_namelist"                 , natural_of_hex "0x2b"  ); 
  ("DW_TAG_namelist_item"            , natural_of_hex "0x2c"  ); 
  ("DW_TAG_packed_type"              , natural_of_hex "0x2d"  ); 
  ("DW_TAG_subprogram"               , natural_of_hex "0x2e"  ); 
  ("DW_TAG_template_type_parameter"  , natural_of_hex "0x2f"  ); 
  ("DW_TAG_template_value_parameter" , natural_of_hex "0x30"  ); 
  ("DW_TAG_thrown_type"              , natural_of_hex "0x31"  ); 
  ("DW_TAG_try_block"                , natural_of_hex "0x32"  ); 
  ("DW_TAG_variant_part"             , natural_of_hex "0x33"  ); 
  ("DW_TAG_variable"                 , natural_of_hex "0x34"  ); 
  ("DW_TAG_volatile_type"            , natural_of_hex "0x35"  ); 
  ("DW_TAG_dwarf_procedure"          , natural_of_hex "0x36"  ); 
  ("DW_TAG_restrict_type"            , natural_of_hex "0x37"  ); 
  ("DW_TAG_interface_type"           , natural_of_hex "0x38"  ); 
  ("DW_TAG_namespace"                , natural_of_hex "0x39"  ); 
  ("DW_TAG_imported_module"          , natural_of_hex "0x3a"  ); 
  ("DW_TAG_unspecified_type"         , natural_of_hex "0x3b"  ); 
  ("DW_TAG_partial_unit"             , natural_of_hex "0x3c"  ); 
  ("DW_TAG_imported_unit"            , natural_of_hex "0x3d"  ); 
  ("DW_TAG_condition"                , natural_of_hex "0x3f"  ); 
  ("DW_TAG_shared_type"              , natural_of_hex "0x40"  ); 
  ("DW_TAG_type_unit"                , natural_of_hex "0x41"  ); 
  ("DW_TAG_rvalue_reference_type"    , natural_of_hex "0x42"  ); 
  ("DW_TAG_template_alias"           , natural_of_hex "0x43"  ); 
  ("DW_TAG_lo_user"                  , natural_of_hex "0x4080"); 
  ("DW_TAG_hi_user"                  , natural_of_hex "0xffff")
]


(* child determination encoding *)

let DW_CHILDREN_no  = natural_of_hex "0x00"
let DW_CHILDREN_yes = natural_of_hex "0x01"


(* attribute encoding *)

type dwarf_attribute_classes = 
  | DWA_7_5_3
  | DWA_address
  | DWA_block
  | DWA_constant
  | DWA_dash
  | DWA_exprloc
  | DWA_flag 
  | DWA_lineptr
  | DWA_loclistptr
  | DWA_macptr
  | DWA_rangelistptr
  | DWA_reference
  | DWA_string

let attribute_encodings = [
  ("DW_AT_sibling"              , natural_of_hex "0x01", [DWA_reference])                                   ;
  ("DW_AT_location"             , natural_of_hex "0x02", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_name"                 , natural_of_hex "0x03", [DWA_string])                                      ;
  ("DW_AT_ordering"             , natural_of_hex "0x09", [DWA_constant])                                    ;
  ("DW_AT_byte_size"            , natural_of_hex "0x0b", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_offset"           , natural_of_hex "0x0c", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_size"             , natural_of_hex "0x0d", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_stmt_list"            , natural_of_hex "0x10", [DWA_lineptr])                                     ;
  ("DW_AT_low_pc"               , natural_of_hex "0x11", [DWA_address])                                     ;
  ("DW_AT_high_pc"              , natural_of_hex "0x12", [DWA_address; DWA_constant])                       ;
  ("DW_AT_language"             , natural_of_hex "0x13", [DWA_constant])                                    ;
  ("DW_AT_discr"                , natural_of_hex "0x15", [DWA_reference])                                   ;
  ("DW_AT_discr_value"          , natural_of_hex "0x16", [DWA_constant])                                    ;
  ("DW_AT_visibility"           , natural_of_hex "0x17", [DWA_constant])                                    ;
  ("DW_AT_import"               , natural_of_hex "0x18", [DWA_reference])                                   ;
  ("DW_AT_string_length"        , natural_of_hex "0x19", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_common_reference"     , natural_of_hex "0x1a", [DWA_reference])                                   ;
  ("DW_AT_comp_dir"             , natural_of_hex "0x1b", [DWA_string])                                      ;
  ("DW_AT_const_value"          , natural_of_hex "0x1c", [DWA_block; DWA_constant; DWA_string])             ;
  ("DW_AT_containing_type"      , natural_of_hex "0x1d", [DWA_reference])                                   ;
  ("DW_AT_default_value"        , natural_of_hex "0x1e", [DWA_reference])                                   ;
  ("DW_AT_inline"               , natural_of_hex "0x20", [DWA_constant])                                    ;
  ("DW_AT_is_optional"          , natural_of_hex "0x21", [DWA_flag])                                        ;
  ("DW_AT_lower_bound"          , natural_of_hex "0x22", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_producer"             , natural_of_hex "0x25", [DWA_string])                                      ;
  ("DW_AT_prototyped"           , natural_of_hex "0x27", [DWA_flag])                                        ;
  ("DW_AT_return_addr"          , natural_of_hex "0x2a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_start_scope"          , natural_of_hex "0x2c", [DWA_constant; DWA_rangelistptr])                  ;
  ("DW_AT_bit_stride"           , natural_of_hex "0x2e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_upper_bound"          , natural_of_hex "0x2f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_abstract_origin"      , natural_of_hex "0x31", [DWA_reference])                                   ;
  ("DW_AT_accessibility"        , natural_of_hex "0x32", [DWA_constant])                                    ;
  ("DW_AT_address_class"        , natural_of_hex "0x33", [DWA_constant])                                    ;
  ("DW_AT_artificial"           , natural_of_hex "0x34", [DWA_flag])                                        ;
  ("DW_AT_base_types"           , natural_of_hex "0x35", [DWA_reference])                                   ;
  ("DW_AT_calling_convention"   , natural_of_hex "0x36", [DWA_constant])                                    ;
  ("DW_AT_count"                , natural_of_hex "0x37", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_member_location" , natural_of_hex "0x38", [DWA_constant; DWA_exprloc; DWA_loclistptr])       ;
  ("DW_AT_decl_column"          , natural_of_hex "0x39", [DWA_constant])                                    ;
  ("DW_AT_decl_file"            , natural_of_hex "0x3a", [DWA_constant])                                    ;
  ("DW_AT_decl_line"            , natural_of_hex "0x3b", [DWA_constant])                                    ;
  ("DW_AT_declaration"          , natural_of_hex "0x3c", [DWA_flag])                                        ;
  ("DW_AT_discr_list"           , natural_of_hex "0x3d", [DWA_block])                                       ;
  ("DW_AT_encoding"             , natural_of_hex "0x3e", [DWA_constant])                                    ;
  ("DW_AT_external"             , natural_of_hex "0x3f", [DWA_flag])                                        ;
  ("DW_AT_frame_base"           , natural_of_hex "0x40", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_friend"               , natural_of_hex "0x41", [DWA_reference])                                   ;
  ("DW_AT_identifier_case"      , natural_of_hex "0x42", [DWA_constant])                                    ;
  ("DW_AT_macro_info"           , natural_of_hex "0x43", [DWA_macptr])                                      ;
  ("DW_AT_namelist_item"        , natural_of_hex "0x44", [DWA_reference])                                   ;
  ("DW_AT_priority"             , natural_of_hex "0x45", [DWA_reference])                                   ;
  ("DW_AT_segment"              , natural_of_hex "0x46", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_specification"        , natural_of_hex "0x47", [DWA_reference])                                   ;
  ("DW_AT_static_link"          , natural_of_hex "0x48", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_type"                 , natural_of_hex "0x49", [DWA_reference])                                   ;
  ("DW_AT_use_location"         , natural_of_hex "0x4a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_variable_parameter"   , natural_of_hex "0x4b", [DWA_flag])                                        ;
  ("DW_AT_virtuality"           , natural_of_hex "0x4c", [DWA_constant])                                    ;
  ("DW_AT_vtable_elem_location" , natural_of_hex "0x4d", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_allocated"            , natural_of_hex "0x4e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_associated"           , natural_of_hex "0x4f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_location"        , natural_of_hex "0x50", [DWA_exprloc])                                     ;
  ("DW_AT_byte_stride"          , natural_of_hex "0x51", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_entry_pc"             , natural_of_hex "0x52", [DWA_address])                                     ;
  ("DW_AT_use_UTF8"             , natural_of_hex "0x53", [DWA_flag])                                        ;
  ("DW_AT_extension"            , natural_of_hex "0x54", [DWA_reference])                                   ;
  ("DW_AT_ranges"               , natural_of_hex "0x55", [DWA_rangelistptr])                                ;
  ("DW_AT_trampoline"           , natural_of_hex "0x56", [DWA_address; DWA_flag; DWA_reference; DWA_string]);
  ("DW_AT_call_column"          , natural_of_hex "0x57", [DWA_constant])                                    ;
  ("DW_AT_call_file"            , natural_of_hex "0x58", [DWA_constant])                                    ;
  ("DW_AT_call_line"            , natural_of_hex "0x59", [DWA_constant])                                    ;
  ("DW_AT_description"          , natural_of_hex "0x5a", [DWA_string])                                      ;
  ("DW_AT_binary_scale"         , natural_of_hex "0x5b", [DWA_constant])                                    ;
  ("DW_AT_decimal_scale"        , natural_of_hex "0x5c", [DWA_constant])                                    ;
  ("DW_AT_small"                , natural_of_hex "0x5d", [DWA_reference])                                   ;
  ("DW_AT_decimal_sign"         , natural_of_hex "0x5e", [DWA_constant])                                    ;
  ("DW_AT_digit_count"          , natural_of_hex "0x5f", [DWA_constant])                                    ;
  ("DW_AT_picture_string"       , natural_of_hex "0x60", [DWA_string])                                      ;
  ("DW_AT_mutable"              , natural_of_hex "0x61", [DWA_flag])                                        ;
  ("DW_AT_threads_scaled"       , natural_of_hex "0x62", [DWA_flag])                                        ;
  ("DW_AT_explicit"             , natural_of_hex "0x63", [DWA_flag])                                        ;
  ("DW_AT_object_pointer"       , natural_of_hex "0x64", [DWA_reference])                                   ;
  ("DW_AT_endianity"            , natural_of_hex "0x65", [DWA_constant])                                    ;
  ("DW_AT_elemental"            , natural_of_hex "0x66", [DWA_flag])                                        ;
  ("DW_AT_pure"                 , natural_of_hex "0x67", [DWA_flag])                                        ;
  ("DW_AT_recursive"            , natural_of_hex "0x68", [DWA_flag])                                        ;
  ("DW_AT_signature"            , natural_of_hex "0x69", [DWA_reference])                                   ;
  ("DW_AT_main_subprogram"      , natural_of_hex "0x6a", [DWA_flag])                                        ;
  ("DW_AT_data_bit_offset"      , natural_of_hex "0x6b", [DWA_constant])                                    ;
  ("DW_AT_const_expr"           , natural_of_hex "0x6c", [DWA_flag])                                        ;
  ("DW_AT_enum_class"           , natural_of_hex "0x6d", [DWA_flag])                                        ;
  ("DW_AT_linkage_name"         , natural_of_hex "0x6e", [DWA_string])                                      ;
  ("DW_AT_lo_user"              , natural_of_hex "0x2000", [DWA_dash])                                      ;
  ("DW_AT_hi_user"              , natural_of_hex "0x3fff", [DWA_dash])                                      
]


(* attribute form encoding *)

let attribute_form_encodings = [
  ("DW_FORM_addr"        , natural_of_hex "0x01", [DWA_address])  ;
  ("DW_FORM_block2"      , natural_of_hex "0x03", [DWA_block])    ;
  ("DW_FORM_block4"      , natural_of_hex "0x04", [DWA_block])    ;
  ("DW_FORM_data2"       , natural_of_hex "0x05", [DWA_constant]) ;
  ("DW_FORM_data4"       , natural_of_hex "0x06", [DWA_constant]) ;
  ("DW_FORM_data8"       , natural_of_hex "0x07", [DWA_constant]) ;
  ("DW_FORM_string"      , natural_of_hex "0x08", [DWA_string])   ;
  ("DW_FORM_block"       , natural_of_hex "0x09", [DWA_block])    ;
  ("DW_FORM_block1"      , natural_of_hex "0x0a", [DWA_block])    ;
  ("DW_FORM_data1"       , natural_of_hex "0x0b", [DWA_constant]) ;
  ("DW_FORM_flag"        , natural_of_hex "0x0c", [DWA_flag])     ;
  ("DW_FORM_sdata"       , natural_of_hex "0x0d", [DWA_constant]) ;
  ("DW_FORM_strp"        , natural_of_hex "0x0e", [DWA_string])   ;
  ("DW_FORM_udata"       , natural_of_hex "0x0f", [DWA_constant]) ;
  ("DW_FORM_ref_addr"    , natural_of_hex "0x10", [DWA_reference]);
  ("DW_FORM_ref1"        , natural_of_hex "0x11", [DWA_reference]);
  ("DW_FORM_ref2"        , natural_of_hex "0x12", [DWA_reference]);
  ("DW_FORM_ref4"        , natural_of_hex "0x13", [DWA_reference]);
  ("DW_FORM_ref8"        , natural_of_hex "0x14", [DWA_reference]);
  ("DW_FORM_ref_udata"   , natural_of_hex "0x15", [DWA_reference]);
  ("DW_FORM_indirect"    , natural_of_hex "0x16", [DWA_7_5_3])    ;
  ("DW_FORM_sec_offset"  , natural_of_hex "0x17", [DWA_lineptr; DWA_loclistptr; DWA_macptr; DWA_rangelistptr]) ;
  ("DW_FORM_exprloc"     , natural_of_hex "0x18", [DWA_exprloc])  ;
  ("DW_FORM_flag_present", natural_of_hex "0x19", [DWA_flag])     ;
  ("DW_FORM_ref_sig8"    , natural_of_hex "0x20", [DWA_reference])
]


(* operation encoding *)

type operation_argument_type =
  | OAT_addr
  | OAT_dwarf_format_t
  | OAT_uint8
  | OAT_uint16
  | OAT_uint32
  | OAT_uint64
  | OAT_sint8
  | OAT_sint16
  | OAT_sint32
  | OAT_sint64
  | OAT_ULEB128
  | OAT_SLEB128
  | OAT_block

type operation_argument_value = 
  | OAV_natural of natural
  | OAV_integer of integer
  | OAV_block of natural * list byte

type operation_stack = list natural

type arithmetic_context = 
  <|
  ac_bitwidth: natural;
  ac_half: natural;  (* 2 ^ (ac_bitwidth -1) *)
  ac_all: natural;   (* 2 ^ ac_bitwidth      *)
  ac_max: natural;   (* (2 ^ ac_bitwidth) -1 *) (* also the representation of -1 *)
|>

type operation_semantics = 
  | OpSem_lit 
  | OpSem_deref
  | OpSem_stack of (arithmetic_context -> operation_stack -> list operation_argument_value -> maybe operation_stack)
  | OpSem_not_supported
  | OpSem_binary of (arithmetic_context -> natural -> natural -> maybe natural)
  | OpSem_unary of (arithmetic_context -> natural -> maybe natural)
  | OpSem_opcode_lit of natural 
  | OpSem_reg
  | OpSem_breg
  | OpSem_bregx
  | OpSem_fbreg
  | OpSem_deref_size
  | OpSem_nop
  | OpSem_piece
  | OpSem_bit_piece
  | OpSem_implicit_value
  | OpSem_stack_value
  | OpSem_call_frame_cfa

let operation_encodings = [
("DW_OP_addr",                natural_of_hex "0x03", [OAT_addr]                 , OpSem_lit); (*1*) (*constant address (size target specific)*)
("DW_OP_deref",               natural_of_hex "0x06", []                         , OpSem_deref); (*0*)
("DW_OP_const1u",             natural_of_hex "0x08", [OAT_uint8]                , OpSem_lit); (*1*) (* 1-byte constant  *)
("DW_OP_const1s",             natural_of_hex "0x09", [OAT_sint8]                , OpSem_lit); (*1*) (* 1-byte constant  *)
("DW_OP_const2u",             natural_of_hex "0x0a", [OAT_uint16]               , OpSem_lit); (*1*) (* 2-byte constant  *)
("DW_OP_const2s",             natural_of_hex "0x0b", [OAT_sint16]               , OpSem_lit); (*1*) (* 2-byte constant  *)
("DW_OP_const4u",             natural_of_hex "0x0c", [OAT_uint32]               , OpSem_lit); (*1*) (* 4-byte constant  *)
("DW_OP_const4s",             natural_of_hex "0x0d", [OAT_sint32]               , OpSem_lit); (*1*) (* 4-byte constant  *)
("DW_OP_const8u",             natural_of_hex "0x0e", [OAT_uint64]               , OpSem_lit); (*1*) (* 8-byte constant  *)
("DW_OP_const8s",             natural_of_hex "0x0f", [OAT_sint64]               , OpSem_lit); (*1*) (* 8-byte constant  *)
("DW_OP_constu",              natural_of_hex "0x10", [OAT_ULEB128]              , OpSem_lit); (*1*) (* ULEB128 constant *)
("DW_OP_consts",              natural_of_hex "0x11", [OAT_SLEB128]              , OpSem_lit); (*1*) (* SLEB128 constant *)
("DW_OP_dup",                 natural_of_hex "0x12", []                         , OpSem_stack (fun ac vs args -> match vs with v::vs -> Just (v::v::vs) | _ -> Nothing end)); (*0*) 
("DW_OP_drop",                natural_of_hex "0x13", []                         , OpSem_stack (fun ac vs args -> match vs with v::vs -> Just vs | _ -> Nothing end)); (*0*) 
("DW_OP_over",                natural_of_hex "0x14", []                         , OpSem_stack (fun ac vs args -> match vs with v::v'::vs -> Just (v'::v::v'::vs) | _ -> Nothing end)); (*0*) 
("DW_OP_pick",                natural_of_hex "0x15", [OAT_uint8]                , OpSem_stack (fun ac vs args -> match args with [OAV_natural n] -> match index_natural vs n with Just v -> Just (v::vs) | Nothing -> Nothing end | _ -> Nothing end)); (*1*) (* 1-byte stack index *)
("DW_OP_swap",                natural_of_hex "0x16", []                         , OpSem_stack (fun ac vs args -> match vs with v::v'::vs -> Just (v'::v::vs) | _ -> Nothing end)); (*0*) 
("DW_OP_rot",                 natural_of_hex "0x17", []                         , OpSem_stack (fun ac vs args -> match vs with v::v'::v''::vs -> Just (v'::v''::v::vs) | _ -> Nothing end)); (*0*) 
("DW_OP_xderef",              natural_of_hex "0x18", []                         , OpSem_not_supported); (*0*) 
("DW_OP_abs",                 natural_of_hex "0x19", []                         , OpSem_unary (fun ac v -> if v < ac.ac_half then Just v else if v=ac.ac_max then Nothing else Just (ac.ac_all-v))); (*0*) 
("DW_OP_and",                 natural_of_hex "0x1a", []                         , OpSem_binary (fun ac v1 v2 -> Just (natural_land v1 v2))); (*0*) 
("DW_OP_div",                 natural_of_hex "0x1b", []                         , OpSem_not_supported) (*TODO*); (*0*) 
("DW_OP_minus",               natural_of_hex "0x1c", []                         , OpSem_binary (fun ac v1 v2 -> Just (partialNaturalFromInteger ((integerFromNatural v1 - integerFromNatural v2) mod (integerFromNatural ac.ac_all))))); (*0*) 
("DW_OP_mod",                 natural_of_hex "0x1d", []                         , OpSem_binary (fun ac v1 v2 -> Just (v1 mod v2))); (*0*) 
("DW_OP_mul",                 natural_of_hex "0x1e", []                         , OpSem_binary (fun ac v1 v2 -> Just (partialNaturalFromInteger ((integerFromNatural v1 * integerFromNatural v2) mod (integerFromNatural ac.ac_all))))); (*0*) 
("DW_OP_neg",                 natural_of_hex "0x1f", []                         , OpSem_unary (fun ac v -> if v < ac.ac_half then Just (ac.ac_max - v) else if v=ac.ac_half then Nothing else Just (ac.ac_all - v))); (*0*) 
("DW_OP_not",                 natural_of_hex "0x20", []                         , OpSem_unary (fun ac v -> Just (natural_lxor v ac.ac_max))); (*0*)
("DW_OP_or",                  natural_of_hex "0x21", []                         , OpSem_binary (fun ac v1 v2 -> Just (natural_lor v1 v2))); (*0*) 
("DW_OP_plus",                natural_of_hex "0x22", []                         , OpSem_binary (fun ac v1 v2 -> Just ((v1 + v2) mod ac.ac_all))); (*0*) 
("DW_OP_plus_uconst",         natural_of_hex "0x23", [OAT_ULEB128]              , OpSem_stack (fun ac vs args -> match args with [OAV_natural n] -> match vs with v::vs' -> let v' = (v+n) mod ac.ac_all in Just (v'::vs)  | [] -> Nothing end  | _ -> Nothing end)); (*1*) (* ULEB128 addend *)
("DW_OP_shl",                 natural_of_hex "0x24", []                         , OpSem_binary (fun ac v1 v2 -> if v2 >= ac.ac_bitwidth then Just 0 else Just (natural_nat_shift_left v1 (natFromNatural v2)))); (*0*) 
("DW_OP_shr",                 natural_of_hex "0x25", []                         , OpSem_binary (fun ac v1 v2 -> if v2 >= ac.ac_bitwidth then Just 0 else Just (natural_nat_shift_right v1 (natFromNatural v2)))); (*0*) 
("DW_OP_shra",                natural_of_hex "0x26", []                         , OpSem_binary (fun ac v1 v2 -> if v1 < ac.ac_half then (if v2 >= ac.ac_bitwidth then Just 0 else Just (natural_nat_shift_right v1 (natFromNatural v2))) else (if v2 >= ac.ac_bitwidth then Just ac.ac_max  else Just (ac.ac_max - (natural_nat_shift_right (ac.ac_max - v1) (natFromNatural v2)))))); (*0*) 
("DW_OP_xor",                 natural_of_hex "0x27", []                         , OpSem_binary (fun ac v1 v2 -> Just (natural_lxor v1 v2))); (*0*)
("DW_OP_skip",                natural_of_hex "0x2f", [OAT_sint16]               , OpSem_not_supported); (*1*) (* signed 2-byte constant *)
("DW_OP_bra",                 natural_of_hex "0x28", [OAT_sint16]               , OpSem_not_supported); (*1*) (* signed 2-byte constant *)
("DW_OP_eq",                  natural_of_hex "0x29", []                         , OpSem_not_supported); (*0*) 
("DW_OP_ge",                  natural_of_hex "0x2a", []                         , OpSem_not_supported); (*0*) 
("DW_OP_gt",                  natural_of_hex "0x2b", []                         , OpSem_not_supported); (*0*) 
("DW_OP_le",                  natural_of_hex "0x2c", []                         , OpSem_not_supported); (*0*) 
("DW_OP_lt",                  natural_of_hex "0x2d", []                         , OpSem_not_supported); (*0*) 
("DW_OP_ne",                  natural_of_hex "0x2e", []                         , OpSem_not_supported); (*0*) 
("DW_OP_lit0",                natural_of_hex "0x30", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*) (* literals 0..31 =(DW_OP_lit0 + literal) *)
("DW_OP_lit1",                natural_of_hex "0x31", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit2",                natural_of_hex "0x32", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit3",                natural_of_hex "0x33", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit4",                natural_of_hex "0x34", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit5",                natural_of_hex "0x35", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit6",                natural_of_hex "0x36", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit7",                natural_of_hex "0x37", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit8",                natural_of_hex "0x38", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit9",                natural_of_hex "0x39", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit10",               natural_of_hex "0x3a", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit11",               natural_of_hex "0x3b", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit12",               natural_of_hex "0x3c", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit13",               natural_of_hex "0x3d", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit14",               natural_of_hex "0x3e", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit15",               natural_of_hex "0x3f", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit16",               natural_of_hex "0x40", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit17",               natural_of_hex "0x41", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit18",               natural_of_hex "0x42", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit19",               natural_of_hex "0x43", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit20",               natural_of_hex "0x44", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit21",               natural_of_hex "0x45", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit22",               natural_of_hex "0x46", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit23",               natural_of_hex "0x47", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit24",               natural_of_hex "0x48", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit25",               natural_of_hex "0x49", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit26",               natural_of_hex "0x4a", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit27",               natural_of_hex "0x4b", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit28",               natural_of_hex "0x4c", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit29",               natural_of_hex "0x4d", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit30",               natural_of_hex "0x4e", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_lit31",               natural_of_hex "0x4f", []                         , OpSem_opcode_lit (natural_of_hex "0x30")); (*0*)
("DW_OP_reg0",                natural_of_hex "0x50", []                         , OpSem_reg); (*1*) (* reg 0..31 = (DW_OP_reg0 + regnum) *)
("DW_OP_reg1",                natural_of_hex "0x51", []                         , OpSem_reg); (*1*)
("DW_OP_reg2",                natural_of_hex "0x52", []                         , OpSem_reg); (*1*)
("DW_OP_reg3",                natural_of_hex "0x53", []                         , OpSem_reg); (*1*)
("DW_OP_reg4",                natural_of_hex "0x54", []                         , OpSem_reg); (*1*)
("DW_OP_reg5",                natural_of_hex "0x55", []                         , OpSem_reg); (*1*)
("DW_OP_reg6",                natural_of_hex "0x56", []                         , OpSem_reg); (*1*)
("DW_OP_reg7",                natural_of_hex "0x57", []                         , OpSem_reg); (*1*)
("DW_OP_reg8",                natural_of_hex "0x58", []                         , OpSem_reg); (*1*)
("DW_OP_reg9",                natural_of_hex "0x59", []                         , OpSem_reg); (*1*)
("DW_OP_reg10",               natural_of_hex "0x5a", []                         , OpSem_reg); (*1*)
("DW_OP_reg11",               natural_of_hex "0x5b", []                         , OpSem_reg); (*1*)
("DW_OP_reg12",               natural_of_hex "0x5c", []                         , OpSem_reg); (*1*)
("DW_OP_reg13",               natural_of_hex "0x5d", []                         , OpSem_reg); (*1*)
("DW_OP_reg14",               natural_of_hex "0x5e", []                         , OpSem_reg); (*1*)
("DW_OP_reg15",               natural_of_hex "0x5f", []                         , OpSem_reg); (*1*)
("DW_OP_reg16",               natural_of_hex "0x60", []                         , OpSem_reg); (*1*)
("DW_OP_reg17",               natural_of_hex "0x61", []                         , OpSem_reg); (*1*)
("DW_OP_reg18",               natural_of_hex "0x62", []                         , OpSem_reg); (*1*)
("DW_OP_reg19",               natural_of_hex "0x63", []                         , OpSem_reg); (*1*)
("DW_OP_reg20",               natural_of_hex "0x64", []                         , OpSem_reg); (*1*)
("DW_OP_reg21",               natural_of_hex "0x65", []                         , OpSem_reg); (*1*)
("DW_OP_reg22",               natural_of_hex "0x66", []                         , OpSem_reg); (*1*)
("DW_OP_reg23",               natural_of_hex "0x67", []                         , OpSem_reg); (*1*)
("DW_OP_reg24",               natural_of_hex "0x68", []                         , OpSem_reg); (*1*)
("DW_OP_reg25",               natural_of_hex "0x69", []                         , OpSem_reg); (*1*)
("DW_OP_reg26",               natural_of_hex "0x6a", []                         , OpSem_reg); (*1*)
("DW_OP_reg27",               natural_of_hex "0x6b", []                         , OpSem_reg); (*1*)
("DW_OP_reg28",               natural_of_hex "0x6c", []                         , OpSem_reg); (*1*)
("DW_OP_reg29",               natural_of_hex "0x6d", []                         , OpSem_reg); (*1*)
("DW_OP_reg30",               natural_of_hex "0x6e", []                         , OpSem_reg); (*1*)
("DW_OP_reg31",               natural_of_hex "0x6f", []                         , OpSem_reg); (*1*) 
("DW_OP_breg0",               natural_of_hex "0x70", [OAT_SLEB128]              , OpSem_breg); (*1*) (* base register 0..31 = (DW_OP_breg0 + regnum) *)
("DW_OP_breg1",               natural_of_hex "0x71", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg2",               natural_of_hex "0x72", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg3",               natural_of_hex "0x73", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg4",               natural_of_hex "0x74", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg5",               natural_of_hex "0x75", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg6",               natural_of_hex "0x76", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg7",               natural_of_hex "0x77", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg8",               natural_of_hex "0x78", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg9",               natural_of_hex "0x79", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg10",              natural_of_hex "0x7a", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg11",              natural_of_hex "0x7b", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg12",              natural_of_hex "0x7c", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg13",              natural_of_hex "0x7d", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg14",              natural_of_hex "0x7e", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg15",              natural_of_hex "0x7f", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg16",              natural_of_hex "0x80", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg17",              natural_of_hex "0x81", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg18",              natural_of_hex "0x82", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg19",              natural_of_hex "0x83", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg20",              natural_of_hex "0x84", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg21",              natural_of_hex "0x85", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg22",              natural_of_hex "0x86", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg23",              natural_of_hex "0x87", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg24",              natural_of_hex "0x88", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg25",              natural_of_hex "0x89", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg26",              natural_of_hex "0x8a", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg27",              natural_of_hex "0x8b", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg28",              natural_of_hex "0x8c", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg29",              natural_of_hex "0x8d", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg30",              natural_of_hex "0x8e", [OAT_SLEB128]              , OpSem_breg); (*1*)
("DW_OP_breg31",              natural_of_hex "0x8f", [OAT_SLEB128]              , OpSem_breg); (*1*) 
("DW_OP_regx",                natural_of_hex "0x90", [OAT_ULEB128]              , OpSem_lit); (*1*) (* ULEB128 register *)
("DW_OP_fbreg",               natural_of_hex "0x91", [OAT_SLEB128]              , OpSem_fbreg); (*1*) (* SLEB128 offset *)
("DW_OP_bregx",               natural_of_hex "0x92", [OAT_ULEB128; OAT_SLEB128] , OpSem_bregx); (*2*) (* ULEB128 register followed by SLEB128 offset *)
("DW_OP_piece",               natural_of_hex "0x93", [OAT_ULEB128]              , OpSem_piece); (*1*) (* ULEB128 size of piece addressed *)
("DW_OP_deref_size",          natural_of_hex "0x94", [OAT_uint8]                , OpSem_deref_size); (*1*) (* 1-byte size of data retrieved *)
("DW_OP_xderef_size",         natural_of_hex "0x95", [OAT_uint8]                , OpSem_not_supported); (*1*) (* 1-byte size of data retrieved *)
("DW_OP_nop",                 natural_of_hex "0x96", []                         , OpSem_nop); (*0*)  
("DW_OP_push_object_address", natural_of_hex "0x97", []                         , OpSem_not_supported); (*0*)  
("DW_OP_call2",               natural_of_hex "0x98", [OAT_uint16]               , OpSem_not_supported); (*1*) (* 2-byte offset of DIE *)
("DW_OP_call4",               natural_of_hex "0x99", [OAT_uint32]               , OpSem_not_supported); (*1*) (* 4-byte offset of DIE *)
("DW_OP_call_ref",            natural_of_hex "0x9a", [OAT_dwarf_format_t]       , OpSem_not_supported); (*1*) (* 4- or 8-byte offset of DIE *)
("DW_OP_form_tls_address",    natural_of_hex "0x9b", []                         , OpSem_not_supported); (*0*)  
("DW_OP_call_frame_cfa",      natural_of_hex "0x9c", []                         , OpSem_call_frame_cfa); (*0*)
("DW_OP_bit_piece",           natural_of_hex "0x9d", [OAT_ULEB128; OAT_ULEB128] , OpSem_bit_piece); (*2*) (* ULEB128 size followed by ULEB128 offset *)
("DW_OP_implicit_value",      natural_of_hex "0x9e", [OAT_block]                , OpSem_implicit_value); (*2*) (* ULEB128 size followed by block of that size *)
("DW_OP_stack_value",         natural_of_hex "0x9f", []                         , OpSem_stack_value); (*0*) 
(* these aren't real operations 
("DW_OP_lo_user",             natural_of_hex "0xe0", []                         , ); 
("DW_OP_hi_user",             natural_of_hex "0xff", []                         , );
*)

(* GCC also produces these for our example: 
https://fedorahosted.org/elfutils/wiki/DwarfExtensions
http://dwarfstd.org/ShowIssue.php?issue=100909.1 *)
("DW_GNU_OP_entry_value",     natural_of_hex "0xf3", [OAT_block], OpSem_not_supported); (*2*) (* ULEB128 size followed by DWARF expression block of that size*)
("DW_OP_GNU_implicit_pointer", natural_of_hex "0xf2", [OAT_dwarf_format_t;OAT_SLEB128], OpSem_not_supported)

]


let vDW_OP_reg0 = natural_of_hex "0x50"
let vDW_OP_breg0 = natural_of_hex "0x70"


let max_address (as': natural) : natural = 
  match as' with
  | 4 -> natural_of_hex "0xffffffff"
  | 8 -> natural_of_hex "0xffffffffffffffff"
  | _ -> Assert_extra.failwith "max_address size not 4 or 8"
  end


(** context for parsing and pp functions *)

type p_context = 
    <|
    endianness: Endianness.endianness;
  |>


(** dwarf representation types *)

(* This gives a "lightly parsed" representation of some of the dwarf
information, with the byte sequences of some of the .debug_* sections
parsed into a structured representation.  That makes the list and tree
structures explicit, and converts the various numeric types into just
natural, integer, and byte sequences, but it leaves the encoding
values as numbers rather than Lem constructors. The lem natural and 
integer could be replaced by unsigned and signed 64-bit types. *)

type dwarf_format =
  | Dwarf32
  | Dwarf64

type abbreviation_declaration = 
    <| 
    ad_abbreviation_code: natural;
    ad_tag: natural;
    ad_has_children: bool;
    ad_attribute_specifications: list (natural * natural);
  |>

type abbreviations_table = list abbreviation_declaration


type operation = 
    <|
    op_code: natural;
    op_string: string;
    op_argument_values: list operation_argument_value;
    op_semantics: operation_semantics;
  |>

type attribute_value =
  | AV_addr of natural
  | AV_block of natural * list byte
  | AV_constantN of natural * list byte
  | AV_constant_SLEB128 of integer
  | AV_constant_ULEB128 of natural
  | AV_exprloc of natural * list byte
  | AV_flag of bool
  | AV_ref of natural 
  | AV_ref_addr of natural (* dwarf_format dependent *)
  | AV_ref_sig8 of natural
  | AV_sec_offset of natural
  | AV_string of list byte (* not including terminating null *)
  | AV_strp of natural (* dwarf_format dependent *)

type die = 
    <|
    die_offset: natural;
    die_abbreviation_code: natural;
    die_abbreviation_declaration: abbreviation_declaration;
    die_attribute_values: list (natural (*pos*) * attribute_value);
    die_children: list die;
  |>

type compilation_unit_header = 
    <| 
    cuh_offset: natural; 
    cuh_dwarf_format: dwarf_format;
    cuh_unit_length: natural;
    cuh_version: natural;
    cuh_debug_abbrev_offset: natural;
    cuh_address_size: natural;
  |> 
    
type compilation_unit = 
    <| 
    cu_header: compilation_unit_header;
    cu_abbreviations_table: abbreviations_table;
    cu_die: die;
  |>

type compilation_units = list compilation_unit

type type_unit_header = 
    <| 
    tuh_cuh: compilation_unit_header;
    tuh_type_signature: natural;
    tuh_type_offset: natural;
  |> 

type type_unit = 
    <| 
    tu_header: type_unit_header;
    tu_abbreviations_table: abbreviations_table;
    tu_die: die;
  |>

type type_units = list type_unit

type single_location_description = list byte

type location_list_entry =
    <|
    lle_beginning_address_offset: natural;
    lle_ending_address_offset: natural;
    lle_single_location_description: single_location_description;
  |>

type base_address_selection_entry =
    <|
    base_address: natural;
  |>

type location_list_item =
  | LLI_lle of location_list_entry
  | LLI_base of base_address_selection_entry

type location_list = natural (*offset*) * list location_list_item

type location_list_list = list location_list 


type range_list_entry =
    <|
    rle_beginning_address_offset: natural;
    rle_ending_address_offset: natural;
  |>

type range_list_item =
  | RLI_rle of range_list_entry
  | RLI_base of base_address_selection_entry

type range_list = natural (*offset*) * list range_list_item

type range_list_list = list range_list 

    
type dwarf = 
    <| 
    d_str: list byte;
    d_compilation_units: compilation_units;
    d_type_units: type_units;
    d_loc: location_list_list;
    d_ranges: range_list_list;
  |>


(** lookup of encodings *)

val lookup_Ab_b : forall 'a 'b. Eq 'a => 'a -> list ('a * 'b) -> maybe 'b
let rec lookup_Ab_b x0 xys = 
  match xys with
  | [] -> Nothing
  | (x,y)::xys' -> if x=x0 then Just y else lookup_Ab_b x0 xys'  
  end

val lookup_aB_a : forall 'a 'b. Eq 'b => 'b -> list ('a * 'b) -> maybe 'a
let rec lookup_aB_a y0 xys = 
  match xys with
  | [] -> Nothing
  | (x,y)::xys' -> if y=y0 then Just x else lookup_aB_a y0 xys'  
  end


val lookup_aBc_a : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe 'a
let rec lookup_aBc_a y0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if y=y0 then Just x else lookup_aBc_a y0 xyzs'  
  end

val lookup_aBc_ac : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe ('a*'c)
let rec lookup_aBc_ac y0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,z)::xyzs' -> if y=y0 then Just (x,z) else lookup_aBc_ac y0 xyzs'  
  end

val lookup_Abc_b : forall 'a 'b 'c. Eq 'a => 'a -> list ('a * 'b * 'c) -> maybe 'b
let rec lookup_Abc_b x0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if x=x0 then Just y else lookup_Abc_b x0 xyzs'  
  end



val lookup_aBcd_a : forall 'a 'b 'c 'd. Eq 'b => 'b -> list ('a * 'b * 'c * 'd) -> maybe 'a
let rec lookup_aBcd_a y0 xyzws = 
  match xyzws with
  | [] -> Nothing
  | (x,y,_,_)::xyzws' -> if y=y0 then Just x else lookup_aBcd_a y0 xyzws'  
  end

val lookup_aBcd_acd : forall 'a 'b 'c 'd. Eq 'b => 'b -> list ('a * 'b * 'c * 'd) -> maybe ('a * 'c * 'd)
let rec lookup_aBcd_acd y0 xyzws = 
  match xyzws with
  | [] -> Nothing
  | (x,y,z,w)::xyzws' -> if y=y0 then Just (x,z,w) else lookup_aBcd_acd y0 xyzws'  
  end


let pp_maybe ppf n = match ppf n with Just s -> s | Nothing -> "encoding not found: " ^ pphex n end

let pp_tag_encoding n = pp_maybe (fun n -> lookup_aB_a n tag_encodings) n
let pp_attribute_encoding n = pp_maybe (fun n -> lookup_aBc_a n attribute_encodings) n
let pp_attribute_form_encoding n = pp_maybe (fun n -> lookup_aBc_a n attribute_form_encodings) n
let pp_operation_encoding n = pp_maybe (fun n -> lookup_aBcd_a n operation_encodings) n

let tag_encode (s: string) : natural = 
  match lookup_Ab_b s tag_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_encode"
  end


let attribute_encode (s: string) : natural = 
  match lookup_Abc_b s attribute_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_encode"
  end

let attribute_form_encode (s: string) : natural = 
  match lookup_Abc_b s attribute_form_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_form_encode"
  end


(** basic parsing *)

(* parsing combinators *)

type parse_context = <| pc_bytes: list byte; pc_offset: natural |> 

type parse_result 'a =
  | PR_success of 'a * parse_context
  | PR_fail of string * parse_context

type parser 'a = parse_context -> parse_result 'a

let pp_parse_context pc = "pc_offset = " ^ pphex pc.pc_offset

let pp_parse_fail s pc = 
  "Parse fail\n" ^ s ^ " at " ^ pp_parse_context pc ^ "\n"

let pp_parse_result ppa pr = 
  match pr with
  | PR_success x pc -> "Parse success\n" ^ ppa x ^ "\n" ^ pp_parse_context pc ^ "\n"
  | PR_fail s pc -> pp_parse_fail s pc  
  end

(* [(>>=)] should be the monadic binding function for [parse_result].  *)
(* but there's a type clash if we use >>=, and lem seems to output bad ocaml for >>>=. So we just use a non-infix version for now *)

val pr_bind : forall 'a 'b. parse_result 'a -> ('a -> parser 'b) -> parse_result 'b
let pr_bind x f =
  match x with
  | PR_success v pc -> f v pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_return : forall 'a. 'a -> (parser 'a)
let pr_return x pc = PR_success x pc

val pr_map : forall 'a 'b. ('a -> 'b) -> parse_result 'a -> parse_result 'b
let pr_map f x =
  match x with
  | PR_success v pc -> PR_success (f v) pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_map2 : forall 'a 'b. ('a -> 'b) -> (parser 'a) -> (parser 'b)
let pr_map2 f p = fun pc -> pr_map f (p pc)

val pr_post_map1 : forall 'a 'b. (parse_result 'a) -> ('a -> 'b) -> (parse_result 'b)
let pr_post_map1 x f = pr_map f x

(*
val pr_post_map : forall 'a 'b 'c. ('c -> parse_result 'a) -> ('a -> 'b) -> ('c -> parse_result 'b)
let pr_post_map g f = fun x ->  pr_map f (g x)
*)
val pr_post_map : forall 'a 'b. (parser 'a) -> ('a -> 'b) -> (parser 'b)
let pr_post_map p f = fun (pc: parse_context) -> pr_map f (p pc)


val pr_with_pos : forall 'a. (parser 'a) -> (parser (natural * 'a))
let pr_with_pos p = fun pc -> pr_map (fun x -> (pc.pc_offset,x)) (p pc)


val parse_pair : forall 'a 'b. (parser 'a) -> (parser 'b) -> (parser ('a * 'b))
let parse_pair p1 p2 = 
  fun pc -> 
    let _ = my_debug "pair " in 
    pr_bind (p1 pc) (fun x pc' -> match p2 pc' with 
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)

val parse_triple : forall 'a 'b 'c. (parser 'a) -> (parser 'b) -> (parser 'c) -> parser ('a * ('b * 'c))
let parse_triple p1 p2 p3 = 
  parse_pair p1 (parse_pair p2 p3)

val parse_quadruple : forall 'a 'b 'c 'd. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> parser ('a * ('b * ('c * 'd)))
let parse_quadruple p1 p2 p3 p4 = 
  parse_pair p1 (parse_pair p2 (parse_pair p3 p4))

val parse_pentuple : forall 'a 'b 'c 'd 'e. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> (parser 'e) -> parser ('a * ('b * ('c * ('d * 'e))))
let parse_pentuple p1 p2 p3 p4 p5 = 
  parse_pair p1 (parse_pair p2 (parse_pair p3 (parse_pair p4 p5)))

val parse_sextuple : forall 'a 'b 'c 'd 'e 'f. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> (parser 'e) -> (parser 'f) -> parser ('a * ('b * ('c * ('d * ('e * 'f)))))
let parse_sextuple p1 p2 p3 p4 p5 p6 = 
  parse_pair p1 (parse_pair p2 (parse_pair p3 (parse_pair p4 (parse_pair p5 p6))))

val parse_dependent_pair : forall 'a 'b. (parser 'a) -> ('a -> parser 'b) -> (parser ('a * 'b))
let parse_dependent_pair p1 p2 = 
  fun pc -> 
    pr_bind (p1 pc) (fun x pc' -> match p2 x pc' with 
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)



val parse_list' : forall 'a. (parser (maybe 'a)) -> (list 'a -> parser (list 'a))
let rec parse_list' p1 =
  fun acc pc ->   let _ = my_debug "list' " in pr_bind (p1 pc) (fun mx pc' -> 
    match mx with
    | Nothing -> PR_success acc pc'
    | Just x -> parse_list' p1 (x :: acc) pc'
    end)

val parse_list : forall 'a. (parser (maybe 'a)) -> (parser (list 'a))
let parse_list p1 = 
  pr_post_map 
    (parse_list' p1 [])
    (List.reverse) 

val parse_parser_list : forall 'a. (list (parser 'a)) -> (parser (list 'a))
let rec parse_parser_list ps = 
  match ps with
  | [] -> pr_return []
  | p::ps' -> 
      (fun pc -> pr_bind (p pc) (fun x pc' -> 
        match parse_parser_list ps' pc' with
        | PR_success xs pc'' -> PR_success (x::xs) pc''
        | PR_fail s pc'' -> PR_fail s pc''
        end))
  end



(* parsing of basic types *)

let rec mytake' (n:natural) acc xs = 
  match (n,xs) with
  | (0, _) -> Just (List.reverse acc, xs)
  | (_, []) -> Nothing
  | (_, x::xs') -> mytake' (n-1) (x::acc) xs'
  end

val mytake : forall 'a.  natural -> (list 'a) -> maybe (list 'a * list 'a)
let mytake n xs = mytake' n [] xs

let parse_n_bytes (n:natural) : parser (list byte) =
    fun (pc:parse_context) -> 
      match mytake n pc.pc_bytes with
      | Nothing -> PR_fail ("parse_n_bytes n=" ^ pphex n) pc
      | Just (xs,bs) -> PR_success xs (<|pc_bytes=bs; pc_offset= pc.pc_offset + naturalFromNat (List.length xs) |> )
      end

let rec mytakestring' acc xs = 
  match xs with
  | [] -> Nothing
  | x::xs' -> if natural_of_byte x = 0 then Just (List.reverse acc, xs') else mytakestring' (x::acc) xs'
  end

let parse_string : parser (list byte) =
    fun (pc:parse_context) ->
      match mytakestring' [] pc.pc_bytes with
      | Nothing -> PR_fail "parse_string" pc
      | Just (xs,bs) -> PR_success xs (<|pc_bytes=bs; pc_offset = pc.pc_offset + naturalFromNat (List.length xs) + naturalFromNat 1 |> )
      end

let parse_uint8 c : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint8 " in
      match pc.pc_bytes with
      | b0::bytes' -> 
          let v = natural_of_byte b0 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint16 c : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint16 " in
      match pc.pc_bytes with
      | b0::b1::bytes' -> 
          let v = if c.endianness=Little then 
            natural_of_byte b0 + 256*natural_of_byte b1 
          else 
            natural_of_byte b1 + 256*natural_of_byte b0 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 2 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint32 c : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint32 " in
      match pc.pc_bytes with
      | b0::b1::b2::b3::bytes' -> 
          let v = if c.endianness=Little then 
            natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3 
          else 
            natural_of_byte b3 + 256*natural_of_byte b2 + 256*256*natural_of_byte b1 + 256*256*256*natural_of_byte b0 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 4 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint64 c : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint64 " in
      match pc.pc_bytes with
      | b0::b1::b2::b3::b4::b5::b6::b7::bytes' -> 
          let v = if c.endianness=Little then 
            natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3 
              + (256*256*256*256*(natural_of_byte b4 + 256*natural_of_byte b5 + 256*256*natural_of_byte b6 + 256*256*256*natural_of_byte b7))
          else
            natural_of_byte b7 + 256*natural_of_byte b6 + 256*256*natural_of_byte b5 + 256*256*256*natural_of_byte b4 
              + (256*256*256*256*(natural_of_byte b3 + 256*natural_of_byte b2 + 256*256*natural_of_byte b1 + 256*256*256*natural_of_byte b0))
          in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 8 |>)
      | _ -> PR_fail "parse_uint64 not given enough bytes" pc
      end

let integerFromTwosComplementNatural (n:natural) (half: natural) (all:integer) : integer = 
  if n < half then integerFromNatural n else integerFromNatural n - all

let partialTwosComplementNaturalFromInteger (i:integer) (half: natural) (all:integer) : natural = 
  if i >=0 && i < integerFromNatural half then partialNaturalFromInteger i
  else if i >= (0-integerFromNatural half) && i < 0 then partialNaturalFromInteger (all + i)
  else Assert_extra.failwith "partialTwosComplementNaturalFromInteger"


let parse_sint8 c : parser integer = 
  pr_post_map (parse_uint8 c) (fun n -> integerFromTwosComplementNatural n 128 256)

let parse_sint16 c : parser integer = 
  pr_post_map (parse_uint16 c) (fun n -> integerFromTwosComplementNatural n (128*256) (256*256))

let parse_sint32 c : parser integer = 
  pr_post_map (parse_uint32 c) (fun n -> integerFromTwosComplementNatural n (128*256*256*256) (256*256*256*256))

let parse_sint64 c : parser integer = 
  pr_post_map (parse_uint64 c) (fun n -> integerFromTwosComplementNatural n (128*256*256*256*256*256*256*256) (256*256*256*256*256*256*256*256))

let rec parse_ULEB128' (acc: natural) (shift_factor: natural) : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "ULEB128' " in
      match pc.pc_bytes with
      | b::bytes' -> 
          let n = natural_of_byte b in
          let acc' = (natural_land n 127) * shift_factor + acc in
          let finished = ((natural_land n 128) = 0) in
          let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
          if finished then 
            PR_success acc' pc'
          else
            parse_ULEB128' acc' (shift_factor * 128) pc'
      | _ ->
          PR_fail "parse_ULEB128' not given enough bytes" pc
      end    

let parse_ULEB128 : parser natural = 
  fun (pc:parse_context) ->
    parse_ULEB128' 0 1 pc

let rec parse_SLEB128' (acc: natural) (shift_factor: natural) : parser (bool * natural * natural) = 
    fun (pc:parse_context) ->
      let _ = my_debug "SLEB128' " in
      match pc.pc_bytes with
      | b::bytes' -> 
          let n = natural_of_byte b in
          let acc' = acc + (natural_land n 127) * shift_factor in
          let shift_factor' = shift_factor * 128 in
          let finished = ((natural_land n 128) = 0) in
          let positive = ((natural_land n 64) = 0) in
          let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
          if finished then 
            PR_success (positive, shift_factor', acc') pc'
          else
            parse_SLEB128' acc' shift_factor' pc'
      | _ ->
          PR_fail "parse_SLEB128' not given enough bytes" pc
      end    

let parse_SLEB128 : parser integer = 
    pr_post_map (parse_SLEB128' 0 1) (fun (positive, shift_factor, acc) ->
       if positive then integerFromNatural acc else integerFromNatural acc - integerFromNatural shift_factor)
    
let parse_nonzero_ULEB128_pair : parser (maybe (natural*natural)) =
  let _ = my_debug "nonzero_ULEB128_pair " in
  pr_post_map 
    (parse_pair parse_ULEB128 parse_ULEB128)
    (fun (n1,n2) -> if n1=0 && n2=0 then Nothing else Just (n1,n2))

let parse_zero_terminated_ULEB128_pair_list : parser (list (natural*natural)) = 
  let _ = my_debug "zero_terminated_ULEB128_pair_list " in
  parse_list parse_nonzero_ULEB128_pair 

let parse_uintDwarfN c (df: dwarf_format) : parser natural =
    match df with
    | Dwarf32 -> (parse_uint32 c)
    | Dwarf64 -> (parse_uint64 c)
    end

let parse_uint_address_size c (as': natural) : parser natural =
    match as' with
    | 4 -> (parse_uint32 c)
    | 8 -> (parse_uint64 c)
    | _ -> Assert_extra.failwith "cuh_address_size not 4 or 8"
    end



(** abbreviations table: pp and parsing *)

let pp_abbreviation_declaration (x:abbreviation_declaration) =
  "   " 
  ^ show x.ad_abbreviation_code ^ "      " 
  ^ pp_tag_encoding x.ad_tag ^ "    " 
  ^ (if x.ad_has_children then "[has children]" else "[no children]")
  ^ "\n"
(*  ^ " "^show (List.length x.ad_attribute_specifications) ^ " attributes\n"*)
  ^ myconcat "" 
      (List.map 
         (fun (n1,n2) ->
           "    " ^ pp_attribute_encoding n1 ^ "     " ^ pp_attribute_form_encoding n2 ^ "\n") 
         x.ad_attribute_specifications)

let pp_abbreviations_table (x:abbreviations_table) = 
  myconcat "" (List.map (pp_abbreviation_declaration) x)

let parse_abbreviation_declaration c : parser (maybe abbreviation_declaration) =
    fun (pc: parse_context) -> 
      pr_bind (parse_ULEB128 pc) (fun n1 pc' -> 
        if n1 = 0 then 
          PR_success Nothing pc'
        else 
          pr_bind (parse_ULEB128 pc') (fun n2 pc'' -> 
            pr_bind (parse_uint8 c pc'') (fun c pc''' -> 
              pr_post_map1 
                (parse_zero_terminated_ULEB128_pair_list pc''')
                (fun l ->
                  Just ( let ad = 
                    <|
                    ad_abbreviation_code = n1;
                    ad_tag = n2;
                    ad_has_children = (c<>0);
                    ad_attribute_specifications = l;
                  |> in let _ = my_debug2 (pp_abbreviation_declaration ad) in ad)
                ))))

let parse_abbreviations_table c =
  parse_list (parse_abbreviation_declaration c)


(** debug_str entry *)

val mydrop : forall 'a. natural -> list 'a -> maybe (list 'a)
let rec mydrop n xs = 
  if n=0 then Just xs 
  else 
    match xs with
    | x::xs' -> mydrop (n-1) xs' 
    | [] -> Nothing
    end

let rec null_terminated_list (acc: list byte) (xs: list byte) : list byte = 
  match xs with
  | [] -> List.reverse acc (* TODO: flag failure? *)
  | x::xs' -> if natural_of_byte x = 0 then List.reverse acc else null_terminated_list (x::acc) xs'
  end

let pp_debug_str_entry (str: list byte) (n: natural) =
  match mydrop n str with
  | Nothing -> "strp beyond .debug_str extent"
  | Just xs -> string_of_bytes (null_terminated_list [] xs)
  end

(** operations: pp and parsing *)

let pp_operation_argument_value (oav:operation_argument_value) : string =
  match oav with
  | OAV_natural n -> pphex n
  | OAV_integer n -> show n
  | OAV_block n bs -> pphex n ^ " " ^ ppbytes bs
  end

let pp_operation_semantics (os: operation_semantics) : string =
  match os with
  | OpSem_lit                         -> "OpSem_lit"                          
  | OpSem_deref                       -> "OpSem_deref"                        
  | OpSem_stack _                     -> "OpSem_stack ..."
  | OpSem_not_supported               -> "OpSem_not_supported"
  | OpSem_binary _                    -> "OpSem_binary ..."
  | OpSem_unary _                     -> "OpSem_unary ..."
  | OpSem_opcode_lit _                -> "OpSem_opcode_lit ..."
  | OpSem_reg                         -> "OpSem_reg"                         
  | OpSem_breg                        -> "OpSem_breg"                         
  | OpSem_bregx                       -> "OpSem_bregx"                        
  | OpSem_fbreg                       -> "OpSem_fbreg"                        
  | OpSem_deref_size                  -> "OpSem_deref_size"                   
  | OpSem_nop                         -> "OpSem_nop"                          
  | OpSem_piece                       -> "OpSem_piece"                        
  | OpSem_bitpiece                    -> "OpSem_bitpiece"                     
  | OpSem_implicit_value              -> "OpSem_implicit_value"
  | OpSem_stack_value                 -> "OpSem_stack_value"                  
  | OpSem_call_frame_cfa              -> "OpSem_call_frame_cfa"                
  end

let pp_operation (op: operation) : string =
  op.op_string ^ " " ^ myconcat " " (List.map pp_operation_argument_value op.op_argument_values) ^ " (" ^ pp_operation_semantics op.op_semantics ^ ")"

let pp_operations (ops: list operation) : string =
  myconcat "; " (List.map pp_operation ops)

val parser_of_operation_argument_type : p_context -> compilation_unit_header -> operation_argument_type -> (parser operation_argument_value)
let parser_of_operation_argument_type c cuh oat = 
  match oat with
    | OAT_addr -> 
        match cuh.cuh_address_size with
        | 4 -> pr_map2 (fun n -> OAV_natural n) (parse_uint32 c)
        | 8 -> pr_map2 (fun n -> OAV_natural n) (parse_uint64 c)
        | _ -> Assert_extra.failwith "cuh_address_size not 4 or 8"
        end
    | OAT_dwarf_format_t ->
        match cuh.cuh_dwarf_format with
        | Dwarf32 -> pr_map2 (fun n -> OAV_natural n) (parse_uint32 c)
        | Dwarf64 -> pr_map2 (fun n -> OAV_natural n) (parse_uint64 c)
        end
    | OAT_uint8   -> pr_map2 (fun n -> OAV_natural n) (parse_uint8 c)
    | OAT_uint16  -> pr_map2 (fun n -> OAV_natural n) (parse_uint16 c)
    | OAT_uint32  -> pr_map2 (fun n -> OAV_natural n) (parse_uint32 c)
    | OAT_uint64  -> pr_map2 (fun n -> OAV_natural n) (parse_uint64 c)
    | OAT_sint8   -> pr_map2 (fun n -> OAV_integer n) (parse_sint8 c)
    | OAT_sint16  -> pr_map2 (fun n -> OAV_integer n) (parse_sint16 c)
    | OAT_sint32  -> pr_map2 (fun n -> OAV_integer n) (parse_sint32 c)
    | OAT_sint64  -> pr_map2 (fun n -> OAV_integer n) (parse_sint64 c)
    | OAT_ULEB128 -> pr_map2 (fun n -> OAV_natural n) parse_ULEB128
    | OAT_SLEB128 -> pr_map2 (fun n -> OAV_integer n) parse_SLEB128
    | OAT_block   ->
      (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
        pr_map (fun bs -> OAV_block n bs) (parse_n_bytes n pc')))
  end

val parse_operation : p_context -> compilation_unit_header -> parser (maybe operation)
let parse_operation c cuh pc = 
  match parse_uint8 c pc with
  | PR_fail s pc' -> PR_success Nothing pc
  | PR_success code pc' ->
      match lookup_aBcd_acd code operation_encodings with
      | Nothing -> PR_fail ("encoding not found: " ^ pphex code) pc 
      | Just (s,oats,opsem) -> 
          let ps = List.map (parser_of_operation_argument_type c cuh) oats in
          (pr_post_map 
            (parse_parser_list ps) 
            (fun oavs -> Just <| op_code = code; op_string = s; op_argument_values = oavs; op_semantics = opsem |>)
          )
            pc'
      end
  end

val parse_operations : p_context -> compilation_unit_header -> parser (list operation)
let parse_operations c cuh =
  parse_list (parse_operation c cuh)

val parse_and_pp_operations : p_context -> compilation_unit_header -> list byte -> string
let parse_and_pp_operations c cuh bs =
  let pc = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_operations c cuh pc with
  | PR_fail s pc' -> "parse_operations fail: " ^ pp_parse_fail s pc'
  | PR_success ops pc' ->
      pp_operations ops 
      ^ if pc'.pc_bytes <> [] then " Warning: extra non-parsed bytes" else ""
  end


(** attribute values: pp and parsing *)

val pp_attribute_value : p_context -> compilation_unit_header -> list byte -> natural (*attribute tag*) -> attribute_value -> string
let pp_attribute_value c cuh str at av = 
  match av with
  | AV_addr x -> "AV_addr " ^ pphex x
  | AV_block n bs -> "AV_block " ^ show n ^ " " ^ ppbytes bs
      ^ if at = attribute_encode "DW_AT_location" then " " ^ parse_and_pp_operations c cuh bs else ""
  | AV_constantN n bs -> "AV_constantN " ^ show n ^ " " ^ ppbytes bs
  | AV_constant_SLEB128 i -> "AV_constant_SLEB128 " ^ show i
  | AV_constant_ULEB128 n -> "AV_constant_ULEB128 " ^ show n
  | AV_exprloc n bs -> "AV_exprloc " ^ show n ^ " " ^ ppbytes bs
      ^ " " ^ parse_and_pp_operations c cuh bs
  | AV_flag b -> "AV_flag " ^ show b
  | AV_ref n -> "AV_ref " ^ pphex n
  | AV_ref_addr n -> "AV_ref_addr " ^ pphex n 
  | AV_ref_sig8 n -> "AV_ref_sig8 " ^ pphex n 
  | AV_sec_offset n -> "AV_sec_offset " ^ pphex  n
  | AV_string bs -> string_of_bytes bs
  | AV_strp n -> "AV_sec_offset " ^ pphex n ^ " " 
      ^ pp_debug_str_entry str n
  end


val parser_of_attribute_form_non_indirect : p_context -> compilation_unit_header -> natural -> parser attribute_value
let parser_of_attribute_form_non_indirect c cuh n = 
(* address*)
  if n = attribute_form_encode "DW_FORM_addr"         then 
    pr_map2 (fun n -> AV_addr n) (parse_uint_address_size c cuh.cuh_address_size)
(* block *)
  else if n = attribute_form_encode "DW_FORM_block1"       then 
    (fun pc -> pr_bind (parse_uint8 c pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block2"       then 
    (fun pc -> pr_bind (parse_uint16 c pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block4"       then 
    (fun pc -> pr_bind (parse_uint32 c pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block"        then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
(* constant *)
  else if n = attribute_form_encode "DW_FORM_data1"        then 
    pr_map2 (fun bs -> AV_block 1 bs) (parse_n_bytes 1)
  else if n = attribute_form_encode "DW_FORM_data2"        then 
    pr_map2 (fun bs -> AV_block 2 bs) (parse_n_bytes 2)
  else if n = attribute_form_encode "DW_FORM_data4"        then 
    pr_map2 (fun bs -> AV_block 4 bs) (parse_n_bytes 4)
  else if n = attribute_form_encode "DW_FORM_data8"        then 
    pr_map2 (fun bs -> AV_block 8 bs) (parse_n_bytes 8)
  else if n = attribute_form_encode "DW_FORM_sdata"        then 
    pr_map2 (fun i -> AV_constant_SLEB128 i) parse_SLEB128
  else if n = attribute_form_encode "DW_FORM_udata"        then 
    pr_map2 (fun n -> AV_constant_ULEB128 n) parse_ULEB128
(* exprloc *)
  else if n = attribute_form_encode "DW_FORM_exprloc"      then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_exprloc n bs) (parse_n_bytes n pc')))
(* flag *)
  else if n = attribute_form_encode "DW_FORM_flag"         then 
    pr_map2 (fun n -> AV_flag (n<>0)) (parse_uint8 c)
  else if n = attribute_form_encode "DW_FORM_flag_present" then 
    pr_map2 (fun () -> AV_flag true) (pr_return ())
(* lineptr, loclistptr, macptr, rangelistptr *)
  else if n = attribute_form_encode "DW_FORM_sec_offset"   then 
    pr_map2 (fun n -> AV_sec_offset n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
(* reference - first type *)
  else if n = attribute_form_encode "DW_FORM_ref1"         then 
    pr_map2 (fun n -> AV_ref n) (parse_uint8 c)
  else if n = attribute_form_encode "DW_FORM_ref2"         then 
    pr_map2 (fun n -> AV_ref n) (parse_uint16 c)
  else if n = attribute_form_encode "DW_FORM_ref4"         then 
    pr_map2 (fun n -> AV_ref n) (parse_uint32 c)
  else if n = attribute_form_encode "DW_FORM_ref8"         then 
    pr_map2 (fun n -> AV_ref n) (parse_uint64 c)
  else if n = attribute_form_encode "DW_FORM_ref_udata"    then 
    pr_map2 (fun n -> AV_ref n) parse_ULEB128
(* reference - second type *)
  else if n = attribute_form_encode "DW_FORM_ref_addr"     then 
    pr_map2 (fun n -> AV_ref_addr n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
(* reference - third type *)
  else if n = attribute_form_encode "DW_FORM_ref_sig8"     then 
    pr_map2 (fun n -> AV_ref_sig8 n) (parse_uint64 c)
(* string *)
  else if n = attribute_form_encode "DW_FORM_string"       then 
    pr_map2 (fun bs -> AV_string bs) parse_string
  else if n = attribute_form_encode "DW_FORM_strp"         then 
    pr_map2 (fun n -> AV_strp n) (parse_uintDwarfN c cuh.cuh_dwarf_format)
(* indirect (cycle detection) *)
  else if n = attribute_form_encode "DW_FORM_indirect"     then 
    Assert_extra.failwith "DW_FORM_INDIRECT cycle"
(* unknown *)
  else
    Assert_extra.failwith "parser_of_attribute_form_non_indirect: unknown attribute form"


let parser_of_attribute_form c cuh n = 
  if n = attribute_form_encode "DW_FORM_indirect" then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n ->
      parser_of_attribute_form_non_indirect c cuh n) )
  else 
    parser_of_attribute_form_non_indirect c cuh n 

(** attribute find *)

let find_name str ats : maybe string =
  myfindmaybe 
    (fun (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) -> 
      if attribute_encode "DW_AT_name" = at then 
        let name = 
          match av with 
          | AV_string bs -> string_of_bytes bs
          | AV_strp n -> pp_debug_str_entry str n
          | _ -> "av_name AV not understood"
          end in
        Just name
      else
        Nothing)
    ats

let find_attribute_value (an: string) (die:die) : maybe attribute_value =
  let at = attribute_encode an in
  let ats = List.zip 
      die.die_abbreviation_declaration.ad_attribute_specifications 
      die.die_attribute_values in
  myfindmaybe 
    (fun  (((at': natural), (af: natural)), ((pos: natural),(av:attribute_value))) -> 
      if at' = at then Just av else Nothing) 
    ats

(** compilation unit header: pp and parsing *)

let pp_unit_header (s:string) (x:compilation_unit_header) : string = 
    "  " ^ s ^ " Unit @ offset " ^ pphex x.cuh_offset ^ ":\n"
  ^ "   Length:        " ^ pphex x.cuh_unit_length ^ " " ^ match x.cuh_dwarf_format with Dwarf32 -> "(32-bit)" | Dwarf64 -> "(64-bit)" end ^ "\n"
  ^ "   Version:       " ^ show x.cuh_version ^ "\n"
  ^ "   Abbrev Offset: " ^ pphex x.cuh_debug_abbrev_offset ^ "\n"
  ^ "   Pointer Size:  " ^ show x.cuh_address_size ^ "\n"

let pp_compilation_unit_header (x:compilation_unit_header) : string = 
  pp_unit_header "Compilation" x

let parse_unit_length c : parser (dwarf_format * natural) =
    fun (pc: parse_context) -> 
      pr_bind (parse_uint32 c pc) (fun x pc' ->
        if x < natural_of_hex "0xfffffff0" then PR_success (Dwarf32,x) pc'
        else if x <> natural_of_hex "0xffffffff" then PR_fail "bad unit_length" pc
        else 
          pr_bind (parse_uint64 c pc') (fun x' pc'' -> 
            PR_success (Dwarf64, x') pc'))
      

let parse_compilation_unit_header c : parser compilation_unit_header = 
    pr_post_map 
      (pr_with_pos 
         (parse_dependent_pair 
            (parse_unit_length c)
            (fun (df,ul) -> 
              parse_triple 
                (parse_uint16 c) (* version *)
                (parse_uintDwarfN c df) (* debug abbrev offset *)
                (parse_uint8 c) (* address_size *))))
      (fun (offset,((df,ul), (v, (dao, as')))) -> 
        <|
        cuh_offset = offset;
        cuh_dwarf_format = df;
        cuh_unit_length = ul;
        cuh_version = v;
        cuh_debug_abbrev_offset = dao;
        cuh_address_size = as';
      |>)


(** type unit header: pp and parsing *)

(* the test binaries don't have a .debug_types section, so this isn't tested *)

let pp_type_unit_header (x:type_unit_header) : string = 
  pp_unit_header "Type" x.tuh_cuh
  ^ "   Type Signature:  " ^ pphex x.tuh_type_signature ^ "\n"
  ^ "   Type Offset:  " ^ pphex x.tuh_type_offset ^ "\n"

      
let parse_type_unit_header c : parser type_unit_header = 
    pr_post_map 
      (parse_dependent_pair 
         (parse_compilation_unit_header c)
         (fun cuh ->
           parse_pair 
             (parse_uint64 c) (* type signature *)
             (parse_uintDwarfN c cuh.cuh_dwarf_format) (* type offset *) ))
      (fun (cuh, (ts, to')) -> 
        <|
        tuh_cuh = cuh;
        tuh_type_signature = ts;
        tuh_type_offset = to';
      |>)
        

(** debugging information entries: pp and parsing *)

(* example pp from readelf
 <2><51>: Abbrev Number: 3 (DW_TAG_variable)
    <52>   DW_AT_name        : x	
    <54>   DW_AT_decl_file   : 1	
    <55>   DW_AT_decl_line   : 2	
    <56>   DW_AT_type        : <0x6a>	
    <5a>   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
*)

let pp_pos pos = "<" ^ pphex pos ^">"

let pp_die_attribute c (cuh:compilation_unit_header) (str : list byte) (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) : string = 
  pp_pos pos  ^ "   " 
  ^ pp_attribute_encoding at ^ "     : "
  ^ "(" ^ pp_attribute_form_encoding af ^ ") "
  ^ pp_attribute_value c cuh str at av
  ^ "\n"

val pp_die : p_context -> compilation_unit_header -> list byte -> natural -> bool -> die -> string
let rec pp_die c cuh str level (pp_children:bool) die = 
  "<" ^ show level ^ ">" 
  ^ pp_pos die.die_offset
  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code 
  ^ " (" ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^")\n"
  ^
    let ats = List.zip 
        die.die_abbreviation_declaration.ad_attribute_specifications 
        die.die_attribute_values in
    (myconcat "" (List.map (pp_die_attribute c cuh str) ats))
    ^
      if pp_children then myconcat "" (List.map (pp_die c cuh str (level +1) pp_children) die.die_children) else ""

val pp_die_abbrev : p_context -> compilation_unit_header -> list byte -> natural -> bool -> (list die) -> die -> string
let rec pp_die_abbrev c cuh str level (pp_children:bool) parents die = 
  (toString (replicate (2 * level) #' '))
  ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag
  ^ " (" ^ pp_pos die.die_offset ^ ") "
(*  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code *)
  ^
    let ats = List.zip 
        die.die_abbreviation_declaration.ad_attribute_specifications 
        die.die_attribute_values in
    (match find_name str ats with Just s -> s | Nothing -> "-" end) 
    ^ "   :  " ^ myconcat " : " (List.map (fun die' ->  pp_tag_encoding die'.die_abbreviation_declaration.ad_tag) parents)
    ^ "\n"            
    ^ (*(myconcat "" (List.map (pp_die_abbrev_attribute c cuh str) ats))*)

      if pp_children then myconcat "" (List.map (pp_die_abbrev c cuh str (level +1) pp_children (die::parents)) die.die_children) else ""



val parse_die : p_context -> list byte -> compilation_unit_header -> (natural->abbreviation_declaration) -> parser (maybe die)
let rec parse_die c str cuh find_abbreviation_declaration = 
  fun (pc: parse_context) ->
    let _ = my_debug3 ("parse_die called at " ^ pp_parse_context pc ^ "\n") in
    pr_bind (parse_ULEB128 pc) (fun abbreviation_code pc' -> 
      if abbreviation_code = 0 then PR_success Nothing pc' 
      else
        let _ = my_debug3 ("parse_die abbreviation code "^pphex abbreviation_code ^"\n") in
        let ad = find_abbreviation_declaration abbreviation_code in
        let attribute_value_parsers = List.map (fun (at,af) -> pr_with_pos (parser_of_attribute_form c cuh af)) ad.ad_attribute_specifications in
        pr_bind (parse_parser_list attribute_value_parsers pc') (fun avs pc'' ->

(*          
          let die_header = 
            <| 
            die_offset = pc.pc_offset;
            die_abbreviation_code = abbreviation_code;
            die_abbreviation_declaration = ad;
            die_attribute_values = avs;
            die_children = [];
          |> in let _ = my_debug3 ("die_header " ^ pp_die cuh str 999 die_header) in 
  *)          
            pr_bind 
              (if ad.ad_has_children then parse_list (parse_die c str cuh find_abbreviation_declaration) pc'' else pr_return [] pc'')
              (fun dies pc''' -> 
                PR_success (Just ( let die = 
                  <| 
                  die_offset = pc.pc_offset;
                  die_abbreviation_code = abbreviation_code;
                  die_abbreviation_declaration = ad;
                  die_attribute_values = avs;
                  die_children = dies;
                |> in (* let _ = my_debug3 ("die entire " ^ pp_die cuh str 999 die) in *)die)) pc''')))

let has_attribute (an: string) (die: die) : bool = 
  List.elem 
    (attribute_encode an)
    (List.map Tuple.fst die.die_abbreviation_declaration.ad_attribute_specifications)


(** compilation units: pp and parsing *)

let pp_compilation_unit c (debug_str_section_body: list byte) cu = 
  pp_compilation_unit_header cu.cu_header
  ^ pp_abbreviations_table cu.cu_abbreviations_table
  ^ pp_die c cu.cu_header debug_str_section_body 0 true cu.cu_die

let pp_compilation_units c debug_string_section_body (compilation_units: list compilation_unit) : string = 
  myconcat "" (List.map (pp_compilation_unit c debug_string_section_body) compilation_units)


let pp_compilation_unit_abbrev c (debug_str_section_body: list byte) cu = 
  pp_compilation_unit_header cu.cu_header
(*  ^ pp_abbreviations_table cu.cu_abbreviations_table*)
  ^ pp_die_abbrev c cu.cu_header debug_str_section_body 0 true [] cu.cu_die

let pp_compilation_units_abbrev c debug_string_section_body (compilation_units: list compilation_unit) : string = 
  myconcat "" (List.map (pp_compilation_unit_abbrev c debug_string_section_body) compilation_units)

                        
let parse_compilation_unit c (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte) : parser (maybe compilation_unit) =
    fun (pc:parse_context) ->
  
      if pc.pc_bytes = [] then PR_success Nothing pc else
      
      let (cuh, pc') = 

        match parse_compilation_unit_header c pc with
        | PR_fail s pc' -> Assert_extra.failwith ("parse_cuh_header fail: " ^ pp_parse_fail s pc')
        | PR_success cuh pc' -> (cuh,pc')
        end in

      let _ = my_debug4 (pp_compilation_unit_header cuh) in 

      let pc_abbrev = <|pc_bytes = match mydrop cuh.cuh_debug_abbrev_offset debug_abbrev_section_body with Just bs -> bs | Nothing -> Assert_extra.failwith "mydrop of debug_abbrev" end; pc_offset = cuh.cuh_debug_abbrev_offset  |> in

      let abbreviations_table = 
        match parse_abbreviations_table c pc_abbrev with
        | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
        | PR_success at pc_abbrev' -> at
        end in

      let _ = my_debug4 (pp_abbreviations_table abbreviations_table) in

      let find_abbreviation_declaration (ac:natural) : abbreviation_declaration = 
        let _ = my_debug4 ("find_abbreviation_declaration "^pphex ac) in 
        myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table  in

      let _ = my_debug3 (pp_abbreviations_table abbreviations_table) in

      match parse_die c debug_str_section_body cuh find_abbreviation_declaration pc' with
      | PR_fail s pc'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc'')
      | PR_success (Nothing) pc'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc'')
      | PR_success (Just die) pc'' -> 
          let cu = 
            <| 
            cu_header = cuh;
            cu_abbreviations_table = abbreviations_table;
            cu_die = die;
          |> in
          PR_success (Just cu) pc''
      end 

let parse_compilation_units c (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte): parser (list compilation_unit) 
    =
  parse_list (parse_compilation_unit c debug_str_section_body debug_abbrev_section_body)


(** type units: pp and parsing *)

let pp_type_unit c (debug_str_section_body: list byte) tu = 
  pp_type_unit_header tu.tu_header
  ^ pp_abbreviations_table tu.tu_abbreviations_table
  ^ pp_die c tu.tu_header.tuh_cuh debug_str_section_body 0 true tu.tu_die

let pp_type_units c debug_string_section_body (type_units: list type_unit) : string = 
  myconcat "" (List.map (pp_type_unit c debug_string_section_body) type_units)

                        
let parse_type_unit c (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte) : parser (maybe type_unit) =
    fun (pc:parse_context) ->
  
      if pc.pc_bytes = [] then PR_success Nothing pc else
      
      let (tuh, pc') = 
        match parse_type_unit_header c pc with
        | PR_fail s pc' -> Assert_extra.failwith ("parse_tuh_header fail: " ^ pp_parse_fail s pc')
        | PR_success tuh pc' -> (tuh,pc')
        end in

      let _ = my_debug4 (pp_type_unit_header tuh) in 

      let pc_abbrev = let n = tuh.tuh_cuh.cuh_debug_abbrev_offset in <|pc_bytes = match mydrop n debug_abbrev_section_body with Just bs -> bs | Nothing -> Assert_extra.failwith "mydrop of debug_abbrev" end; pc_offset = n  |> in

      let abbreviations_table = 
        match parse_abbreviations_table c pc_abbrev with
        | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
        | PR_success at pc_abbrev' -> at
        end in

      let _ = my_debug4 (pp_abbreviations_table abbreviations_table) in

      let find_abbreviation_declaration (ac:natural) : abbreviation_declaration = 
        let _ = my_debug4 ("find_abbreviation_declaration "^pphex ac) in 
        myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table  in

      let _ = my_debug3 (pp_abbreviations_table abbreviations_table) in

      match parse_die c debug_str_section_body tuh.tuh_cuh find_abbreviation_declaration pc' with
      | PR_fail s pc'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc'')
      | PR_success (Nothing) pc'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc'')
      | PR_success (Just die) pc'' -> 
          let tu = 
            <| 
            tu_header = tuh;
            tu_abbreviations_table = abbreviations_table;
            tu_die = die;
          |> in
          PR_success (Just tu) pc''
      end 

let parse_type_units c (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte): parser (list type_unit) 
      =
    parse_list (parse_type_unit c debug_str_section_body debug_abbrev_section_body)

(** location lists *)

(* readelf example
Contents of the .debug_loc section:

    Offset   Begin    End      Expression
    00000000 0000000000400168 0000000000400174 (DW_OP_reg0 (r0))
    00000000 0000000000400174 0000000000400184 (DW_OP_GNU_entry_value: (DW_OP_reg0 (r0)); DW_OP_stack_value)
    00000000 <End of list>
    00000039 000000000040017c 0000000000400180 (DW_OP_lit1; DW_OP_stack_value)
*)

let pp_location_list_entry c (cuh:compilation_unit_header) (offset:natural) (x:location_list_entry) : string =
  "    " ^ pphex offset 
  ^ " " ^ pphex x.lle_beginning_address_offset
  ^ " " ^ pphex x.lle_ending_address_offset
  ^ " (" ^ parse_and_pp_operations c cuh x.lle_single_location_description ^")"
  ^ "\n"

let pp_base_address_selection_entry c (cuh:compilation_unit_header) (offset:natural) (x:base_address_selection_entry) : string =
  "    " ^ pphex offset 
  ^ " " ^ pphex x.base_address
  ^ "\n"

let pp_location_list_item c (cuh: compilation_unit_header) (offset: natural) (x:location_list_item) = 
  match x with
  | LLI_lle lle -> pp_location_list_entry c cuh offset lle
  | LLI_base base -> pp_base_address_selection_entry c cuh offset base
  end

let pp_location_list c (cuh: compilation_unit_header) ((offset:natural), (llis: list location_list_item)) =
  myconcat "" (List.map (pp_location_list_item c cuh offset) llis)
(*  ^ "    " ^ pphex offset  ^ " <End of list>\n"*)
                               
let pp_loc c (cuh: compilation_unit_header) (lls: list location_list) =
  "    Offset   Begin    End      Expression\n"
  ^  myconcat "" (List.map (pp_location_list c cuh) lls)

(* Note that this is just pp'ing the raw location list data - Sectoin
3.1.1 says: The applicable base address of a location list entry is
determined by the closest preceding base address selection entry in
the same location list. If there is no such selection entry, then the
applicable base address defaults to the base address of the
compilation unit *)


      
let parse_location_list_item c (cuh: compilation_unit_header) : parser (maybe location_list_item) =
    fun (pc:parse_context) -> 
      pr_bind 
        (parse_pair 
           (parse_uint_address_size c cuh.cuh_address_size)
           (parse_uint_address_size c cuh.cuh_address_size)
           pc)
        (fun ((a1: natural),(a2:natural)) pc' ->
          let _ = my_debug4 ("offset="^pphex pc.pc_offset ^ " begin=" ^ pphex a1 ^ " end=" ^ pphex a2) in
          if a1=0 && a2=0 then
            PR_success Nothing pc'
          else if a1 = max_address cuh.cuh_address_size then
            let x = LLI_base <| (*base_offset=pc.pc_offset;*) base_address=a1 |> in
            PR_success (Just x (*(pc.pc_offset, x)*)) pc'
          else
            pr_bind (parse_uint16 c pc') (fun n pc'' -> 
              pr_post_map1
                (parse_n_bytes n pc'') 
                (fun bs -> 
                  let x = 
                    LLI_lle <| 
                    (*lle_offset = pc.pc_offset;*)
                    lle_beginning_address_offset = a1;
                    lle_ending_address_offset = a2;
                    lle_single_location_description = bs;
                  |> in
                  Just x (*(pc.pc_offset, x)*))
                                        )
        )

let parse_location_list c cuh : parser (maybe location_list) =
    fun (pc: parse_context) -> 
      if pc.pc_bytes = [] then 
        PR_success Nothing pc
      else
        pr_post_map1 
          (parse_list (parse_location_list_item c cuh) pc)
          (fun llis -> (Just (pc.pc_offset, llis)))

let parse_location_list_list c cuh : parser location_list_list =
    parse_list (parse_location_list c cuh)

let find_location_list dloc n : location_list = 
  myfindNonPure (fun (n',_)-> n'=n) dloc
  (* fails if location list not found *)

let rec interpret_location_list (base_address: natural) (llis: list location_list_item) : list (natural * natural * single_location_description) =
  match llis with
  | [] -> []
  | LLI_base base::llis' -> interpret_location_list base.base_address llis'
  | LLI_lle lle :: llis' -> (base_address+lle.lle_beginning_address_offset, base_address+lle.lle_ending_address_offset, lle.lle_single_location_description) :: interpret_location_list base_address llis'
  end


(** range lists *)

(* readelf example
Contents of the .debug_aranges section:

  Length:                   44
  Version:                  2
  Offset into .debug_info:  0x0
  Pointer Size:             8
  Segment Size:             0

    Address            Length
    00000000100000e8 0000000000000090 
    0000000000000000 0000000000000000 
  Length:                   44
  Version:                  2
  Offset into .debug_info:  0x1de
  Pointer Size:             8
  Segment Size:             0
*)

let pp_range_list_entry c (cuh:compilation_unit_header) (offset:natural) (x:range_list_entry) : string =
  "    " ^ pphex offset 
  ^ " " ^ pphex x.rle_beginning_address_offset
  ^ " " ^ pphex x.rle_ending_address_offset
  ^ "\n"

let pp_range_list_item c (cuh: compilation_unit_header) (offset: natural) (x:range_list_item) = 
  match x with
  | RLI_rle rle -> pp_range_list_entry c cuh offset rle
  | RLI_base base -> pp_base_address_selection_entry c cuh offset base
  end

let pp_range_list c (cuh: compilation_unit_header) ((offset:natural), (rlis: list range_list_item)) =
  myconcat "" (List.map (pp_range_list_item c cuh offset) rlis)
(*  ^ "    " ^ pphex offset  ^ " <End of list>\n"*)
                               
let pp_ranges c (cuh: compilation_unit_header) (rls: list range_list) =
  "    Offset   Begin    End      Expression\n"
  ^  myconcat "" (List.map (pp_range_list c cuh) rls)

(* Note that this is just pp'ing the raw range list data - Section
3.1.1 says (for location lists and range lists): The applicable base
address of a location list entry is determined by the closest
preceding base address selection entry in the same location list. If
there is no such selection entry, then the applicable base address
defaults to the base address of the compilation unit *)


      
let parse_range_list_item c (cuh: compilation_unit_header) : parser (maybe range_list_item) =
    fun (pc:parse_context) -> 
      pr_bind 
        (parse_pair 
           (parse_uint_address_size c cuh.cuh_address_size)
           (parse_uint_address_size c cuh.cuh_address_size)
           pc)
        (fun ((a1: natural),(a2:natural)) pc' ->
          let _ = my_debug4 ("offset="^pphex pc.pc_offset ^ " begin=" ^ pphex a1 ^ " end=" ^ pphex a2) in
          if a1=0 && a2=0 then
            PR_success Nothing pc'
          else if a1 = max_address cuh.cuh_address_size then
            let x = RLI_base <| base_address=a1 |> in
            PR_success (Just x) pc'
          else
            let x = 
              RLI_rle <| 
                    rle_beginning_address_offset = a1;
                    rle_ending_address_offset = a2;
                  |> in
                  PR_success (Just x (*(pc.pc_offset, x)*)) pc'
        )

let parse_range_list c cuh : parser (maybe range_list) =
    fun (pc: parse_context) -> 
      if pc.pc_bytes = [] then 
        PR_success Nothing pc
      else
        pr_post_map1 
          (parse_list (parse_range_list_item c cuh) pc)
          (fun rlis -> (Just (pc.pc_offset, rlis)))

let parse_range_list_list c cuh : parser range_list_list =
    parse_list (parse_range_list c cuh)

let find_range_list dranges n : range_list = 
  myfindNonPure (fun (n',_)-> n'=n) dranges
  (* fails if range list not found *)

let rec interpret_range_list (base_address: natural) (rlis: list range_list_item) : list (natural * natural) =
  match rlis with
  | [] -> []
  | RLI_base base::rlis' -> interpret_range_list base.base_address rlis'
  | RLI_rle rle :: rlis' -> (base_address+rle.rle_beginning_address_offset, base_address+rle.rle_ending_address_offset) :: interpret_range_list base_address rlis'
  end




(** all dwarf info: pp and parsing *)

let pp_dwarf c d = 
  "************** abbrev ****************\n"
  ^ pp_compilation_units_abbrev c d.d_str d.d_compilation_units 
  ^ "************** full ****************\n"
  ^ pp_compilation_units c d.d_str d.d_compilation_units 
  ^ "\n"
  ^ let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in
    pp_loc c cuh_default d.d_loc
  ^
    pp_ranges c cuh_default d.d_ranges
    
let parse_dwarf c
    (debug_info_section_body: list byte) 
    (debug_abbrev_section_body: list byte) 
    (debug_str_section_body: list byte) 
    (debug_loc_section_body: list byte) 
    (debug_ranges_section_body: list byte) 
    : dwarf =

  let pc_info = <|pc_bytes = debug_info_section_body; pc_offset = 0  |> in
  
  let compilation_units = 
    match parse_compilation_units c debug_str_section_body debug_abbrev_section_body pc_info with
    | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_compilation_units: " ^ pp_parse_fail s pc_info')
    | PR_success cus pc_info' -> cus
    end in

(* the DWARF4 spec doesn't seem to specify the address size used in the .debug_loc section, so we (hackishly) take it from the first compilation unit *)
    let (cuh_default : compilation_unit_header) = let cu = myhead compilation_units in cu.cu_header in

    let pc_loc = <|pc_bytes = debug_loc_section_body; pc_offset = 0  |> in

    let loc = 
      match parse_location_list_list c cuh_default pc_loc with
      | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_location_list: " ^ pp_parse_fail s pc_info')
      | PR_success loc pc_loc' -> loc
      end in

    let pc_ranges = <|pc_bytes = debug_ranges_section_body; pc_offset = 0  |> in

    let ranges = 
      match parse_range_list_list c cuh_default pc_ranges with
      | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_range_list: " ^ pp_parse_fail s pc_info')
      | PR_success loc pc_loc' -> loc
      end in

   <| 
   d_str = debug_str_section_body;
   d_compilation_units = compilation_units;
   d_type_units = []; 
   d_loc = loc;
   d_ranges = ranges;
  |>


(** interpreting locations *)


(* cf dwarflist, btw: https://fedorahosted.org/elfutils/wiki/DwarfLint?format=txt *)

(*

location description ::=
| single location description
| location list

single location description ::=
| simple location description
| composite location description

simple location description ::=
| memory location description : non-empty dwarf expr, value is address of all or part of object in memory
| register location description : single DW_OP_regN or DW_OP_regx, naming a register in which all the object is
| implicit location description : single DW_OP_implicit_value or a non-empty dwarf expr ending in DW_OP_stack_value, giving the value of all/part of object
| empty location description : an empty dwarf expr, indicating a part or all of an object that is not represented

composite location description : a list of simple location descriptions, each followed by a DW_OP_piece or DW_OP_bitpiece

(the simple location description can be a register location description: https://www.mail-archive.com/dwarf-discuss@lists.dwarfstd.org/msg00271.html)
(contradicting "A register location description must stand alone as the entire description of an object or a piece of an object.")

location list entry : a list of address ranges (possibly overlapping), each with a single location description

Dwarf expressions can include data-dependent control flow choices
(though we don't see that in the examples?), so we can't statically
determine which kind of single location description or simple location
description we have.  We can distinguish:

- empty -> simple.empty
- DW_OP_regN/DW_OP_regx -> simple.register 
- DW_OP_implicit_value -> simple.implicit
- any of those followed by DW_OP_piece or DW_OP_bitpiece, perhaps followed by more composite parts -> composite part :: composite

otherwise run to the end, or a DW_OP_stack_value at the end, or to
anything (except a DO_OP_regN/DW_OP_regx) followed by a
DW_OP_piece/DW_OP_bitpiece. Pfeh.


actually used in our examples (ignoring GNU extentions):

DW_OP_addr         literal
DW_OP_lit1         literal
DW_OP_const4u      literal                

DW_OP_breg3 (r3)   read register value and add offset

DW_OP_and          bitwise and
DW_OP_plus         addition (mod whatever)

DW_OP_deref_size                   
DW_OP_fbreg        evaluate location description from DW_AT_frame_base attribute of the current function (which is DW_OP_call_frame_cfa in our examples) and add offset
           
DW_OP_implicit_value   the argument block is the actual value (not location) of the entity in question
DW_OP_stack_value      use the value at top of stack as the actual value (not location) of the entity in question

DW_OP_reg0 (r0))       read register value

DW_OP_call_frame_cfa   go off to 6.4 and pull info out of .debug_frame (possibly involving other location expressions)

*)


(* the result of a location expression evaluation is a single_location  (or failure) *)

type simple_location = 
  | SL_memory_address of natural
  | SL_register of natural
  | SL_implicit of list byte  (* used for implicit and stack values *)
  | SL_empty

type composite_location_piece = 
  | CLP_piece of natural * simple_location
  | CLP_bit_piece of natural * natural * simple_location

type single_location =
  | SL_simple of simple_location
  | SL_composite of list composite_location_piece

(* location expression evaluation can involve register and memory reads, via the following interface *)

type register_read_result 'a =
  | RRR_result of natural
  | RRR_not_currently_available
  | RRR_bad_register_number

type memory_read_result 'a =
  | MRR_result of natural
  | MRR_not_currently_available
  | MRR_bad_address

type evaluation_context = 
    <| 
    read_register : natural -> register_read_result natural;
    read_memory : natural -> natural -> memory_read_result natural;
  |>

(* location expression evaluation is basically a recursive function
down a list of operations, maintaining an operation_stack (a list of
naturals representing machine-address-size words), the current
simple_location, and a list of any composite_location_piece's
accumulated so far *)

type state = 
    <| 
    s_stack: operation_stack;
    s_value: simple_location;
    s_location_pieces: list composite_location_piece;
  |>

let initial_state = 
  <|
  s_stack = [];
  s_value = SL_empty;
  s_location_pieces = [];
|>
  
(* the main location expression evaluation function *)

let rec evaluate_operation_list (c:p_context) (dloc: location_list_list) (cuh: compilation_unit_header) (ac: arithmetic_context) (ev: evaluation_context) (mfbloc: maybe attribute_value) (pc: natural) (s: state) (ops: list operation) : error single_location =

  let push_memory_address v vs' = Success <| s with s_stack = v :: vs'; s_value = SL_memory_address v |>  in

  let push_memory_address_maybe (mv: maybe natural) vs' (err:string) op = 
    match mv with
    | Just v -> push_memory_address v vs'
    | Nothing -> Fail (err ^ pp_operation op)
    end in

  let bregxi r i = 
    match ev.read_register r with
    | RRR_result v -> push_memory_address (partialNaturalFromInteger ((integerFromNatural v+i) mod (integerFromNatural ac.ac_all))) s.s_stack
    | RRR_not_currently_available -> Fail "RRR_not_currently_available"
    | RRR_bad_register_number -> Fail "RRR_bad_register_number"
    end in

  let deref_size n = 
    match s.s_stack with
    | v::vs' -> 
        match ev.read_memory v n with
        | MRR_result v' -> push_memory_address v' vs'
        | MRR_not_currently_available -> Fail "MRR_not_currently_available"
        | MRR_bad_address -> Fail "MRR_bad_address"
        end
    | _ -> Fail "OpSem unary not given an element on stack"
    end in

  match ops with
  | [] -> 
      if s.s_location_pieces = [] then 
        Success (SL_simple s.s_value)
      else if s.s_value = SL_empty then
        Success (SL_composite s.s_location_pieces)
      else
        (*  unclear what's supposed to happen in this case *)
        Fail "unfinished part of composite expression"
         
  | op::ops' -> 
      let es' = 
        match (op.op_semantics, op.op_argument_values)  with
        | (OpSem_nop, []) -> 
            Success s
        | (OpSem_lit, [OAV_natural n]) -> 
            push_memory_address n s.s_stack
        | (OpSem_lit, [OAV_integer i]) -> 
            push_memory_address (partialTwosComplementNaturalFromInteger i ac.ac_half (integerFromNatural ac.ac_all)) s.s_stack
        | (OpSem_stack f, []) -> 
            match f ac s.s_stack op.op_argument_values with 
            | Just stack' ->  
                let value' : simple_location = match stack' with [] -> SL_empty | v'::_ -> SL_memory_address v' end in 
                Success <| s with s_stack = stack'; s_value = value' |>
            | Nothing -> Fail "OpSem_stack failed"
            end
        | (OpSem_not_supported, []) -> 
            Fail ("OpSem_not_supported: " ^ pp_operation op)
        | (OpSem_binary f, []) -> 
            match s.s_stack with
            | v1::v2::vs' -> push_memory_address_maybe (f ac v1 v2) vs' "OpSem_binary error: " op
            | _ -> Fail "OpSem binary not given two elements on stack"
            end
        | (OpSem_unary f, []) -> 
            match s.s_stack with
            | v1::vs' -> push_memory_address_maybe (f ac v1) vs' "OpSem_unary error: " op
            | _ -> Fail "OpSem unary not given an element on stack"
            end
        | (OpSem_opcode_lit base, []) -> 
            if op.op_code >= base && op.op_code < base + 32 then
              push_memory_address (op.op_code - base) s.s_stack
            else
              Fail "OpSem_opcode_lit opcode not within [base,base+32)"
        | (OpSem_reg, []) -> 
            (* TODO: unclear whether this should push the register id or not *)
            let r = op.op_code - vDW_OP_reg0 in   
            Success <| s with s_stack = r :: s.s_stack; s_value = SL_register r |>  
        | (OpSem_breg, [OAV_integer i]) ->  
            let r = op.op_code - vDW_OP_breg0 in
            bregxi r i
        | (OpSem_bregx, [OAV_natural r; OAV_integer i]) -> 
            bregxi r i
        | (OpSem_deref, []) ->
            deref_size cuh.cuh_address_size 
        | (OpSem_deref_size, [OAV_natural n]) -> 
            deref_size n
        | (OpSem_fbreg, [OAV_integer i]) ->  
            match mfbloc with
            | Just fbloc ->
                match evaluate_location_description c dloc cuh ac ev (*mfbloc*)Nothing pc fbloc with
                (* what to do if the recursive call also uses fbreg?  for now assume that's not allowed *)
                | Success l ->
                    match l with 
                    | SL_simple (SL_memory_address a) ->
                        let vi = ((integerFromNatural a) + i) mod (integerFromNatural ac.ac_all) in
                        let v = partialTwosComplementNaturalFromInteger vi ac.ac_half (integerFromNatural ac.ac_all) in
                        push_memory_address v s.s_stack
                    | _ ->
                        Fail "OpSem_fbreg got a non-SL_simple (SL_memory_address _) result"
                       (* "The DW_OP_fbreg operation provides a signed LEB128
                           offset from the address specified by the location
                           description in the DW_AT_frame_base attribute of the
                           current function. " 
                          - so what to do if the location description returns a non-memory-address location?  *)
                    end
                | Fail e ->
                    Fail ("OpSem_fbreg failure: " ^ e)
                end 
            | Nothing -> 
                Fail "OpSem_fbreg: no frame base location description given"
            end

        | (OpSem_piece, [OAV_natural size_bytes]) ->  
            let piece = CLP_piece size_bytes s.s_value in
            (* we allow a piece (or bit_piece) to be any simple_location, including implicit and stack values. Unclear if this is intended, esp. the latter *)
            let stack' = [] in
            let value' = SL_empty in
            Success <| s with s_stack = stack'; s_value = value'; s_location_pieces = s.s_location_pieces ++ [piece] |>
        | (OpSem_bit_piece, [OAV_natural size_bits; OAV_natural offset_bits]) -> 
            let piece = CLP_bit_piece size_bits offset_bits s.s_value in
            let stack' = [] in
            let value' = SL_empty in
            Success <| s with s_stack = stack'; s_value = value'; s_location_pieces = s.s_location_pieces ++ [piece] |>
        | (OpSem_implicit_value, [OAV_block size bs]) -> 
            let stack' = [] in
            let value' = SL_implicit bs in
            Success <| s with s_stack = stack'; s_value = value' |>
        | (OpSem_stack_value, []) -> 
            (* "The DW_OP_stack_value operation terminates the expression." - does
               this refer to just the subexpression, ie allowing a stack value to be
               a piece of a composite location, or necessarily the whole expression?
               Why does DW_OP_stack_value have this clause while DW_OP_implicit_value
               does not? *)
            (* why doesn't DW_OP_stack_value have a size argument? *)
            match s.s_stack with
            | v::vs' -> 
                let stack' = [] in
                let value' = SL_implicit (bytes_of_natural c.endianness cuh.cuh_address_size v) in
                Success <| s with s_stack = stack'; s_value = value' |>
      
            | _ -> Fail "OpSem_stack_value not given an element on stack"
            end
        | (OpSem_call_frame_cfa, []) ->  
            Fail "OpSem_call_frame_cfa not implemented"
        | (_, _) ->
            Fail ("bad OpSem invocation: op=" ^ pp_operation op ^ " arguments=" ^ myconcat "" (List.map pp_operation_argument_value op.op_argument_values))
        end 
      in
      match es' with
      | Success s' ->
          evaluate_operation_list c dloc cuh ac ev mfbloc pc s' ops'
      | Fail e ->
          Fail e
      end
  end

and evaluate_location_description_bytes (c:p_context) (dloc: location_list_list) (cuh: compilation_unit_header) (ac: arithmetic_context) (ev: evaluation_context) (mfbloc: maybe attribute_value) (pc: natural) (bs: list byte) : error single_location =
  let parse_context = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_operations c cuh parse_context with
  | PR_fail s pc' -> Fail ("evaluate_location_description_bytes: parse_operations fail: " ^ pp_parse_fail s pc')
  | PR_success ops pc' -> 
      if pc'.pc_bytes <> [] then 
        Fail "evaluate_location_description_bytes: extra non-parsed bytes" 
      else 
        evaluate_operation_list c dloc cuh ac ev mfbloc pc initial_state ops
  end

and evaluate_location_description (c:p_context) (dloc: location_list_list) (cuh: compilation_unit_header) (ac: arithmetic_context) (ev: evaluation_context) (mfbloc: maybe attribute_value) (pc: natural) (loc:attribute_value) : error single_location =
  match loc with 
  | AV_exprloc n bs ->
      evaluate_location_description_bytes c dloc cuh ac ev mfbloc pc bs
  | AV_block n bs -> 
      evaluate_location_description_bytes c dloc cuh ac ev mfbloc pc bs
  | AV_sec_offset n -> 
      let location_list = find_location_list dloc n in 
      let (offset,(llis:list location_list_item)) = location_list in 
      let f (lli:location_list_item) : maybe single_location_description = 
        match lli with
        | LLI_lle lle ->
           if pc >= lle.lle_beginning_address_offset && pc < lle.lle_ending_address_offset then Just lle.lle_single_location_description else Nothing
        | LLI_base _ -> 
           Nothing  (* TODO: either refactor to do offset during parsing or update base offsets here*)
        end in
        match myfindmaybe f llis with
        | Just bs ->
            evaluate_location_description_bytes c dloc cuh ac ev mfbloc pc bs
        | Nothing ->
            Fail "evaluate_location_description didn't find pc in location list ranges"
        end
  | _ -> Fail "evaluate_location_description av_location not understood"
  end 


(** analysis *)
   
val find_dies_in_die : (die->bool) -> compilation_unit -> list die -> die -> list (compilation_unit * (list die) * die)
let rec find_dies_in_die (p:die->bool) (cu:compilation_unit) (parents: list die) (d: die) = 
  let ds = List.concatMap (find_dies_in_die p cu (d::parents)) d.die_children in
  if p d then (cu,parents,d)::ds else ds
    
let find_dies (p:die->bool) (d: dwarf) : list (compilation_unit * (list die) * die) =
  List.concatMap
    (fun cu -> find_dies_in_die p cu [] cu.cu_die) 
    d.d_compilation_units 


(* simple-minded analysis of location *)

let analyse_locations_raw c (d: dwarf) = 

  let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in
  
  (* find all DW_TAG_variable and DW_TAG_formal_parameter dies with a DW_AT_name attribute *)
  let tags = List.map tag_encode ["DW_TAG_variable"; "DW_TAG_formal_parameter"] in
  let dies : list (compilation_unit * (list die) * die) = 
    find_dies 
      (fun die -> 
        List.elem die.die_abbreviation_declaration.ad_tag tags
          && has_attribute "DW_AT_name" die) 
      d in

  myconcat "" 
    (List.map 
       (fun (cu,parents,die) -> 
         
         let ats = List.zip 
             die.die_abbreviation_declaration.ad_attribute_specifications 
             die.die_attribute_values in
         
         let find_ats (s:string) = myfindNonPure (fun  (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) -> attribute_encode s = at) ats in
         
         let ((_,_),(_,av_name)) = find_ats "DW_AT_name" in 
         
         let name = 
           match av_name with 
           | AV_string bs -> string_of_bytes bs
           | AV_strp n -> pp_debug_str_entry d.d_str n
           | _ -> "av_name AV not understood"
           end in


         let ((_,_),(_,av_location)) = find_ats "DW_AT_location" in 

         let ppd_location = 
           match av_location with 
           | AV_exprloc n bs -> "    "^parse_and_pp_operations c cuh_default bs^"\n"
           | AV_block n bs -> "    "^parse_and_pp_operations c cuh_default bs^"\n"
           | AV_sec_offset n -> 
               let location_list = myfindNonPure (fun (n',_)-> n'=n) d.d_loc in
               pp_location_list c cuh_default location_list 
           | _ -> "av_location AV not understood"
           end in 
   
         pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^ " " ^ name ^ ":\n" ^ ppd_location ^ "\n" )
                 
       dies)
    

(* more proper analysis of locations *)



(*  TODO: handle this:
In a variable entry representing the definition of a variable (that is, with no
DW_AT_declaration attribute) if no location attribute is present, or if the location attribute is
present but has an empty location description (as described in Section 2.6), the variable is
assumed to exist in the source code but not in the executable program (but see number 10,
below).
In a variable entry representing a non-defining declaration of a variable, the location
specified modifies the location specified by the defining declaration and only applies for the
scope of the variable entry; if no location is specified, then the location specified in the
defining declaration applies.
The location of a variable may be further specified with a DW_AT_segment attribute, if
appropriate.
*)


(*  

if there's a DW_AT_location that's a location list (DW_FORM_sec_offset/AV_sec_offset) : use that for both the range(s) and location; interpret the range(s) wrt the applicable base address of the compilation unit 

if there's a DW_AT_location that's a location expression (DW_FORM_exprloc/AV_exprloc or DW_block/AV_block), look for the closest enclosing range:
 - DW_AT_low_pc (AV_addr) and no DW_AT_high_pc or DW_AT_ranges: just the singleton address
 - DW_AT_low_pc (AV_addr) and DW_AT_high_pc (either an absolute AV_addr or an offset AV_constantN/AV_constant_SLEB128/AV_constantULEB128) : that range
 - DW_AT_ranges (DW_FORM_sec_offset/AV_sec_offset) : get a range list from .debug_ranges; interpret wrt the applicable base address of the compilation unit 
 - for compilation units: a DW_AT_ranges together with a DW_AT_low_pc to specify the default base address to use in interpeting location and range lists

DW_OP_fbreg in location expressions evaluate the DW_AT_frame_base of
the closest enclosing function - which is either a location expression
or a location list (what happens if the ranges of that location list
don't cover where we are?)

For each variable and formal parameter that has a DW_AT_name, we'll calculate a list of pairs of a concrete (low,high) range and a location expression.



 *)

let rec closest_enclosing_range (dranges: range_list_list) (cu_base_address: natural) (parents: list die) : maybe (list (natural * natural)) = 
  match parents with
  | [] -> Nothing
  | die::parents' ->
      match (find_attribute_value "DW_AT_low_pc" die, find_attribute_value "DW_AT_high_pc" die, find_attribute_value "DW_AT_ranges" die) with
      | (Just (AV_addr n),  Nothing,                       Nothing               ) -> Just [(n,n+1)]   (* unclear if this case is used? *)
      | (Just (AV_addr n1), Just (AV_addr n2),             Nothing               ) -> Just [(n1,n2)] 
      | (Just (AV_addr n1), Just (AV_constant_ULEB128 n2), Nothing               ) -> Just [(n1, n1+n2)] (* should be mod all? *)
      | (Just (AV_addr n1), Just (AV_constant_SLEB128 i2), Nothing               ) -> Just [(n1, naturalFromInteger (integerFromNatural n1 + i2))] (* should
 be mod all? *)
      | (Just (AV_addr n1), Just (AV_constantN _ _),       Nothing               ) -> Assert_extra.failwith "AV_constantN in closest_enclosing_range"
      | (_,                 Nothing,                       Just (AV_sec_offset n)) -> 
          let rlis = Tuple.snd (find_range_list dranges n) in
          let nns = interpret_range_list cu_base_address rlis in
          Just nns
      | (Nothing,           Nothing,                       Nothing               ) -> closest_enclosing_range dranges cu_base_address parents' 
      | (_,                 _,                             _                     ) -> Assert_extra.failwith "unexpected attribute values in closest_enclosing_range"
      end
  end

(*
If one of the DW_FORM_data<n> forms is used to represent a signed or unsigned integer, it
can be hard for a consumer to discover the context necessary to determine which
interpretation is intended. Producers are therefore strongly encouraged to use
DW_FORM_sdata or DW_FORM_udata for signed and unsigned integers respectively,
rather than DW_FORM_data<n>.
no kidding - if we get an AV_constantN for DW_AT_high_pc, should it be interpreted as signed or unsigned? *)

let interpreted_location_of_die (dloc: location_list_list) (dranges: range_list_list) (base_address: natural) (parents: list die) (die: die) : maybe (list (natural * natural * single_location_description)) = 

  let location bs = match closest_enclosing_range dranges base_address (die::parents) with
  | Just (_,rlis) -> 
      let nns = interpret_range_list base_address rlis in
      Just (List.map (fun (n1,n2) -> (n1,n2,bs)) nns)
  | Nothing -> Assert_extra.failwith "no enclosing range"
  end in

  match find_attribute_value "DW_AT_location" die with 
  | Just (AV_exprloc n bs) -> location bs
  | Just (AV_block n bs) -> location bs
  | Just (AV_sec_offset n) -> 
      let (_,llis) = find_location_list dloc n in 
      Just (interpret_location_list base_address llis)
  | Nothing -> Nothing
  end 


let analyse_locations c (d: dwarf) : list ((compilation_unit * (list die) * die) * maybe (list (natural * natural * single_location_description))) = 

  let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in
  
  (* find all DW_TAG_variable and DW_TAG_formal_parameter dies with a DW_AT_name attribute *)
  let tags = List.map tag_encode ["DW_TAG_variable"; "DW_TAG_formal_parameter"] in
  let dies : list (compilation_unit * (list die) * die) = 
    find_dies 
      (fun die -> 
        List.elem die.die_abbreviation_declaration.ad_tag tags
          && has_attribute "DW_AT_name")
      d in

  List.map 
    (fun (((cu:compilation_unit), (parents: list die), (die: die)) as x) -> 
      let cu_base_address = match find_attribute_value "DW_AT_low_pc" cu.cu_die with Just (AV_addr n) -> n | _ -> Assert_extra.failwith "no cu DW_AT_low_pc" end in

      let interpreted_locations : maybe (list (natural * natural * single_location_description)) = 
        interpreted_location_of_die d.d_loc d.d_ranges cu_base_address parents die in
      (x,interpreted_locations)
    ) 
    dies



let pp_analysed_locations1 c cuh (nnls: list (natural * natural * single_location_description)) : string = 
  myconcat ""
    (List.map 
       (fun (n1,n2,bs) -> "  " ^ pphex n1 ^ "  " ^ pphex n2 ^ parse_and_pp_operations c cuh bs ^ "\n")
       nnls)

let pp_analysed_locations2 c cuh mnnls = 
  match mnnls with
  | Just nnls -> pp_analysed_locations1 c cuh nnls
  | Nothing -> "  <no locations>\n"
  end

let pp_analysed_locations3 c cuh str (als: list ((compilation_unit * (list die) * die) * maybe (list (natural * natural * single_location_description)))) : string = 
  myconcat "\n"
    (List.map 
       (fun ((cu,parents,die),mnnls) ->
         pp_die_abbrev c cuh str 0 false parents die
         ^ pp_analysed_locations2 c cuh mnnls
       )
       als
  )
    

      


(** top level *)

let just_one s xs = 
  match xs with
  | [] -> Assert_extra.failwith ("no " ^ s)
  | x1::x2::_ -> Assert_extra.failwith ("more than one " ^ s)
  | [x] -> x
  end

val harness_string_of_elf64_debug_info_section : elf64_file -> byte_sequence -> (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf64_debug_info_section f1 bs0 os proc usr hdr sht stbl =

  let (en: Endianness.endianness) = Elf_header.get_elf64_header_endianness f1.Elf_file.elf64_file_header in 
  let (c: p_context) = <| endianness = en |> in
  let extract_section_body section_name = 
    let sections = 
      List.filter 
        (fun x -> 
          x.Elf_interpreted_section.elf64_section_name_as_string = section_name
        ) f1.elf64_file_interpreted_sections in
    let section = just_one (section_name ^ " sections")  sections  in
    let section_body =  match section.Elf_interpreted_section.elf64_section_body with Sequence bs -> bs end in
    let _ = my_debug4 (section_name ^ ": \n" ^ Elf_interpreted_section.string_of_elf64_interpreted_section section ^ "\n"
                          ^ "  body = " ^ ppbytes2 0 section_body ^ "\n") in
    section_body in

  let debug_abbrev_section_body = extract_section_body ".debug_abbrev" in
  let debug_info_section_body = extract_section_body ".debug_info" in
  let debug_str_section_body = extract_section_body ".debug_str" in
  let debug_loc_section_body = extract_section_body ".debug_loc" in
  let debug_ranges_section_body = extract_section_body ".debug_ranges" in

  let d = parse_dwarf c debug_info_section_body debug_abbrev_section_body debug_str_section_body debug_loc_section_body debug_ranges_section_body in
  pp_dwarf c d
   ^ analyse_locations_raw c d    

   ^ " ********************************\n"
   ^ 
     let (cuh_default : compilation_unit_header) = let cu = myhead d.d_compilation_units in cu.cu_header in
     pp_analysed_locations3 c (*HACK*) cuh_default d.d_str analyse_locations c d 

val harness_string_of_elf32_debug_info_section : elf32_file -> byte_sequence -> (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf32_debug_info_section f1 bs0 os proc usr hdr sht stbl =
  "NOT IMPLEMENTED"
