open import Basic_classes
open import Bool
open import Function
open import Maybe
open import Num
open import String

open import Byte_sequence
open import Error
open import Hex_printing
open import Missing_pervasives
open import Show

open import Default_printing

open import Endianness
open import String_table

open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint


(** ***************** experimental DWARF reading *********** *)

(** debug *)

(* workaround debug.lem linking *)
val print_endline : string -> unit
declare ocaml target_rep function print_endline = `print_endline`

let my_debug s = () (*print_endline s*)
let my_debug2 s = () (*print_endline s*)
let my_debug3 s = () (*print_endline s*)
let my_debug4 s = () (*print_endline s*)


(** hex parsing *)

(* should be in lem, either built-in or in pervasives *)

val natural_of_char : char -> natural 
let natural_of_char c =
  let naturalOrd c' = naturalFromNat (String_extra.ord c') in
  let n = naturalOrd c in 
  if n >= naturalOrd #'0' && n <= naturalOrd #'9' then n - naturalOrd #'0' 
  else if n >= naturalOrd #'A' && n <= naturalOrd #'F' then n - naturalOrd #'A' + 10
  else if n >= naturalOrd #'a' && n <= naturalOrd #'f' then n - naturalOrd #'a' + 10
  else Assert_extra.failwith ("natural_of_char argument #'" ^ String.toString [c] ^ "' not in 0-9,A-F,a-f")

val natural_of_hex' : list char -> natural
let rec natural_of_hex' cs = 
  match cs with
  | c :: cs' -> natural_of_char c + 16 * natural_of_hex' cs'
  | [] -> 0
  end

val natural_of_hex : string -> natural
let natural_of_hex s =
  let cs = String.toCharList s in
  match cs with
  | #'0'::#'x'::cs' -> 
      match cs' with
      | c :: _ -> natural_of_hex' (List.reverse cs')
      | [] -> Assert_extra.failwith ("natural_of_hex argument \"" ^ s ^ "\" has no digits")
      end
  | _ -> Assert_extra.failwith ("natural_of_hex argument \"" ^ s ^ "\" does not begin 0x")
  end

(** more missing pervasives *)

(* quick hacky workaround: this is in String.lem, in src_lem_library, but the linker doesn't find it *)
val myconcat : string -> list string -> string
let rec myconcat sep ss =
  match ss with
    | [] -> ""
    | s :: ss' ->
      match ss' with
      | [] -> s
      | _ -> s ^ sep ^ myconcat sep ss'
      end
  end

val myfindNonPure : forall 'a. ('a -> bool) -> list 'a -> 'a 
let myfindNonPure P l = match (List.find P l) with 
  | Just e      -> e
  | Nothing     -> Assert_extra.failwith "myfindNonPure"
end



(** basic pretty printing *)

let pphex n = "0x" ^ unsafe_hex_string_of_natural 0 n

let ppbytes xs = show (List.map (fun x -> show x) xs)

let rec ppbytes2 n xs = match xs with | [] -> "" | x::xs' -> "<"^pphex n^">  "^show x^"\n"^ppbytes2 (n+1) xs' end

(* workaround: from String *)
val mytoString : list char -> string
declare ocaml    target_rep function mytoString = `Xstring.implode`

let string_of_bytes bs = mytoString (List.map Missing_pervasives.char_of_byte bs)


(** dwarf encodings *)

(* these encoding tables are pasted from the DWARF 4 specification *)

(* tag encoding *)
let tag_encodings = [
  ("DW_TAG_array_type"               , natural_of_hex "0x01"  ); 
  ("DW_TAG_class_type"               , natural_of_hex "0x02"  ); 
  ("DW_TAG_entry_point"              , natural_of_hex "0x03"  ); 
  ("DW_TAG_enumeration_type"         , natural_of_hex "0x04"  ); 
  ("DW_TAG_formal_parameter"         , natural_of_hex "0x05"  ); 
  ("DW_TAG_imported_declaration"     , natural_of_hex "0x08"  ); 
  ("DW_TAG_label"                    , natural_of_hex "0x0a"  ); 
  ("DW_TAG_lexical_block"            , natural_of_hex "0x0b"  ); 
  ("DW_TAG_member"                   , natural_of_hex "0x0d"  ); 
  ("DW_TAG_pointer_type"             , natural_of_hex "0x0f"  ); 
  ("DW_TAG_reference_type"           , natural_of_hex "0x10"  ); 
  ("DW_TAG_compile_unit"             , natural_of_hex "0x11"  ); 
  ("DW_TAG_string_type"              , natural_of_hex "0x12"  ); 
  ("DW_TAG_structure_type"           , natural_of_hex "0x13"  ); 
  ("DW_TAG_subroutine_type"          , natural_of_hex "0x15"  ); 
  ("DW_TAG_typedef"                  , natural_of_hex "0x16"  ); 
  ("DW_TAG_union_type"               , natural_of_hex "0x17"  ); 
  ("DW_TAG_unspecified_parameters"   , natural_of_hex "0x18"  ); 
  ("DW_TAG_variant"                  , natural_of_hex "0x19"  ); 
  ("DW_TAG_common_block"             , natural_of_hex "0x1a"  ); 
  ("DW_TAG_common_inclusion"         , natural_of_hex "0x1b"  ); 
  ("DW_TAG_inheritance"              , natural_of_hex "0x1c"  ); 
  ("DW_TAG_inlined_subroutine"       , natural_of_hex "0x1d"  ); 
  ("DW_TAG_module"                   , natural_of_hex "0x1e"  ); 
  ("DW_TAG_ptr_to_member_type"       , natural_of_hex "0x1f"  ); 
  ("DW_TAG_set_type"                 , natural_of_hex "0x20"  ); 
  ("DW_TAG_subrange_type"            , natural_of_hex "0x21"  ); 
  ("DW_TAG_with_stmt"                , natural_of_hex "0x22"  ); 
  ("DW_TAG_access_declaration"       , natural_of_hex "0x23"  ); 
  ("DW_TAG_base_type"                , natural_of_hex "0x24"  ); 
  ("DW_TAG_catch_block"              , natural_of_hex "0x25"  ); 
  ("DW_TAG_const_type"               , natural_of_hex "0x26"  ); 
  ("DW_TAG_constant"                 , natural_of_hex "0x27"  ); 
  ("DW_TAG_enumerator"               , natural_of_hex "0x28"  ); 
  ("DW_TAG_file_type"                , natural_of_hex "0x29"  ); 
  ("DW_TAG_friend"                   , natural_of_hex "0x2a"  ); 
  ("DW_TAG_namelist"                 , natural_of_hex "0x2b"  ); 
  ("DW_TAG_namelist_item"            , natural_of_hex "0x2c"  ); 
  ("DW_TAG_packed_type"              , natural_of_hex "0x2d"  ); 
  ("DW_TAG_subprogram"               , natural_of_hex "0x2e"  ); 
  ("DW_TAG_template_type_parameter"  , natural_of_hex "0x2f"  ); 
  ("DW_TAG_template_value_parameter" , natural_of_hex "0x30"  ); 
  ("DW_TAG_thrown_type"              , natural_of_hex "0x31"  ); 
  ("DW_TAG_try_block"                , natural_of_hex "0x32"  ); 
  ("DW_TAG_variant_part"             , natural_of_hex "0x33"  ); 
  ("DW_TAG_variable"                 , natural_of_hex "0x34"  ); 
  ("DW_TAG_volatile_type"            , natural_of_hex "0x35"  ); 
  ("DW_TAG_dwarf_procedure"          , natural_of_hex "0x36"  ); 
  ("DW_TAG_restrict_type"            , natural_of_hex "0x37"  ); 
  ("DW_TAG_interface_type"           , natural_of_hex "0x38"  ); 
  ("DW_TAG_namespace"                , natural_of_hex "0x39"  ); 
  ("DW_TAG_imported_module"          , natural_of_hex "0x3a"  ); 
  ("DW_TAG_unspecified_type"         , natural_of_hex "0x3b"  ); 
  ("DW_TAG_partial_unit"             , natural_of_hex "0x3c"  ); 
  ("DW_TAG_imported_unit"            , natural_of_hex "0x3d"  ); 
  ("DW_TAG_condition"                , natural_of_hex "0x3f"  ); 
  ("DW_TAG_shared_type"              , natural_of_hex "0x40"  ); 
  ("DW_TAG_type_unit"                , natural_of_hex "0x41"  ); 
  ("DW_TAG_rvalue_reference_type"    , natural_of_hex "0x42"  ); 
  ("DW_TAG_template_alias"           , natural_of_hex "0x43"  ); 
  ("DW_TAG_lo_user"                  , natural_of_hex "0x4080"); 
  ("DW_TAG_hi_user"                  , natural_of_hex "0xffff")
]


(* child determination encoding *)

let DW_CHILDREN_no  = natural_of_hex "0x00"
let DW_CHILDREN_yes = natural_of_hex "0x01"


(* attribute encoding *)

type dwarf_attribute_classes = 
  | DWA_7_5_3
  | DWA_address
  | DWA_block
  | DWA_constant
  | DWA_dash
  | DWA_exprloc
  | DWA_flag 
  | DWA_lineptr
  | DWA_loclistptr
  | DWA_macptr
  | DWA_rangelistptr
  | DWA_reference
  | DWA_string

let attribute_encodings = [
  ("DW_AT_sibling"              , natural_of_hex "0x01", [DWA_reference])                                   ;
  ("DW_AT_location"             , natural_of_hex "0x02", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_name"                 , natural_of_hex "0x03", [DWA_string])                                      ;
  ("DW_AT_ordering"             , natural_of_hex "0x09", [DWA_constant])                                    ;
  ("DW_AT_byte_size"            , natural_of_hex "0x0b", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_offset"           , natural_of_hex "0x0c", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_size"             , natural_of_hex "0x0d", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_stmt_list"            , natural_of_hex "0x10", [DWA_lineptr])                                     ;
  ("DW_AT_low_pc"               , natural_of_hex "0x11", [DWA_address])                                     ;
  ("DW_AT_high_pc"              , natural_of_hex "0x12", [DWA_address; DWA_constant])                       ;
  ("DW_AT_language"             , natural_of_hex "0x13", [DWA_constant])                                    ;
  ("DW_AT_discr"                , natural_of_hex "0x15", [DWA_reference])                                   ;
  ("DW_AT_discr_value"          , natural_of_hex "0x16", [DWA_constant])                                    ;
  ("DW_AT_visibility"           , natural_of_hex "0x17", [DWA_constant])                                    ;
  ("DW_AT_import"               , natural_of_hex "0x18", [DWA_reference])                                   ;
  ("DW_AT_string_length"        , natural_of_hex "0x19", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_common_reference"     , natural_of_hex "0x1a", [DWA_reference])                                   ;
  ("DW_AT_comp_dir"             , natural_of_hex "0x1b", [DWA_string])                                      ;
  ("DW_AT_const_value"          , natural_of_hex "0x1c", [DWA_block; DWA_constant; DWA_string])             ;
  ("DW_AT_containing_type"      , natural_of_hex "0x1d", [DWA_reference])                                   ;
  ("DW_AT_default_value"        , natural_of_hex "0x1e", [DWA_reference])                                   ;
  ("DW_AT_inline"               , natural_of_hex "0x20", [DWA_constant])                                    ;
  ("DW_AT_is_optional"          , natural_of_hex "0x21", [DWA_flag])                                        ;
  ("DW_AT_lower_bound"          , natural_of_hex "0x22", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_producer"             , natural_of_hex "0x25", [DWA_string])                                      ;
  ("DW_AT_prototyped"           , natural_of_hex "0x27", [DWA_flag])                                        ;
  ("DW_AT_return_addr"          , natural_of_hex "0x2a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_start_scope"          , natural_of_hex "0x2c", [DWA_constant; DWA_rangelistptr])                  ;
  ("DW_AT_bit_stride"           , natural_of_hex "0x2e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_upper_bound"          , natural_of_hex "0x2f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_abstract_origin"      , natural_of_hex "0x31", [DWA_reference])                                   ;
  ("DW_AT_accessibility"        , natural_of_hex "0x32", [DWA_constant])                                    ;
  ("DW_AT_address_class"        , natural_of_hex "0x33", [DWA_constant])                                    ;
  ("DW_AT_artificial"           , natural_of_hex "0x34", [DWA_flag])                                        ;
  ("DW_AT_base_types"           , natural_of_hex "0x35", [DWA_reference])                                   ;
  ("DW_AT_calling_convention"   , natural_of_hex "0x36", [DWA_constant])                                    ;
  ("DW_AT_count"                , natural_of_hex "0x37", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_member_location" , natural_of_hex "0x38", [DWA_constant; DWA_exprloc; DWA_loclistptr])       ;
  ("DW_AT_decl_column"          , natural_of_hex "0x39", [DWA_constant])                                    ;
  ("DW_AT_decl_file"            , natural_of_hex "0x3a", [DWA_constant])                                    ;
  ("DW_AT_decl_line"            , natural_of_hex "0x3b", [DWA_constant])                                    ;
  ("DW_AT_declaration"          , natural_of_hex "0x3c", [DWA_flag])                                        ;
  ("DW_AT_discr_list"           , natural_of_hex "0x3d", [DWA_block])                                       ;
  ("DW_AT_encoding"             , natural_of_hex "0x3e", [DWA_constant])                                    ;
  ("DW_AT_external"             , natural_of_hex "0x3f", [DWA_flag])                                        ;
  ("DW_AT_frame_base"           , natural_of_hex "0x40", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_friend"               , natural_of_hex "0x41", [DWA_reference])                                   ;
  ("DW_AT_identifier_case"      , natural_of_hex "0x42", [DWA_constant])                                    ;
  ("DW_AT_macro_info"           , natural_of_hex "0x43", [DWA_macptr])                                      ;
  ("DW_AT_namelist_item"        , natural_of_hex "0x44", [DWA_reference])                                   ;
  ("DW_AT_priority"             , natural_of_hex "0x45", [DWA_reference])                                   ;
  ("DW_AT_segment"              , natural_of_hex "0x46", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_specification"        , natural_of_hex "0x47", [DWA_reference])                                   ;
  ("DW_AT_static_link"          , natural_of_hex "0x48", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_type"                 , natural_of_hex "0x49", [DWA_reference])                                   ;
  ("DW_AT_use_location"         , natural_of_hex "0x4a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_variable_parameter"   , natural_of_hex "0x4b", [DWA_flag])                                        ;
  ("DW_AT_virtuality"           , natural_of_hex "0x4c", [DWA_constant])                                    ;
  ("DW_AT_vtable_elem_location" , natural_of_hex "0x4d", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_allocated"            , natural_of_hex "0x4e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_associated"           , natural_of_hex "0x4f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_location"        , natural_of_hex "0x50", [DWA_exprloc])                                     ;
  ("DW_AT_byte_stride"          , natural_of_hex "0x51", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_entry_pc"             , natural_of_hex "0x52", [DWA_address])                                     ;
  ("DW_AT_use_UTF8"             , natural_of_hex "0x53", [DWA_flag])                                        ;
  ("DW_AT_extension"            , natural_of_hex "0x54", [DWA_reference])                                   ;
  ("DW_AT_ranges"               , natural_of_hex "0x55", [DWA_rangelistptr])                                ;
  ("DW_AT_trampoline"           , natural_of_hex "0x56", [DWA_address; DWA_flag; DWA_reference; DWA_string]);
  ("DW_AT_call_column"          , natural_of_hex "0x57", [DWA_constant])                                    ;
  ("DW_AT_call_file"            , natural_of_hex "0x58", [DWA_constant])                                    ;
  ("DW_AT_call_line"            , natural_of_hex "0x59", [DWA_constant])                                    ;
  ("DW_AT_description"          , natural_of_hex "0x5a", [DWA_string])                                      ;
  ("DW_AT_binary_scale"         , natural_of_hex "0x5b", [DWA_constant])                                    ;
  ("DW_AT_decimal_scale"        , natural_of_hex "0x5c", [DWA_constant])                                    ;
  ("DW_AT_small"                , natural_of_hex "0x5d", [DWA_reference])                                   ;
  ("DW_AT_decimal_sign"         , natural_of_hex "0x5e", [DWA_constant])                                    ;
  ("DW_AT_digit_count"          , natural_of_hex "0x5f", [DWA_constant])                                    ;
  ("DW_AT_picture_string"       , natural_of_hex "0x60", [DWA_string])                                      ;
  ("DW_AT_mutable"              , natural_of_hex "0x61", [DWA_flag])                                        ;
  ("DW_AT_threads_scaled"       , natural_of_hex "0x62", [DWA_flag])                                        ;
  ("DW_AT_explicit"             , natural_of_hex "0x63", [DWA_flag])                                        ;
  ("DW_AT_object_pointer"       , natural_of_hex "0x64", [DWA_reference])                                   ;
  ("DW_AT_endianity"            , natural_of_hex "0x65", [DWA_constant])                                    ;
  ("DW_AT_elemental"            , natural_of_hex "0x66", [DWA_flag])                                        ;
  ("DW_AT_pure"                 , natural_of_hex "0x67", [DWA_flag])                                        ;
  ("DW_AT_recursive"            , natural_of_hex "0x68", [DWA_flag])                                        ;
  ("DW_AT_signature"            , natural_of_hex "0x69", [DWA_reference])                                   ;
  ("DW_AT_main_subprogram"      , natural_of_hex "0x6a", [DWA_flag])                                        ;
  ("DW_AT_data_bit_offset"      , natural_of_hex "0x6b", [DWA_constant])                                    ;
  ("DW_AT_const_expr"           , natural_of_hex "0x6c", [DWA_flag])                                        ;
  ("DW_AT_enum_class"           , natural_of_hex "0x6d", [DWA_flag])                                        ;
  ("DW_AT_linkage_name"         , natural_of_hex "0x6e", [DWA_string])                                      ;
  ("DW_AT_lo_user"              , natural_of_hex "0x2000", [DWA_dash])                                      ;
  ("DW_AT_hi_user"              , natural_of_hex "0x3fff", [DWA_dash])                                      
]


(* attribute form encoding *)

let attribute_form_encodings = [
  ("DW_FORM_addr"        , natural_of_hex "0x01", [DWA_address])  ;
  ("DW_FORM_block2"      , natural_of_hex "0x03", [DWA_block])    ;
  ("DW_FORM_block4"      , natural_of_hex "0x04", [DWA_block])    ;
  ("DW_FORM_data2"       , natural_of_hex "0x05", [DWA_constant]) ;
  ("DW_FORM_data4"       , natural_of_hex "0x06", [DWA_constant]) ;
  ("DW_FORM_data8"       , natural_of_hex "0x07", [DWA_constant]) ;
  ("DW_FORM_string"      , natural_of_hex "0x08", [DWA_string])   ;
  ("DW_FORM_block"       , natural_of_hex "0x09", [DWA_block])    ;
  ("DW_FORM_block1"      , natural_of_hex "0x0a", [DWA_block])    ;
  ("DW_FORM_data1"       , natural_of_hex "0x0b", [DWA_constant]) ;
  ("DW_FORM_flag"        , natural_of_hex "0x0c", [DWA_flag])     ;
  ("DW_FORM_sdata"       , natural_of_hex "0x0d", [DWA_constant]) ;
  ("DW_FORM_strp"        , natural_of_hex "0x0e", [DWA_string])   ;
  ("DW_FORM_udata"       , natural_of_hex "0x0f", [DWA_constant]) ;
  ("DW_FORM_ref_addr"    , natural_of_hex "0x10", [DWA_reference]);
  ("DW_FORM_ref1"        , natural_of_hex "0x11", [DWA_reference]);
  ("DW_FORM_ref2"        , natural_of_hex "0x12", [DWA_reference]);
  ("DW_FORM_ref4"        , natural_of_hex "0x13", [DWA_reference]);
  ("DW_FORM_ref8"        , natural_of_hex "0x14", [DWA_reference]);
  ("DW_FORM_ref_udata"   , natural_of_hex "0x15", [DWA_reference]);
  ("DW_FORM_indirect"    , natural_of_hex "0x16", [DWA_7_5_3])    ;
  ("DW_FORM_sec_offset"  , natural_of_hex "0x17", [DWA_lineptr; DWA_loclistptr; DWA_macptr; DWA_rangelistptr]) ;
  ("DW_FORM_exprloc"     , natural_of_hex "0x18", [DWA_exprloc])  ;
  ("DW_FORM_flag_present", natural_of_hex "0x19", [DWA_flag])     ;
  ("DW_FORM_ref_sig8"    , natural_of_hex "0x20", [DWA_reference])
]


(* operation encoding *)

type operation_argument_type =
  | OAT_addr
  | OAT_dwarf_format_t
  | OAT_uint8
  | OAT_uint16
  | OAT_uint32
  | OAT_uint64
  | OAT_sint8
  | OAT_sint16
  | OAT_sint32
  | OAT_sint64
  | OAT_ULEB128
  | OAT_SLEB128
  | OAT_block

let operation_encodings = [
("DW_OP_addr",                natural_of_hex "0x03", [OAT_addr]); (*1*) (*constant address (size target specific)*)
("DW_OP_deref",               natural_of_hex "0x06", []); (*0*)
("DW_OP_const1u",             natural_of_hex "0x08", [OAT_uint8]); (*1*) (* 1-byte constant  *)
("DW_OP_const1s",             natural_of_hex "0x09", [OAT_sint8]); (*1*) (* 1-byte constant  *)
("DW_OP_const2u",             natural_of_hex "0x0a", [OAT_uint16]); (*1*) (* 2-byte constant  *)
("DW_OP_const2s",             natural_of_hex "0x0b", [OAT_sint16]); (*1*) (* 2-byte constant  *)
("DW_OP_const4u",             natural_of_hex "0x0c", [OAT_uint32]); (*1*) (* 4-byte constant  *)
("DW_OP_const4s",             natural_of_hex "0x0d", [OAT_sint32]); (*1*) (* 4-byte constant  *)
("DW_OP_const8u",             natural_of_hex "0x0e", [OAT_uint64]); (*1*) (* 8-byte constant  *)
("DW_OP_const8s",             natural_of_hex "0x0f", [OAT_sint64]); (*1*) (* 8-byte constant  *)
("DW_OP_constu",              natural_of_hex "0x10", [OAT_ULEB128]); (*1*) (* ULEB128 constant *)
("DW_OP_consts",              natural_of_hex "0x11", [OAT_SLEB128]); (*1*) (* SLEB128 constant *)
("DW_OP_dup",                 natural_of_hex "0x12", []); (*0*) 
("DW_OP_drop",                natural_of_hex "0x13", []); (*0*) 
("DW_OP_over",                natural_of_hex "0x14", []); (*0*) 
("DW_OP_pick",                natural_of_hex "0x15", [OAT_uint8]); (*1*) (* 1-byte stack index *)
("DW_OP_swap",                natural_of_hex "0x16", []); (*0*) 
("DW_OP_rot",                 natural_of_hex "0x17", []); (*0*) 
("DW_OP_xderef",              natural_of_hex "0x18", []); (*0*) 
("DW_OP_abs",                 natural_of_hex "0x19", []); (*0*) 
("DW_OP_and",                 natural_of_hex "0x1a", []); (*0*) 
("DW_OP_div",                 natural_of_hex "0x1b", []); (*0*) 
("DW_OP_minus",               natural_of_hex "0x1c", []); (*0*) 
("DW_OP_mod",                 natural_of_hex "0x1d", []); (*0*) 
("DW_OP_mul",                 natural_of_hex "0x1e", []); (*0*) 
("DW_OP_neg",                 natural_of_hex "0x1f", []); (*0*) 
("DW_OP_not",                 natural_of_hex "0x20", []); (*0*) 
("DW_OP_or",                  natural_of_hex "0x21", []); (*0*) 
("DW_OP_plus",                natural_of_hex "0x22", []); (*0*) 
("DW_OP_plus_uconst",         natural_of_hex "0x23", [OAT_ULEB128]); (*1*) (* ULEB128 addend *)
("DW_OP_shl",                 natural_of_hex "0x24", []); (*0*) 
("DW_OP_shr",                 natural_of_hex "0x25", []); (*0*) 
("DW_OP_shra",                natural_of_hex "0x26", []); (*0*) 
("DW_OP_xor",                 natural_of_hex "0x27", []); (*0*) 
("DW_OP_skip",                natural_of_hex "0x2f", [OAT_sint16]); (*1*) (* signed 2-byte constant *)
("DW_OP_bra",                 natural_of_hex "0x28", [OAT_sint16]); (*1*) (* signed 2-byte constant *)
("DW_OP_eq",                  natural_of_hex "0x29", []); (*0*) 
("DW_OP_ge",                  natural_of_hex "0x2a", []); (*0*) 
("DW_OP_gt",                  natural_of_hex "0x2b", []); (*0*) 
("DW_OP_le",                  natural_of_hex "0x2c", []); (*0*) 
("DW_OP_lt",                  natural_of_hex "0x2d", []); (*0*) 
("DW_OP_ne",                  natural_of_hex "0x2e", []); (*0*) 
("DW_OP_lit0",                natural_of_hex "0x30", []); (*0*) (* literals 0..31 =(DW_OP_lit0 + literal) *)
("DW_OP_lit1",                natural_of_hex "0x31", []); (*0*)
("DW_OP_lit2",                natural_of_hex "0x32", []); (*0*)
("DW_OP_lit3",                natural_of_hex "0x33", []); (*0*)
("DW_OP_lit4",                natural_of_hex "0x34", []); (*0*)
("DW_OP_lit5",                natural_of_hex "0x35", []); (*0*)
("DW_OP_lit6",                natural_of_hex "0x36", []); (*0*)
("DW_OP_lit7",                natural_of_hex "0x37", []); (*0*)
("DW_OP_lit8",                natural_of_hex "0x38", []); (*0*)
("DW_OP_lit9",                natural_of_hex "0x39", []); (*0*)
("DW_OP_lit10",               natural_of_hex "0x3a", []); (*0*)
("DW_OP_lit11",               natural_of_hex "0x3b", []); (*0*)
("DW_OP_lit12",               natural_of_hex "0x3c", []); (*0*)
("DW_OP_lit13",               natural_of_hex "0x3d", []); (*0*)
("DW_OP_lit14",               natural_of_hex "0x3e", []); (*0*)
("DW_OP_lit15",               natural_of_hex "0x3f", []); (*0*)
("DW_OP_lit16",               natural_of_hex "0x40", []); (*0*)
("DW_OP_lit17",               natural_of_hex "0x41", []); (*0*)
("DW_OP_lit18",               natural_of_hex "0x42", []); (*0*)
("DW_OP_lit19",               natural_of_hex "0x43", []); (*0*)
("DW_OP_lit20",               natural_of_hex "0x44", []); (*0*)
("DW_OP_lit21",               natural_of_hex "0x45", []); (*0*)
("DW_OP_lit22",               natural_of_hex "0x46", []); (*0*)
("DW_OP_lit23",               natural_of_hex "0x47", []); (*0*)
("DW_OP_lit24",               natural_of_hex "0x48", []); (*0*)
("DW_OP_lit25",               natural_of_hex "0x49", []); (*0*)
("DW_OP_lit26",               natural_of_hex "0x4a", []); (*0*)
("DW_OP_lit27",               natural_of_hex "0x4b", []); (*0*)
("DW_OP_lit28",               natural_of_hex "0x4c", []); (*0*)
("DW_OP_lit29",               natural_of_hex "0x4d", []); (*0*)
("DW_OP_lit30",               natural_of_hex "0x4e", []); (*0*)
("DW_OP_lit31",               natural_of_hex "0x4f", []); (*0*)
("DW_OP_reg0",                natural_of_hex "0x50", []); (*1*) (* reg 0..31 = (DW_OP_reg0 + regnum) *)
("DW_OP_reg1",                natural_of_hex "0x51", []); (*1*)
("DW_OP_reg2",                natural_of_hex "0x52", []); (*1*)
("DW_OP_reg3",                natural_of_hex "0x53", []); (*1*)
("DW_OP_reg4",                natural_of_hex "0x54", []); (*1*)
("DW_OP_reg5",                natural_of_hex "0x55", []); (*1*)
("DW_OP_reg6",                natural_of_hex "0x56", []); (*1*)
("DW_OP_reg7",                natural_of_hex "0x57", []); (*1*)
("DW_OP_reg8",                natural_of_hex "0x58", []); (*1*)
("DW_OP_reg9",                natural_of_hex "0x59", []); (*1*)
("DW_OP_reg10",               natural_of_hex "0x5a", []); (*1*)
("DW_OP_reg11",               natural_of_hex "0x5b", []); (*1*)
("DW_OP_reg12",               natural_of_hex "0x5c", []); (*1*)
("DW_OP_reg13",               natural_of_hex "0x5d", []); (*1*)
("DW_OP_reg14",               natural_of_hex "0x5e", []); (*1*)
("DW_OP_reg15",               natural_of_hex "0x5f", []); (*1*)
("DW_OP_reg16",               natural_of_hex "0x60", []); (*1*)
("DW_OP_reg17",               natural_of_hex "0x61", []); (*1*)
("DW_OP_reg18",               natural_of_hex "0x62", []); (*1*)
("DW_OP_reg19",               natural_of_hex "0x63", []); (*1*)
("DW_OP_reg20",               natural_of_hex "0x64", []); (*1*)
("DW_OP_reg21",               natural_of_hex "0x65", []); (*1*)
("DW_OP_reg22",               natural_of_hex "0x66", []); (*1*)
("DW_OP_reg23",               natural_of_hex "0x67", []); (*1*)
("DW_OP_reg24",               natural_of_hex "0x68", []); (*1*)
("DW_OP_reg25",               natural_of_hex "0x69", []); (*1*)
("DW_OP_reg26",               natural_of_hex "0x6a", []); (*1*)
("DW_OP_reg27",               natural_of_hex "0x6b", []); (*1*)
("DW_OP_reg28",               natural_of_hex "0x6c", []); (*1*)
("DW_OP_reg29",               natural_of_hex "0x6d", []); (*1*)
("DW_OP_reg30",               natural_of_hex "0x6e", []); (*1*)
("DW_OP_reg31",               natural_of_hex "0x6f", []); (*1*) 
("DW_OP_breg0",               natural_of_hex "0x70", []); (*1*) (* base register 0..31 = (DW_OP_breg0 + regnum) *)
("DW_OP_breg1",               natural_of_hex "0x71", []); (*1*)
("DW_OP_breg2",               natural_of_hex "0x72", []); (*1*)
("DW_OP_breg3",               natural_of_hex "0x73", []); (*1*)
("DW_OP_breg4",               natural_of_hex "0x74", []); (*1*)
("DW_OP_breg5",               natural_of_hex "0x75", []); (*1*)
("DW_OP_breg6",               natural_of_hex "0x76", []); (*1*)
("DW_OP_breg7",               natural_of_hex "0x77", []); (*1*)
("DW_OP_breg8",               natural_of_hex "0x78", []); (*1*)
("DW_OP_breg9",               natural_of_hex "0x79", []); (*1*)
("DW_OP_breg10",              natural_of_hex "0x7a", []); (*1*)
("DW_OP_breg11",              natural_of_hex "0x7b", []); (*1*)
("DW_OP_breg12",              natural_of_hex "0x7c", []); (*1*)
("DW_OP_breg13",              natural_of_hex "0x7d", []); (*1*)
("DW_OP_breg14",              natural_of_hex "0x7e", []); (*1*)
("DW_OP_breg15",              natural_of_hex "0x7f", []); (*1*)
("DW_OP_breg16",              natural_of_hex "0x80", []); (*1*)
("DW_OP_breg17",              natural_of_hex "0x81", []); (*1*)
("DW_OP_breg18",              natural_of_hex "0x82", []); (*1*)
("DW_OP_breg19",              natural_of_hex "0x83", []); (*1*)
("DW_OP_breg20",              natural_of_hex "0x84", []); (*1*)
("DW_OP_breg21",              natural_of_hex "0x85", []); (*1*)
("DW_OP_breg22",              natural_of_hex "0x86", []); (*1*)
("DW_OP_breg23",              natural_of_hex "0x87", []); (*1*)
("DW_OP_breg24",              natural_of_hex "0x88", []); (*1*)
("DW_OP_breg25",              natural_of_hex "0x89", []); (*1*)
("DW_OP_breg26",              natural_of_hex "0x8a", []); (*1*)
("DW_OP_breg27",              natural_of_hex "0x8b", []); (*1*)
("DW_OP_breg28",              natural_of_hex "0x8c", []); (*1*)
("DW_OP_breg29",              natural_of_hex "0x8d", []); (*1*)
("DW_OP_breg30",              natural_of_hex "0x8e", []); (*1*)
("DW_OP_breg31",              natural_of_hex "0x8f", []); (*1*) 
("DW_OP_regx",                natural_of_hex "0x90", [OAT_ULEB128]); (*1*) (* ULEB128 register *)
("DW_OP_fbreg",               natural_of_hex "0x91", [OAT_SLEB128]); (*1*) (* SLEB128 offset *)
("DW_OP_bregx",               natural_of_hex "0x92", [OAT_ULEB128; OAT_SLEB128]); (*2*) (* ULEB128 register followed by SLEB128 offset *)
("DW_OP_piece",               natural_of_hex "0x93", [OAT_ULEB128]); (*1*) (* ULEB128 size of piece addressed *)
("DW_OP_deref_size",          natural_of_hex "0x94", [OAT_uint8]); (*1*) (* 1-byte size of data retrieved *)
("DW_OP_xderef_size",         natural_of_hex "0x95", [OAT_uint8]); (*1*) (* 1-byte size of data retrieved *)
("DW_OP_nop",                 natural_of_hex "0x96", []); (*0*)  
("DW_OP_push_object_address", natural_of_hex "0x97", []); (*0*)  
("DW_OP_call2",               natural_of_hex "0x98", [OAT_uint16]); (*1*) (* 2-byte offset of DIE *)
("DW_OP_call4",               natural_of_hex "0x99", [OAT_uint32]); (*1*) (* 4-byte offset of DIE *)
("DW_OP_call_ref",            natural_of_hex "0x9a", [OAT_dwarf_format_t]); (*1*) (* 4- or 8-byte offset of DIE *)
("DW_OP_form_tls_address",    natural_of_hex "0x9b", []); (*0*)  
("DW_OP_call_frame_cfa",      natural_of_hex "0x9c", []); (*0*)  
("DW_OP_bit_piece",           natural_of_hex "0x9d", [OAT_ULEB128; OAT_ULEB128]); (*2*) (* ULEB128 size followed by ULEB128 offset *)
("DW_OP_implicit_value",      natural_of_hex "0x9e", [OAT_block]); (*2*) (* ULEB128 size followed by block of that size *)
("DW_OP_stack_value",         natural_of_hex "0x9f", []); (*0*) 
("DW_OP_lo_user",             natural_of_hex "0xe0", []); 
("DW_OP_hi_user",             natural_of_hex "0xff", [])
]


(** dwarf representation types *)

(* This gives a "lightly parsed" representation of some of the dwarf
information, with the byte sequences of some of the .debug_* sections
parsed into a structured representation.  That makes the list and tree
structures explicit, and converts the various numeric types into just
natural, integer, and byte sequences, but it leaves the encoding
values as numbers rather than Lem constructors. The lem natural and 
integer could be replaced by unsigned and signed 64-bit types. *)

type dwarf_format =
  | Dwarf32
  | Dwarf64

type abbreviation_declaration = 
    <| 
    ad_abbreviation_code : natural;
    ad_tag : natural;
    ad_has_children : bool;
    ad_attribute_specifications : list (natural * natural);
  |>

type abbreviations_table = list abbreviation_declaration

type attribute_value =
  | AV_addr of natural
  | AV_block of natural * list byte
  | AV_constantN of natural * list byte
  | AV_constant_SLEB128 of integer
  | AV_constant_ULEB128 of natural
  | AV_exprloc of natural * list byte
  | AV_flag of bool
  | AV_ref of natural 
  | AV_ref_addr of natural (* dwarf_format dependent *)
  | AV_ref_sig8 of natural
  | AV_sec_offset of natural
  | AV_string of list byte (* not including terminating null *)
  | AV_strp of natural (* dwarf_format dependent *)

type die = 
    <|
    die_offset : natural;
    die_abbreviation_code : natural;
    die_abbreviation_declaration : abbreviation_declaration;
    die_attribute_values : list (natural (*pos*) * attribute_value);
    die_children : list die;
  |>

type operation_argument_value = 
  | OAV_natural of natural
  | OAV_integer of integer
  | OAV_block of natural * list byte

type operation = 
    <|
    op_code : natural;
    op_string : string;
    op_argument_values : list operation_argument_value;
  |>

type compilation_unit_header = 
    <| 
    cuh_offset : natural; 
    cuh_dwarf_format : dwarf_format;
    cuh_unit_length : natural;
    cuh_version : natural;
    cuh_debug_abbrev_offset : natural;
    cuh_address_size : natural;
  |> 
    
type compilation_unit = 
    <| 
    cu_header : compilation_unit_header;
    cu_abbreviations_table : abbreviations_table;
    cu_die : die;
  |>

type compilation_units = list compilation_unit

type type_unit_header = 
    <| 
    tuh_cuh : compilation_unit_header;
    tuh_type_signature : natural;
    tuh_type_offset : natural;
  |> 

type type_unit = 
    <| 
    tu_header : type_unit_header;
    tu_abbreviations_table : abbreviations_table;
    tu_die : die;
  |>

type type_units = list type_unit
    
type dwarf = 
    <| 
    d_str : list byte;
    d_compilation_units : compilation_units;
    d_type_units : type_units;
  |>


(** lookup of encodings *)

val lookup_aB_a : forall 'a 'b. Eq 'b => 'b -> list ('a * 'b) -> maybe 'a
let rec lookup_aB_a y0 xys = 
  match xys with
  | [] -> Nothing
  | (x,y)::xys' -> if y=y0 then Just x else lookup_aB_a y0 xys'  
  end

val lookup_aBc_a : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe 'a
let rec lookup_aBc_a y0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if y=y0 then Just x else lookup_aBc_a y0 xyzs'  
  end

val lookup_aBc_ac : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe ('a*'c)
let rec lookup_aBc_ac y0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,z)::xyzs' -> if y=y0 then Just (x,z) else lookup_aBc_ac y0 xyzs'  
  end

val lookup_Abc_b : forall 'a 'b 'c. Eq 'a => 'a -> list ('a * 'b * 'c) -> maybe 'b
let rec lookup_Abc_b x0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if x=x0 then Just y else lookup_Abc_b x0 xyzs'  
  end


let pp_maybe ppf n = match ppf n with Just s -> s | Nothing -> "encoding not found: " ^ pphex n end

let pp_tag_encoding n = pp_maybe (fun n -> lookup_aB_a n tag_encodings) n
let pp_attribute_encoding n = pp_maybe (fun n -> lookup_aBc_a n attribute_encodings) n
let pp_attribute_form_encoding n = pp_maybe (fun n -> lookup_aBc_a n attribute_form_encodings) n
let pp_operation_encoding n = pp_maybe (fun n -> lookup_aBc_a n operation_encodings) n

let attribute_encode (s: string) : natural = 
  match lookup_Abc_b s attribute_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_encode"
  end

let attribute_form_encode (s: string) : natural = 
  match lookup_Abc_b s attribute_form_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_form_encode"
  end


(** basic parsing *)

(* parsing combinators *)

type parse_context = <| pc_bytes: list byte; pc_offset: natural |> 

type parse_result 'a =
  | PR_success of 'a * parse_context
  | PR_fail of string * parse_context

type parser 'a = parse_context -> parse_result 'a

let pp_parse_context pc = "pc_offset = " ^ pphex pc.pc_offset

let pp_parse_fail s pc = 
  "Parse fail\n" ^ s ^ " at " ^ pp_parse_context pc ^ "\n"

let pp_parse_result ppa pr = 
  match pr with
  | PR_success x pc -> "Parse success\n" ^ ppa x ^ "\n" ^ pp_parse_context pc ^ "\n"
  | PR_fail s pc -> pp_parse_fail s pc  
  end

(* [(>>=)] should be the monadic binding function for [parse_result].  *)
(* but there's a type clash if we use >>=, and lem seems to output bad ocaml for >>>=. So we just use a non-infix version for now *)

val pr_bind : forall 'a 'b. parse_result 'a -> ('a -> parser 'b) -> parse_result 'b
let pr_bind x f =
  match x with
  | PR_success v pc -> f v pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_return : forall 'a. 'a -> (parser 'a)
let pr_return x pc = PR_success x pc

val pr_map : forall 'a 'b. ('a -> 'b) -> parse_result 'a -> parse_result 'b
let pr_map f x =
  match x with
  | PR_success v pc -> PR_success (f v) pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_map2 : forall 'a 'b. ('a -> 'b) -> (parser 'a) -> (parser 'b)
let pr_map2 f p = fun pc -> pr_map f (p pc)

val pr_post_map1 : forall 'a 'b. (parse_result 'a) -> ('a -> 'b) -> (parse_result 'b)
let pr_post_map1 x f = pr_map f x

(*
val pr_post_map : forall 'a 'b 'c. ('c -> parse_result 'a) -> ('a -> 'b) -> ('c -> parse_result 'b)
let pr_post_map g f = fun x ->  pr_map f (g x)
*)
val pr_post_map : forall 'a 'b. (parser 'a) -> ('a -> 'b) -> (parser 'b)
let pr_post_map p f = fun (pc: parse_context) -> pr_map f (p pc)


val pr_with_pos : forall 'a. (parser 'a) -> (parser (natural * 'a))
let pr_with_pos p = fun pc -> pr_map (fun x -> (pc.pc_offset,x)) (p pc)


val parse_pair : forall 'a 'b. (parser 'a) -> (parser 'b) -> (parser ('a * 'b))
let parse_pair p1 p2 = 
  fun pc -> 
    let _ = my_debug "pair " in 
    pr_bind (p1 pc) (fun x pc' -> match p2 pc' with 
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)

val parse_triple : forall 'a 'b 'c. (parser 'a) -> (parser 'b) -> (parser 'c) -> parser ('a * ('b * 'c))
let parse_triple p1 p2 p3 = 
  parse_pair p1 (parse_pair p2 p3)

val parse_quadruple : forall 'a 'b 'c 'd. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> parser ('a * ('b * ('c * 'd)))
let parse_quadruple p1 p2 p3 p4 = 
  parse_pair p1 (parse_pair p2 (parse_pair p3 p4))

val parse_pentuple : forall 'a 'b 'c 'd 'e. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> (parser 'e) -> parser ('a * ('b * ('c * ('d * 'e))))
let parse_pentuple p1 p2 p3 p4 p5 = 
  parse_pair p1 (parse_pair p2 (parse_pair p3 (parse_pair p4 p5)))

val parse_sextuple : forall 'a 'b 'c 'd 'e 'f. (parser 'a) -> (parser 'b) -> (parser 'c) -> (parser 'd) -> (parser 'e) -> (parser 'f) -> parser ('a * ('b * ('c * ('d * ('e * 'f)))))
let parse_sextuple p1 p2 p3 p4 p5 p6 = 
  parse_pair p1 (parse_pair p2 (parse_pair p3 (parse_pair p4 (parse_pair p5 p6))))

val parse_dependent_pair : forall 'a 'b. (parser 'a) -> ('a -> parser 'b) -> (parser ('a * 'b))
let parse_dependent_pair p1 p2 = 
  fun pc -> 
    pr_bind (p1 pc) (fun x pc' -> match p2 x pc' with 
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)



open import List
val parse_list' : forall 'a. (parser (maybe 'a)) -> (list 'a -> parser (list 'a))
let rec parse_list' p1 =
  fun acc pc ->   let _ = my_debug "list' " in pr_bind (p1 pc) (fun mx pc' -> 
    match mx with
    | Nothing -> PR_success acc pc'
    | Just x -> parse_list' p1 (x :: acc) pc'
    end)

val parse_list : forall 'a. (parser (maybe 'a)) -> (parser (list 'a))
let parse_list p1 = 
  pr_post_map 
    (parse_list' p1 [])
    (List.reverse) 

val parse_parser_list : forall 'a. (list (parser 'a)) -> (parser (list 'a))
let rec parse_parser_list ps = 
  match ps with
  | [] -> pr_return []
  | p::ps' -> 
      (fun pc -> pr_bind (p pc) (fun x pc' -> 
        match parse_parser_list ps' pc' with
        | PR_success xs pc'' -> PR_success (x::xs) pc''
        | PR_fail s pc'' -> PR_fail s pc''
        end))
  end



(* parsing of basic types *)

let rec mytake' (n:natural) acc xs = 
  match (n,xs) with
  | (0, _) -> Just (List.reverse acc, xs)
  | (_, []) -> Nothing
  | (_, x::xs') -> mytake' (n-1) (x::acc) xs'
  end

val mytake : forall 'a.  natural -> (list 'a) -> maybe (list 'a * list 'a)
let mytake n xs = mytake' n [] xs

let parse_n_bytes (n:natural) : parser (list byte) =
    fun (pc:parse_context) -> 
      match mytake n pc.pc_bytes with
      | Nothing -> PR_fail "parse_n_bytes" pc
      | Just (xs,bs) -> PR_success xs (<|pc_bytes=bs; pc_offset= pc.pc_offset + naturalFromNat (List.length xs) |> )
      end

let rec mytakestring' acc xs = 
  match xs with
  | [] -> Nothing
  | x::xs' -> if natural_of_byte x = 0 then Just (List.reverse acc, xs') else mytakestring' (x::acc) xs'
  end

let parse_string : parser (list byte) =
    fun (pc:parse_context) ->
      match mytakestring' [] pc.pc_bytes with
      | Nothing -> PR_fail "parse_string" pc
      | Just (xs,bs) -> PR_success xs (<|pc_bytes=bs; pc_offset = pc.pc_offset + naturalFromNat (List.length xs) + naturalFromNat 1 |> )
      end

let parse_uint8 : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint8 " in
      match pc.pc_bytes with
      | b0::bytes' -> 
          let v = natural_of_byte b0 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint16 : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint16 " in
      match pc.pc_bytes with
      | b0::b1::bytes' -> 
          let v = natural_of_byte b0 + 256*natural_of_byte b1 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 2 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint32 : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint32 " in
      match pc.pc_bytes with
      | b0::b1::b2::b3::bytes' -> 
          let v = natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3 in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 4 |>)
      | _ -> PR_fail "parse_uint32 not given enough bytes" pc
      end

let parse_uint64 : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "uint64 " in
      match pc.pc_bytes with
      | b0::b1::b2::b3::b4::b5::b6::b7::bytes' -> 
          let v = natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3 
              + (256*256*256*256*(natural_of_byte b4 + 256*natural_of_byte b5 + 256*256*natural_of_byte b6 + 256*256*256*natural_of_byte b7))
          in
          PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 8 |>)
      | _ -> PR_fail "parse_uint64 not given enough bytes" pc
      end

let integerFrom2sComplementNatural (n:natural) (half: natural) (all:integer) = 
  if n < half then integerFromNatural n else integerFromNatural n - all

let parse_sint8 : parser integer = 
  pr_post_map parse_uint8 (fun n -> integerFrom2sComplementNatural n 128 256)

let parse_sint16 : parser integer = 
  pr_post_map parse_uint16 (fun n -> integerFrom2sComplementNatural n (128*256) (256*256))

let parse_sint32 : parser integer = 
  pr_post_map parse_uint32 (fun n -> integerFrom2sComplementNatural n (128*256*256*256) (256*256*256*256))

let parse_sint64 : parser integer = 
  pr_post_map parse_uint64 (fun n -> integerFrom2sComplementNatural n (128*256*256*256*256*256*256*256) (256*256*256*256*256*256*256*256))

let rec parse_ULEB128' (acc: natural) (shift_factor: natural) : parser natural = 
    fun (pc:parse_context) ->
      let _ = my_debug "ULEB128' " in
      match pc.pc_bytes with
      | b::bytes' -> 
          let n = natural_of_byte b in
          let acc' = (natural_land n 127) * shift_factor + acc in
          let finished = ((natural_land n 128) = 0) in
          let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
          if finished then 
            PR_success acc' pc'
          else
            parse_ULEB128' acc' (shift_factor * 128) pc'
      | _ ->
          PR_fail "parse_ULEB128' not given enough bytes" pc
      end    

let parse_ULEB128 : parser natural = 
  fun (pc:parse_context) ->
    parse_ULEB128' 0 1 pc

let rec parse_SLEB128' (acc: natural) (shift_factor: natural) : parser (bool * natural * natural) = 
    fun (pc:parse_context) ->
      let _ = my_debug "SLEB128' " in
      match pc.pc_bytes with
      | b::bytes' -> 
          let n = natural_of_byte b in
          let acc' = acc + (natural_land n 127) * shift_factor in
          let shift_factor' = shift_factor * 128 in
          let finished = ((natural_land n 128) = 0) in
          let positive = ((natural_land n 64) = 0) in
          let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
          if finished then 
            PR_success (positive, shift_factor', acc') pc'
          else
            parse_SLEB128' acc' shift_factor' pc'
      | _ ->
          PR_fail "parse_SLEB128' not given enough bytes" pc
      end    

let parse_SLEB128 : parser integer = 
    pr_post_map (parse_SLEB128' 0 1) (fun (positive, shift_factor, acc) ->
       if positive then integerFromNatural acc else integerFromNatural acc - integerFromNatural shift_factor)
    
let parse_nonzero_ULEB128_pair : parser (maybe (natural*natural)) =
  let _ = my_debug "nonzero_ULEB128_pair " in
  pr_post_map 
    (parse_pair parse_ULEB128 parse_ULEB128)
    (fun (n1,n2) -> if n1=0 && n2=0 then Nothing else Just (n1,n2))

let parse_zero_terminated_ULEB128_pair_list : parser (list (natural*natural)) = 
  let _ = my_debug "zero_terminated_ULEB128_pair_list " in
  parse_list parse_nonzero_ULEB128_pair 



(** abbreviations table: pp and parsing *)

let pp_abbreviation_declaration (x:abbreviation_declaration) =
  "   " 
  ^ show x.ad_abbreviation_code ^ "      " 
  ^ pp_tag_encoding x.ad_tag ^ "    " 
  ^ (if x.ad_has_children then "[has children]" else "[no children]")
  ^ "\n"
(*  ^ " "^show (List.length x.ad_attribute_specifications) ^ " attributes\n"*)
  ^ myconcat "" 
      (List.map 
         (fun (n1,n2) ->
           "    " ^ pp_attribute_encoding n1 ^ "     " ^ pp_attribute_form_encoding n2 ^ "\n") 
         x.ad_attribute_specifications)

let pp_abbreviations_table (x:abbreviations_table) = 
  myconcat "" (List.map pp_abbreviation_declaration x)

let parse_abbreviation_declaration : parser (maybe abbreviation_declaration) =
    fun (pc: parse_context) -> 
      pr_bind (parse_ULEB128 pc) (fun n1 pc' -> 
        if n1 = 0 then 
          PR_success Nothing pc'
        else 
          pr_bind (parse_ULEB128 pc') (fun n2 pc'' -> 
            pr_bind (parse_uint8 pc'') (fun c pc''' -> 
              pr_post_map1 
                (parse_zero_terminated_ULEB128_pair_list pc''')
                (fun l ->
                  Just ( let ad = 
                    <|
                    ad_abbreviation_code = n1;
                    ad_tag = n2;
                    ad_has_children = (c<>0);
                    ad_attribute_specifications = l;
                  |> in let _ = my_debug2 (pp_abbreviation_declaration ad) in ad)
                ))))

let parse_abbreviations_table =
  parse_list parse_abbreviation_declaration


(** debug_str entry *)

val mydrop : forall 'a. natural -> list 'a -> maybe (list 'a)
let rec mydrop n xs = 
  if n=0 then Just xs 
  else 
    match xs with
    | x::xs' -> mydrop (n-1) xs' 
    | [] -> Nothing
    end

let rec null_terminated_list (acc: list byte) (xs: list byte) : list byte = 
  match xs with
  | [] -> List.reverse acc (* TODO: flag failure? *)
  | x::xs' -> if natural_of_byte x = 0 then List.reverse acc else null_terminated_list (x::acc) xs'
  end

let pp_debug_str_entry (str: list byte) (n: natural) =
  match mydrop n str with
  | Nothing -> "strp beyond .debug_str extent"
  | Just xs -> string_of_bytes (null_terminated_list [] xs)
  end

(** operations: pp and parsing *)

let pp_operation_argument_value (oav:operation_argument_value) : string =
  match oav with
  | OAV_natural n -> pphex n
  | OAV_integer n -> show n
  | OAV_block n bs -> pphex n ^ " " ^ ppbytes bs
  end

let pp_operation (op: operation) : string =
  op.op_string ^ " " ^ myconcat " " (List.map pp_operation_argument_value op.op_argument_values)

let pp_operations (ops: list operation) : string =
  myconcat " " (List.map pp_operation ops)

val parser_of_operation_argument_type : compilation_unit_header -> operation_argument_type -> (parser operation_argument_value)
let parser_of_operation_argument_type cuh oat = 
  match oat with
    | OAT_addr -> 
        match cuh.cuh_address_size with
        | 4 -> pr_map2 (fun n -> OAV_natural n) parse_uint32
        | 8 -> pr_map2 (fun n -> OAV_natural n) parse_uint64
        | _ -> Assert_extra.failwith "cuh_address_size not 4 or 8"
        end
    | OAT_dwarf_format_t ->
        match cuh.cuh_dwarf_format with
        | Dwarf32 -> pr_map2 (fun n -> OAV_natural n) parse_uint32
        | Dwarf64 -> pr_map2 (fun n -> OAV_natural n) parse_uint64
        end
    | OAT_uint8   -> pr_map2 (fun n -> OAV_natural n) parse_uint8
    | OAT_uint16  -> pr_map2 (fun n -> OAV_natural n) parse_uint16
    | OAT_uint32  -> pr_map2 (fun n -> OAV_natural n) parse_uint32
    | OAT_uint64  -> pr_map2 (fun n -> OAV_natural n) parse_uint64
    | OAT_sint8   -> pr_map2 (fun n -> OAV_integer n) parse_sint8
    | OAT_sint16  -> pr_map2 (fun n -> OAV_integer n) parse_sint16
    | OAT_sint32  -> pr_map2 (fun n -> OAV_integer n) parse_sint32
    | OAT_sint64  -> pr_map2 (fun n -> OAV_integer n) parse_sint64
    | OAT_ULEB128 -> pr_map2 (fun n -> OAV_natural n) parse_ULEB128
    | OAT_SLEB128 -> pr_map2 (fun n -> OAV_integer n) parse_SLEB128
    | OAT_block   ->
      (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
        pr_map (fun bs -> OAV_block n bs) (parse_n_bytes n pc')))
  end

val parse_operation : compilation_unit_header -> parser (maybe operation)
let parse_operation cuh pc = 
  match parse_uint8 pc with
  | PR_fail s pc' -> PR_success Nothing pc
  | PR_success code pc' ->
      match lookup_aBc_ac code operation_encodings with
      | Nothing -> PR_fail ("encoding not found: " ^ pphex code) pc 
      | Just (s,oats) -> 
          let ps = List.map (parser_of_operation_argument_type cuh) oats in
          (pr_post_map 
            (parse_parser_list ps) 
            (fun oavs -> Just <| op_code = code; op_string = s; op_argument_values = oavs |>)
          )
            pc'
      end
  end

val parse_operations : compilation_unit_header -> parser (list operation)
let parse_operations cuh =
  parse_list (parse_operation cuh)

val parse_and_pp_operations : compilation_unit_header -> list byte -> string
let parse_and_pp_operations cuh bs =
  let pc = <|pc_bytes = bs; pc_offset = 0  |> in
  match parse_operations cuh pc with
  | PR_fail s pc' -> "parse_operations fail: " ^ pp_parse_fail s pc'
  | PR_success ops pc' ->
      pp_operations ops 
      ^ if pc'.pc_bytes <> [] then " Warning: extra non-parsed bytes" else ""
  end


(** attribute values: pp and parsing *)

val pp_attribute_value : compilation_unit_header -> list byte -> natural (*attribute tag*) -> attribute_value -> string
let pp_attribute_value cuh str at av = 
  match av with
  | AV_addr x -> "AV_addr " ^ pphex x
  | AV_block n bs -> "AV_block " ^ show n ^ " " ^ ppbytes bs
      ^ if at = attribute_encode "DW_AT_location" then " " ^ parse_and_pp_operations cuh bs else ""
  | AV_constantN n bs -> "AV_constantN " ^ show n ^ " " ^ ppbytes bs
  | AV_constant_SLEB128 i -> "AV_constant_SLEB128 " ^ show i
  | AV_constant_ULEB128 n -> "AV_constant_ULEB128 " ^ show n
  | AV_exprloc n bs -> "AV_exprloc " ^ show n ^ " " ^ ppbytes bs
      ^ " " ^ parse_and_pp_operations cuh bs
  | AV_flag b -> "AV_flag " ^ show b
  | AV_ref n -> "AV_ref " ^ pphex n
  | AV_ref_addr n -> "AV_ref_addr " ^ pphex n 
  | AV_ref_sig8 n -> "AV_ref_sig8 " ^ pphex n 
  | AV_sec_offset n -> "AV_sec_offset " ^ pphex  n
  | AV_string bs -> string_of_bytes bs
  | AV_strp n -> "AV_sec_offset " ^ pphex n ^ " " 
      ^ pp_debug_str_entry str n
  end


val parser_of_attribute_form_non_indirect : compilation_unit_header -> natural -> parser attribute_value
let parser_of_attribute_form_non_indirect cuh n = 
(* address*)
  if n = attribute_form_encode "DW_FORM_addr"         then 
    match cuh.cuh_address_size with
    | 4 -> pr_map2 (fun n -> AV_addr n) parse_uint32
    | 8 -> pr_map2 (fun n -> AV_addr n) parse_uint64
    | _ -> Assert_extra.failwith "cuh_address_size not 4 or 8"
    end
(* block *)
  else if n = attribute_form_encode "DW_FORM_block1"       then 
    (fun pc -> pr_bind (parse_uint8 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block2"       then 
    (fun pc -> pr_bind (parse_uint16 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block4"       then 
    (fun pc -> pr_bind (parse_uint32 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block"        then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
(* constant *)
  else if n = attribute_form_encode "DW_FORM_data1"        then 
    pr_map2 (fun bs -> AV_block 1 bs) (parse_n_bytes 1)
  else if n = attribute_form_encode "DW_FORM_data2"        then 
    pr_map2 (fun bs -> AV_block 2 bs) (parse_n_bytes 2)
  else if n = attribute_form_encode "DW_FORM_data4"        then 
    pr_map2 (fun bs -> AV_block 4 bs) (parse_n_bytes 4)
  else if n = attribute_form_encode "DW_FORM_data8"        then 
    pr_map2 (fun bs -> AV_block 8 bs) (parse_n_bytes 8)
  else if n = attribute_form_encode "DW_FORM_sdata"        then 
    pr_map2 (fun i -> AV_constant_SLEB128 i) parse_SLEB128
  else if n = attribute_form_encode "DW_FORM_udata"        then 
    pr_map2 (fun n -> AV_constant_ULEB128 n) parse_ULEB128
(* exprloc *)
  else if n = attribute_form_encode "DW_FORM_exprloc"      then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_exprloc n bs) (parse_n_bytes n pc')))
(* flag *)
  else if n = attribute_form_encode "DW_FORM_flag"         then 
    pr_map2 (fun n -> AV_flag (n<>0)) parse_uint8
  else if n = attribute_form_encode "DW_FORM_flag_present" then 
    pr_map2 (fun () -> AV_flag true) (pr_return ())
(* lineptr, loclistptr, macptr, rangelistptr *)
  else if n = attribute_form_encode "DW_FORM_sec_offset"   then 
    match cuh.cuh_dwarf_format with
    | Dwarf32 -> pr_map2 (fun n -> AV_sec_offset n) parse_uint32
    | Dwarf64 -> pr_map2 (fun n -> AV_sec_offset n) parse_uint64
    end
(* reference - first type *)
  else if n = attribute_form_encode "DW_FORM_ref1"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint8
  else if n = attribute_form_encode "DW_FORM_ref2"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint16
  else if n = attribute_form_encode "DW_FORM_ref4"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint32
  else if n = attribute_form_encode "DW_FORM_ref8"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint64
  else if n = attribute_form_encode "DW_FORM_ref_udata"    then 
    pr_map2 (fun n -> AV_ref n) parse_ULEB128
(* reference - second type *)
  else if n = attribute_form_encode "DW_FORM_ref_addr"     then 
    match cuh.cuh_dwarf_format with
    | Dwarf32 -> pr_map2 (fun n -> AV_ref_addr n) parse_uint32
    | Dwarf64 -> pr_map2 (fun n -> AV_ref_addr n) parse_uint64
    end
(* reference - third type *)
  else if n = attribute_form_encode "DW_FORM_ref_sig8"     then 
    pr_map2 (fun n -> AV_ref_sig8 n) parse_uint64
(* string *)
  else if n = attribute_form_encode "DW_FORM_string"       then 
    pr_map2 (fun bs -> AV_string bs) parse_string
  else if n = attribute_form_encode "DW_FORM_strp"         then 
    match cuh.cuh_dwarf_format with
    | Dwarf32 -> pr_map2 (fun n -> AV_strp n) parse_uint32
    | Dwarf64 -> pr_map2 (fun n -> AV_strp n) parse_uint64
    end
(* indirect (cycle detection) *)
  else if n = attribute_form_encode "DW_FORM_indirect"     then 
    Assert_extra.failwith "DW_FORM_INDIRECT cycle"
(* unknown *)
  else
    Assert_extra.failwith "parser_of_attribute_form_non_indirect: unknown attribute form"


let parser_of_attribute_form cuh n = 
  if n = attribute_form_encode "DW_FORM_indirect"     then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n ->
      parser_of_attribute_form_non_indirect cuh n) )
  else 
    parser_of_attribute_form_non_indirect cuh n 


(** compilation unit header: pp and parsing *)

let pp_unit_header (s:string) (x:compilation_unit_header) : string = 
    "  " ^ s ^ " Unit @ offset " ^ pphex x.cuh_offset ^ ":\n"
  ^ "   Length:        " ^ pphex x.cuh_unit_length ^ " " ^ match x.cuh_dwarf_format with Dwarf32 -> "(32-bit)" | Dwarf64 -> "(64-bit)" end ^ "\n"
  ^ "   Version:       " ^ show x.cuh_version ^ "\n"
  ^ "   Abbrev Offset: " ^ pphex x.cuh_debug_abbrev_offset ^ "\n"
  ^ "   Pointer Size:  " ^ show x.cuh_address_size ^ "\n"

let pp_compilation_unit_header (x:compilation_unit_header) : string = 
  pp_unit_header "Type" x

let parse_unit_length : parser (dwarf_format * natural) =
    fun (pc: parse_context) -> 
      pr_bind (parse_uint32 pc) (fun x pc' ->
        if x < natural_of_hex "0xfffffff0" then PR_success (Dwarf32,x) pc'
        else if x <> natural_of_hex "0xffffffff" then PR_fail "bad unit_length" pc
        else 
          pr_bind (parse_uint64 pc') (fun x' pc'' -> 
            PR_success (Dwarf64, x') pc'))
      
let parse_uintDwarfN (df: dwarf_format) : parser natural =
    match df with
    | Dwarf32 -> parse_uint32
    | Dwarf64 -> parse_uint64
    end

let parse_compilation_unit_header : parser compilation_unit_header = 
    pr_post_map 
      (pr_with_pos 
         (parse_dependent_pair 
            parse_unit_length
            (fun (df,ul) -> 
              parse_triple 
                parse_uint16 (* version *)
                (parse_uintDwarfN df) (* debug abbrev offset *)
                parse_uint8 (* address_size *))))
      (fun (offset,((df,ul), (v, (dao, as')))) -> 
        <|
        cuh_offset = offset;
        cuh_dwarf_format = df;
        cuh_unit_length = ul;
        cuh_version = v;
        cuh_debug_abbrev_offset = dao;
        cuh_address_size = as';
      |>)


(** type unit header: pp and parsing *)

(* the test binaries don't have a .debug_types section, so this isn't tested *)

let pp_type_unit_header (x:type_unit_header) : string = 
  pp_unit_header "Type" x.tuh_cuh
  ^ "   Type Signature:  " ^ pphex x.tuh_type_signature ^ "\n"
  ^ "   Type Offset:  " ^ pphex x.tuh_type_offset ^ "\n"

      
let parse_type_unit_header : parser type_unit_header = 
    pr_post_map 
      (parse_dependent_pair 
         parse_compilation_unit_header
         (fun cuh ->
           parse_pair 
             parse_uint64 (* type signature *)
             (parse_uintDwarfN cuh.cuh_dwarf_format) (* type offset *) ))
      (fun (cuh, (ts, to')) -> 
        <|
        tuh_cuh = cuh;
        tuh_type_signature = ts;
        tuh_type_offset = to';
      |>)
        

(** debugging information entries: pp and parsing *)

(* example pp from readelf
 <2><51>: Abbrev Number: 3 (DW_TAG_variable)
    <52>   DW_AT_name        : x	
    <54>   DW_AT_decl_file   : 1	
    <55>   DW_AT_decl_line   : 2	
    <56>   DW_AT_type        : <0x6a>	
    <5a>   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
*)

let pp_pos pos = "<" ^ pphex pos ^">"

let pp_die_attribute (cuh:compilation_unit_header) (str : list byte) (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) : string = 
  pp_pos pos  ^ "   " 
  ^ pp_attribute_encoding at ^ "     : "
  ^ "(" ^ pp_attribute_form_encoding af ^ ") "
  ^ pp_attribute_value cuh str at av
  ^ "\n"

val pp_die : compilation_unit_header -> list byte -> natural -> die -> string
let rec pp_die cuh str level die = 
  "<" ^ show level ^ ">" 
  ^ pp_pos die.die_offset
  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code 
  ^ " (" ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^")\n"
  ^
    let ats = List.zip 
        die.die_abbreviation_declaration.ad_attribute_specifications 
        die.die_attribute_values in
    (myconcat "" (List.map (pp_die_attribute cuh str) ats))
    ^
      (myconcat "" (List.map (pp_die cuh str (level +1)) die.die_children))


val parse_die : list byte -> compilation_unit_header -> (natural->abbreviation_declaration) -> parser (maybe die)
let rec parse_die str cuh find_abbreviation_declaration = 
  fun (pc: parse_context) ->
    let _ = my_debug3 ("parse_die called at " ^ pp_parse_context pc ^ "\n") in
    pr_bind (parse_ULEB128 pc) (fun abbreviation_code pc' -> 
      if abbreviation_code = 0 then PR_success Nothing pc' 
      else
        let _ = my_debug3 ("parse_die abbreviation code "^pphex abbreviation_code ^"\n") in
        let ad = find_abbreviation_declaration abbreviation_code in
        let attribute_value_parsers = List.map (fun (at,af) -> pr_with_pos (parser_of_attribute_form cuh af)) ad.ad_attribute_specifications in
        pr_bind (parse_parser_list attribute_value_parsers pc') (fun avs pc'' ->

(*          
          let die_header = 
            <| 
            die_offset = pc.pc_offset;
            die_abbreviation_code = abbreviation_code;
            die_abbreviation_declaration = ad;
            die_attribute_values = avs;
            die_children = [];
          |> in let _ = my_debug3 ("die_header " ^ pp_die cuh str 999 die_header) in 
  *)          
            pr_bind 
              (if ad.ad_has_children then parse_list (parse_die str cuh find_abbreviation_declaration) pc'' else pr_return [] pc'')
              (fun dies pc''' -> 
                PR_success (Just ( let die = 
                  <| 
                  die_offset = pc.pc_offset;
                  die_abbreviation_code = abbreviation_code;
                  die_abbreviation_declaration = ad;
                  die_attribute_values = avs;
                  die_children = dies;
                |> in (* let _ = my_debug3 ("die entire " ^ pp_die cuh str 999 die) in *)die)) pc''')))


(** compilation units: pp and parsing *)

let pp_compilation_unit (debug_str_section_body: list byte) cu = 
  pp_compilation_unit_header cu.cu_header
  ^ pp_abbreviations_table cu.cu_abbreviations_table
  ^ pp_die cu.cu_header debug_str_section_body 0 cu.cu_die

let pp_compilation_units debug_string_section_body (compilation_units: list compilation_unit) : string = 
  myconcat "" (List.map (pp_compilation_unit debug_string_section_body) compilation_units)

                        
let parse_compilation_unit (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte) : parser (maybe compilation_unit) =
    fun (pc:parse_context) ->
  
      if pc.pc_bytes = [] then PR_success Nothing pc else
      
      let (cuh, pc') = 

        match parse_compilation_unit_header pc with
        | PR_fail s pc' -> Assert_extra.failwith ("parse_cuh_header fail: " ^ pp_parse_fail s pc')
        | PR_success cuh pc' -> (cuh,pc')
        end in

      let _ = my_debug4 (pp_compilation_unit_header cuh) in 

      let pc_abbrev = <|pc_bytes = match mydrop cuh.cuh_debug_abbrev_offset debug_abbrev_section_body with Just bs -> bs | Nothing -> Assert_extra.failwith "mydrop of debug_abbrev" end; pc_offset = cuh.cuh_debug_abbrev_offset  |> in

      let abbreviations_table = 
        match parse_abbreviations_table pc_abbrev with
        | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
        | PR_success at pc_abbrev' -> at
        end in

      let _ = my_debug4 (pp_abbreviations_table abbreviations_table) in

      let find_abbreviation_declaration (ac:natural) : abbreviation_declaration = 
        let _ = my_debug4 ("find_abbreviation_declaration "^pphex ac) in 
        myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table  in

      let _ = my_debug3 (pp_abbreviations_table abbreviations_table) in

      match parse_die debug_str_section_body cuh find_abbreviation_declaration pc' with
      | PR_fail s pc'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc'')
      | PR_success (Nothing) pc'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc'')
      | PR_success (Just die) pc'' -> 
          let cu = 
            <| 
            cu_header = cuh;
            cu_abbreviations_table = abbreviations_table;
            cu_die = die;
          |> in
          PR_success (Just cu) pc''
      end 

let parse_compilation_units (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte): parser (list compilation_unit) 
    =
  parse_list (parse_compilation_unit debug_str_section_body debug_abbrev_section_body)


(** type units: pp and parsing *)

let pp_type_unit (debug_str_section_body: list byte) tu = 
  pp_type_unit_header tu.tu_header
  ^ pp_abbreviations_table tu.tu_abbreviations_table
  ^ pp_die tu.tu_header.tuh_cuh debug_str_section_body 0 tu.tu_die

let pp_type_units debug_string_section_body (type_units: list type_unit) : string = 
  myconcat "" (List.map (pp_type_unit debug_string_section_body) type_units)

                        
let parse_type_unit (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte) : parser (maybe type_unit) =
    fun (pc:parse_context) ->
  
      if pc.pc_bytes = [] then PR_success Nothing pc else
      
      let (tuh, pc') = 
        match parse_type_unit_header pc with
        | PR_fail s pc' -> Assert_extra.failwith ("parse_tuh_header fail: " ^ pp_parse_fail s pc')
        | PR_success tuh pc' -> (tuh,pc')
        end in

      let _ = my_debug4 (pp_type_unit_header tuh) in 

      let pc_abbrev = let n = tuh.tuh_cuh.cuh_debug_abbrev_offset in <|pc_bytes = match mydrop n debug_abbrev_section_body with Just bs -> bs | Nothing -> Assert_extra.failwith "mydrop of debug_abbrev" end; pc_offset = n  |> in

      let abbreviations_table = 
        match parse_abbreviations_table pc_abbrev with
        | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
        | PR_success at pc_abbrev' -> at
        end in

      let _ = my_debug4 (pp_abbreviations_table abbreviations_table) in

      let find_abbreviation_declaration (ac:natural) : abbreviation_declaration = 
        let _ = my_debug4 ("find_abbreviation_declaration "^pphex ac) in 
        myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table  in

      let _ = my_debug3 (pp_abbreviations_table abbreviations_table) in

      match parse_die debug_str_section_body tuh.tuh_cuh find_abbreviation_declaration pc' with
      | PR_fail s pc'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc'')
      | PR_success (Nothing) pc'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc'')
      | PR_success (Just die) pc'' -> 
          let tu = 
            <| 
            tu_header = tuh;
            tu_abbreviations_table = abbreviations_table;
            tu_die = die;
          |> in
          PR_success (Just tu) pc''
      end 

let parse_type_units (debug_str_section_body: list byte) (debug_abbrev_section_body: list byte): parser (list type_unit) 
    =
  parse_list (parse_type_unit debug_str_section_body debug_abbrev_section_body)



(** all dwarf info: pp and parsing *)

let pp_dwarf d = 
   pp_compilation_units d.d_str d.d_compilation_units 

let parse_dwarf
    (debug_info_section_body: list byte) 
    (debug_abbrev_section_body: list byte) 
    (debug_str_section_body: list byte) 
    : dwarf =

  let pc_info = <|pc_bytes = debug_info_section_body; pc_offset = 0  |> in
  
  let compilation_units = 
    match parse_compilation_units debug_str_section_body debug_abbrev_section_body pc_info with
    | PR_fail s pc_info' ->  Assert_extra.failwith ("parse_compilation_units: " ^ pp_parse_fail s pc_info')
    | PR_success cus pc_info' -> cus
    end in

   <| 
   d_str = debug_str_section_body;
   d_compilation_units = compilation_units;
   d_type_units = []; 
  |>


(** top level *)

let just_one s xs = 
  match xs with
  | [] -> Assert_extra.failwith ("no " ^ s)
  | x1::x2::_ -> Assert_extra.failwith ("more than one " ^ s)
  | [x] -> x
  end

val harness_string_of_elf64_debug_info_section : elf64_file -> byte_sequence -> (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf64_debug_info_section f1 bs0 os proc usr hdr sht stbl =

  let extract_section_body section_name = 
    let sections = 
      List.filter 
        (fun x -> 
          x.Elf_interpreted_section.elf64_section_name_as_string = section_name
        ) f1.elf64_file_interpreted_sections in
    let section = just_one (section_name ^ " sections")  sections  in
    let section_body =  match section.Elf_interpreted_section.elf64_section_body with Sequence bs -> bs end in
    let _ = my_debug3 (section_name ^ ": \n" ^ Elf_interpreted_section.string_of_elf64_interpreted_section section ^ "\n"
                          ^ "  body = " ^ ppbytes2 0 section_body ^ "\n") in
    section_body in

  let debug_abbrev_section_body = extract_section_body ".debug_abbrev" in
  let debug_info_section_body = extract_section_body ".debug_info" in
  let debug_str_section_body = extract_section_body ".debug_str" in

  let d = parse_dwarf debug_info_section_body debug_abbrev_section_body debug_str_section_body in
  pp_dwarf d
    

val harness_string_of_elf32_debug_info_section : elf32_file -> byte_sequence -> (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf32_debug_info_section f1 bs0 os proc usr hdr sht stbl =
  "NOT IMPLEMENTED"
