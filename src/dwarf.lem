open import Basic_classes
open import Bool
open import Function
open import Maybe
open import Num
open import String

open import Byte_sequence
open import Error
open import Hex_printing
open import Missing_pervasives
open import Show

open import Default_printing

open import Endianness
open import String_table

open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint


(** ***************** experimental DWARF stuff *********** *)


(* hex parsing *)

val natural_of_char : char -> natural 
let natural_of_char c =
  let naturalOrd c' = naturalFromNat (String_extra.ord c') in
  let n = naturalOrd c in 
  if n >= naturalOrd #'0' && n <= naturalOrd #'9' then n - naturalOrd #'0' 
  else if n >= naturalOrd #'A' && n <= naturalOrd #'F' then n - naturalOrd #'A' + 10
  else if n >= naturalOrd #'a' && n <= naturalOrd #'f' then n - naturalOrd #'a' + 10
  else Assert_extra.failwith ("natural_of_char argument #'" ^ String.toString [c] ^ "' not in 0-9,A-F,a-f")


val natural_of_hex' : list char -> natural
let rec natural_of_hex' cs = 
  match cs with
  | c :: cs' -> natural_of_char c + 16 * natural_of_hex' cs'
  | [] -> 0
  end

val natural_of_hex : string -> natural
let natural_of_hex s =
  let cs = String.toCharList s in
  match cs with
  | #'0'::#'x'::cs' -> 
      match cs' with
      | c :: _ -> natural_of_hex' (List.reverse cs')
      | [] -> Assert_extra.failwith ("natural_of_hex argument \"" ^ s ^ "\" has no digits")
      end
  | _ -> Assert_extra.failwith ("natural_of_hex argument \"" ^ s ^ "\" does not begin 0x")
  end





(** dwarf types *)

(* dwarf format *)

type dwarf_format =
  | Dwarf32
  | Dwarf64

(** tag encodings *)
let tag_encodings = [
  ("DW_TAG_array_type"               , natural_of_hex "0x01"  ); 
  ("DW_TAG_class_type"               , natural_of_hex "0x02"  ); 
  ("DW_TAG_entry_point"              , natural_of_hex "0x03"  ); 
  ("DW_TAG_enumeration_type"         , natural_of_hex "0x04"  ); 
  ("DW_TAG_formal_parameter"         , natural_of_hex "0x05"  ); 
  ("DW_TAG_imported_declaration"     , natural_of_hex "0x08"  ); 
  ("DW_TAG_label"                    , natural_of_hex "0x0a"  ); 
  ("DW_TAG_lexical_block"            , natural_of_hex "0x0b"  ); 
  ("DW_TAG_member"                   , natural_of_hex "0x0d"  ); 
  ("DW_TAG_pointer_type"             , natural_of_hex "0x0f"  ); 
  ("DW_TAG_reference_type"           , natural_of_hex "0x10"  ); 
  ("DW_TAG_compile_unit"             , natural_of_hex "0x11"  ); 
  ("DW_TAG_string_type"              , natural_of_hex "0x12"  ); 
  ("DW_TAG_structure_type"           , natural_of_hex "0x13"  ); 
  ("DW_TAG_subroutine_type"          , natural_of_hex "0x15"  ); 
  ("DW_TAG_typedef"                  , natural_of_hex "0x16"  ); 
  ("DW_TAG_union_type"               , natural_of_hex "0x17"  ); 
  ("DW_TAG_unspecified_parameters"   , natural_of_hex "0x18"  ); 
  ("DW_TAG_variant"                  , natural_of_hex "0x19"  ); 
  ("DW_TAG_common_block"             , natural_of_hex "0x1a"  ); 
  ("DW_TAG_common_inclusion"         , natural_of_hex "0x1b"  ); 
  ("DW_TAG_inheritance"              , natural_of_hex "0x1c"  ); 
  ("DW_TAG_inlined_subroutine"       , natural_of_hex "0x1d"  ); 
  ("DW_TAG_module"                   , natural_of_hex "0x1e"  ); 
  ("DW_TAG_ptr_to_member_type"       , natural_of_hex "0x1f"  ); 
  ("DW_TAG_set_type"                 , natural_of_hex "0x20"  ); 
  ("DW_TAG_subrange_type"            , natural_of_hex "0x21"  ); 
  ("DW_TAG_with_stmt"                , natural_of_hex "0x22"  ); 
  ("DW_TAG_access_declaration"       , natural_of_hex "0x23"  ); 
  ("DW_TAG_base_type"                , natural_of_hex "0x24"  ); 
  ("DW_TAG_catch_block"              , natural_of_hex "0x25"  ); 
  ("DW_TAG_const_type"               , natural_of_hex "0x26"  ); 
  ("DW_TAG_constant"                 , natural_of_hex "0x27"  ); 
  ("DW_TAG_enumerator"               , natural_of_hex "0x28"  ); 
  ("DW_TAG_file_type"                , natural_of_hex "0x29"  ); 
  ("DW_TAG_friend"                   , natural_of_hex "0x2a"  ); 
  ("DW_TAG_namelist"                 , natural_of_hex "0x2b"  ); 
  ("DW_TAG_namelist_item"            , natural_of_hex "0x2c"  ); 
  ("DW_TAG_packed_type"              , natural_of_hex "0x2d"  ); 
  ("DW_TAG_subprogram"               , natural_of_hex "0x2e"  ); 
  ("DW_TAG_template_type_parameter"  , natural_of_hex "0x2f"  ); 
  ("DW_TAG_template_value_parameter" , natural_of_hex "0x30"  ); 
  ("DW_TAG_thrown_type"              , natural_of_hex "0x31"  ); 
  ("DW_TAG_try_block"                , natural_of_hex "0x32"  ); 
  ("DW_TAG_variant_part"             , natural_of_hex "0x33"  ); 
  ("DW_TAG_variable"                 , natural_of_hex "0x34"  ); 
  ("DW_TAG_volatile_type"            , natural_of_hex "0x35"  ); 
  ("DW_TAG_dwarf_procedure"          , natural_of_hex "0x36"  ); 
  ("DW_TAG_restrict_type"            , natural_of_hex "0x37"  ); 
  ("DW_TAG_interface_type"           , natural_of_hex "0x38"  ); 
  ("DW_TAG_namespace"                , natural_of_hex "0x39"  ); 
  ("DW_TAG_imported_module"          , natural_of_hex "0x3a"  ); 
  ("DW_TAG_unspecified_type"         , natural_of_hex "0x3b"  ); 
  ("DW_TAG_partial_unit"             , natural_of_hex "0x3c"  ); 
  ("DW_TAG_imported_unit"            , natural_of_hex "0x3d"  ); 
  ("DW_TAG_condition"                , natural_of_hex "0x3f"  ); 
  ("DW_TAG_shared_type"              , natural_of_hex "0x40"  ); 
  ("DW_TAG_type_unit"                , natural_of_hex "0x41"  ); 
  ("DW_TAG_rvalue_reference_type"    , natural_of_hex "0x42"  ); 
  ("DW_TAG_template_alias"           , natural_of_hex "0x43"  ); 
  ("DW_TAG_lo_user"                  , natural_of_hex "0x4080"); 
  ("DW_TAG_hi_user"                  , natural_of_hex "0xffff")
]



(** child determination encodings *)
let DW_CHILDREN_no  = natural_of_hex "0x00"
let DW_CHILDREN_yes = natural_of_hex "0x01"


type dwarf_attribute_classes = 
  | DWA_7_5_3
  | DWA_address
  | DWA_block
  | DWA_constant
  | DWA_dash
  | DWA_exprloc
  | DWA_flag 
  | DWA_lineptr
  | DWA_loclistptr
  | DWA_macptr
  | DWA_rangelistptr
  | DWA_reference
  | DWA_string




(** attribute encodings *)

let attribute_encodings = [
  ("DW_AT_sibling"              , natural_of_hex "0x01", [DWA_reference])                                   ;
  ("DW_AT_location"             , natural_of_hex "0x02", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_name"                 , natural_of_hex "0x03", [DWA_string])                                      ;
  ("DW_AT_ordering"             , natural_of_hex "0x09", [DWA_constant])                                    ;
  ("DW_AT_byte_size"            , natural_of_hex "0x0b", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_offset"           , natural_of_hex "0x0c", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_bit_size"             , natural_of_hex "0x0d", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_stmt_list"            , natural_of_hex "0x10", [DWA_lineptr])                                     ;
  ("DW_AT_low_pc"               , natural_of_hex "0x11", [DWA_address])                                     ;
  ("DW_AT_high_pc"              , natural_of_hex "0x12", [DWA_address; DWA_constant])                       ;
  ("DW_AT_language"             , natural_of_hex "0x13", [DWA_constant])                                    ;
  ("DW_AT_discr"                , natural_of_hex "0x15", [DWA_reference])                                   ;
  ("DW_AT_discr_value"          , natural_of_hex "0x16", [DWA_constant])                                    ;
  ("DW_AT_visibility"           , natural_of_hex "0x17", [DWA_constant])                                    ;
  ("DW_AT_import"               , natural_of_hex "0x18", [DWA_reference])                                   ;
  ("DW_AT_string_length"        , natural_of_hex "0x19", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_common_reference"     , natural_of_hex "0x1a", [DWA_reference])                                   ;
  ("DW_AT_comp_dir"             , natural_of_hex "0x1b", [DWA_string])                                      ;
  ("DW_AT_const_value"          , natural_of_hex "0x1c", [DWA_block; DWA_constant; DWA_string])             ;
  ("DW_AT_containing_type"      , natural_of_hex "0x1d", [DWA_reference])                                   ;
  ("DW_AT_default_value"        , natural_of_hex "0x1e", [DWA_reference])                                   ;
  ("DW_AT_inline"               , natural_of_hex "0x20", [DWA_constant])                                    ;
  ("DW_AT_is_optional"          , natural_of_hex "0x21", [DWA_flag])                                        ;
  ("DW_AT_lower_bound"          , natural_of_hex "0x22", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_producer"             , natural_of_hex "0x25", [DWA_string])                                      ;
  ("DW_AT_prototyped"           , natural_of_hex "0x27", [DWA_flag])                                        ;
  ("DW_AT_return_addr"          , natural_of_hex "0x2a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_start_scope"          , natural_of_hex "0x2c", [DWA_constant; DWA_rangelistptr])                  ;
  ("DW_AT_bit_stride"           , natural_of_hex "0x2e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_upper_bound"          , natural_of_hex "0x2f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_abstract_origin"      , natural_of_hex "0x31", [DWA_reference])                                   ;
  ("DW_AT_accessibility"        , natural_of_hex "0x32", [DWA_constant])                                    ;
  ("DW_AT_address_class"        , natural_of_hex "0x33", [DWA_constant])                                    ;
  ("DW_AT_artificial"           , natural_of_hex "0x34", [DWA_flag])                                        ;
  ("DW_AT_base_types"           , natural_of_hex "0x35", [DWA_reference])                                   ;
  ("DW_AT_calling_convention"   , natural_of_hex "0x36", [DWA_constant])                                    ;
  ("DW_AT_count"                , natural_of_hex "0x37", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_member_location" , natural_of_hex "0x38", [DWA_constant; DWA_exprloc; DWA_loclistptr])       ;
  ("DW_AT_decl_column"          , natural_of_hex "0x39", [DWA_constant])                                    ;
  ("DW_AT_decl_file"            , natural_of_hex "0x3a", [DWA_constant])                                    ;
  ("DW_AT_decl_line"            , natural_of_hex "0x3b", [DWA_constant])                                    ;
  ("DW_AT_declaration"          , natural_of_hex "0x3c", [DWA_flag])                                        ;
  ("DW_AT_discr_list"           , natural_of_hex "0x3d", [DWA_block])                                       ;
  ("DW_AT_encoding"             , natural_of_hex "0x3e", [DWA_constant])                                    ;
  ("DW_AT_external"             , natural_of_hex "0x3f", [DWA_flag])                                        ;
  ("DW_AT_frame_base"           , natural_of_hex "0x40", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_friend"               , natural_of_hex "0x41", [DWA_reference])                                   ;
  ("DW_AT_identifier_case"      , natural_of_hex "0x42", [DWA_constant])                                    ;
  ("DW_AT_macro_info"           , natural_of_hex "0x43", [DWA_macptr])                                      ;
  ("DW_AT_namelist_item"        , natural_of_hex "0x44", [DWA_reference])                                   ;
  ("DW_AT_priority"             , natural_of_hex "0x45", [DWA_reference])                                   ;
  ("DW_AT_segment"              , natural_of_hex "0x46", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_specification"        , natural_of_hex "0x47", [DWA_reference])                                   ;
  ("DW_AT_static_link"          , natural_of_hex "0x48", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_type"                 , natural_of_hex "0x49", [DWA_reference])                                   ;
  ("DW_AT_use_location"         , natural_of_hex "0x4a", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_variable_parameter"   , natural_of_hex "0x4b", [DWA_flag])                                        ;
  ("DW_AT_virtuality"           , natural_of_hex "0x4c", [DWA_constant])                                    ;
  ("DW_AT_vtable_elem_location" , natural_of_hex "0x4d", [DWA_exprloc; DWA_loclistptr])                     ;
  ("DW_AT_allocated"            , natural_of_hex "0x4e", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_associated"           , natural_of_hex "0x4f", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_data_location"        , natural_of_hex "0x50", [DWA_exprloc])                                     ;
  ("DW_AT_byte_stride"          , natural_of_hex "0x51", [DWA_constant; DWA_exprloc; DWA_reference])        ;
  ("DW_AT_entry_pc"             , natural_of_hex "0x52", [DWA_address])                                     ;
  ("DW_AT_use_UTF8"             , natural_of_hex "0x53", [DWA_flag])                                        ;
  ("DW_AT_extension"            , natural_of_hex "0x54", [DWA_reference])                                   ;
  ("DW_AT_ranges"               , natural_of_hex "0x55", [DWA_rangelistptr])                                ;
  ("DW_AT_trampoline"           , natural_of_hex "0x56", [DWA_address; DWA_flag; DWA_reference; DWA_string]);
  ("DW_AT_call_column"          , natural_of_hex "0x57", [DWA_constant])                                    ;
  ("DW_AT_call_file"            , natural_of_hex "0x58", [DWA_constant])                                    ;
  ("DW_AT_call_line"            , natural_of_hex "0x59", [DWA_constant])                                    ;
  ("DW_AT_description"          , natural_of_hex "0x5a", [DWA_string])                                      ;
  ("DW_AT_binary_scale"         , natural_of_hex "0x5b", [DWA_constant])                                    ;
  ("DW_AT_decimal_scale"        , natural_of_hex "0x5c", [DWA_constant])                                    ;
  ("DW_AT_small"                , natural_of_hex "0x5d", [DWA_reference])                                   ;
  ("DW_AT_decimal_sign"         , natural_of_hex "0x5e", [DWA_constant])                                    ;
  ("DW_AT_digit_count"          , natural_of_hex "0x5f", [DWA_constant])                                    ;
  ("DW_AT_picture_string"       , natural_of_hex "0x60", [DWA_string])                                      ;
  ("DW_AT_mutable"              , natural_of_hex "0x61", [DWA_flag])                                        ;
  ("DW_AT_threads_scaled"       , natural_of_hex "0x62", [DWA_flag])                                        ;
  ("DW_AT_explicit"             , natural_of_hex "0x63", [DWA_flag])                                        ;
  ("DW_AT_object_pointer"       , natural_of_hex "0x64", [DWA_reference])                                   ;
  ("DW_AT_endianity"            , natural_of_hex "0x65", [DWA_constant])                                    ;
  ("DW_AT_elemental"            , natural_of_hex "0x66", [DWA_flag])                                        ;
  ("DW_AT_pure"                 , natural_of_hex "0x67", [DWA_flag])                                        ;
  ("DW_AT_recursive"            , natural_of_hex "0x68", [DWA_flag])                                        ;
  ("DW_AT_signature"            , natural_of_hex "0x69", [DWA_reference])                                   ;
  ("DW_AT_main_subprogram"      , natural_of_hex "0x6a", [DWA_flag])                                        ;
  ("DW_AT_data_bit_offset"      , natural_of_hex "0x6b", [DWA_constant])                                    ;
  ("DW_AT_const_expr"           , natural_of_hex "0x6c", [DWA_flag])                                        ;
  ("DW_AT_enum_class"           , natural_of_hex "0x6d", [DWA_flag])                                        ;
  ("DW_AT_linkage_name"         , natural_of_hex "0x6e", [DWA_string])                                      ;
  ("DW_AT_lo_user"              , natural_of_hex "0x2000", [DWA_dash])                                      ;
  ("DW_AT_hi_user"              , natural_of_hex "0x3fff", [DWA_dash])                                      
]

(** attribute form encodings *)




let attribute_form_encodings = [
  ("DW_FORM_addr"        , natural_of_hex "0x01", [DWA_address])  ;
  ("DW_FORM_block2"      , natural_of_hex "0x03", [DWA_block])    ;
  ("DW_FORM_block4"      , natural_of_hex "0x04", [DWA_block])    ;
  ("DW_FORM_data2"       , natural_of_hex "0x05", [DWA_constant]) ;
  ("DW_FORM_data4"       , natural_of_hex "0x06", [DWA_constant]) ;
  ("DW_FORM_data8"       , natural_of_hex "0x07", [DWA_constant]) ;
  ("DW_FORM_string"      , natural_of_hex "0x08", [DWA_string])   ;
  ("DW_FORM_block"       , natural_of_hex "0x09", [DWA_block])    ;
  ("DW_FORM_block1"      , natural_of_hex "0x0a", [DWA_block])    ;
  ("DW_FORM_data1"       , natural_of_hex "0x0b", [DWA_constant]) ;
  ("DW_FORM_flag"        , natural_of_hex "0x0c", [DWA_flag])     ;
  ("DW_FORM_sdata"       , natural_of_hex "0x0d", [DWA_constant]) ;
  ("DW_FORM_strp"        , natural_of_hex "0x0e", [DWA_string])   ;
  ("DW_FORM_udata"       , natural_of_hex "0x0f", [DWA_constant]) ;
  ("DW_FORM_ref_addr"    , natural_of_hex "0x10", [DWA_reference]);
  ("DW_FORM_ref1"        , natural_of_hex "0x11", [DWA_reference]);
  ("DW_FORM_ref2"        , natural_of_hex "0x12", [DWA_reference]);
  ("DW_FORM_ref4"        , natural_of_hex "0x13", [DWA_reference]);
  ("DW_FORM_ref8"        , natural_of_hex "0x14", [DWA_reference]);
  ("DW_FORM_ref_udata"   , natural_of_hex "0x15", [DWA_reference]);
  ("DW_FORM_indirect"    , natural_of_hex "0x16", [DWA_7_5_3])    ;
  ("DW_FORM_sec_offset"  , natural_of_hex "0x17", [DWA_lineptr; DWA_loclistptr; DWA_macptr; DWA_rangelistptr]) ;
  ("DW_FORM_exprloc"     , natural_of_hex "0x18", [DWA_exprloc])  ;
  ("DW_FORM_flag_present", natural_of_hex "0x19", [DWA_flag])     ;
  ("DW_FORM_ref_sig8"    , natural_of_hex "0x20", [DWA_reference])
]

type attribute_value =
  | AV_addr of natural
  | AV_block of natural * list byte
  | AV_constantN of natural * list byte
  | AV_constant_SLEB128 of integer
  | AV_constant_ULEB128 of natural
  | AV_exprloc of natural * list byte
  | AV_flag of bool
  | AV_ref of natural 
  | AV_ref_addr of natural (* dwarf_format dependent *)
  | AV_ref_sig8 of natural
  | AV_sec_offset of natural
  | AV_string of list byte (* not including terminating null *)
  | AV_strp of natural (* dwarf_format dependent *)


(** operation encodings *)

(*
DW_OP_addr                0x03 1   constant address (size target specific)
DW_OP_deref               0x06 0
DW_OP_const1u             0x08 1 1-byte constant
DW_OP_const1s             0x09 1 1-byte constant
DW_OP_const2u             0x0a 1 2-byte constant
DW_OP_const2s             0x0b 1 2-byte constant
DW_OP_const4u             0x0c 1 4-byte constant
DW_OP_const4s             0x0d 1 4-byte constant
DW_OP_const8u             0x0e 1 8-byte constant
DW_OP_const8s             0x0f 1 8-byte constant
DW_OP_constu              0x10 1 ULEB128 constant
DW_OP_consts              0x11 1 SLEB128 constant
DW_OP_dup                 0x12 0 
DW_OP_drop                0x13 0 
DW_OP_over                0x14 0 
DW_OP_pick                0x15 1  1-byte stack index
DW_OP_swap                0x16 0 
DW_OP_rot                 0x17 0 
DW_OP_xderef              0x18 0 
DW_OP_abs                 0x19 0 
DW_OP_and                 0x1a 0 
DW_OP_div                 0x1b 0 
DW_OP_minus               0x1c 0 
DW_OP_mod                 0x1d 0 
DW_OP_mul                 0x1e 0 
DW_OP_neg                 0x1f 0 
DW_OP_not                 0x20 0 
DW_OP_or                  0x21 0 
DW_OP_plus                0x22 0 
DW_OP_plus_uconst         0x23 1  ULEB128 addend
DW_OP_shl                 0x24 0 
DW_OP_shr                 0x25 0 
DW_OP_shra                0x26 0 
DW_OP_xor                 0x27 0 
DW_OP_skip                0x2f 1 signed 2-byte constant
DW_OP_bra                 0x28 1 signed 2-byte constant
DW_OP_eq                  0x29 0 
DW_OP_ge                  0x2a 0 
DW_OP_gt                  0x2b 0 
DW_OP_le                  0x2c 0 
DW_OP_lt                  0x2d 0 
DW_OP_ne                  0x2e 0 
DW_OP_lit0                0x30 0   literals 0..31 =(DW_OP_lit0 + literal)
DW_OP_lit1                0x31 0
DW_OP_lit2                0x32 0
DW_OP_lit3                0x33 0
DW_OP_lit4                0x34 0
DW_OP_lit5                0x35 0
DW_OP_lit6                0x36 0
DW_OP_lit7                0x37 0
DW_OP_lit8                0x38 0
DW_OP_lit9                0x39 0
DW_OP_lit10               0x3a 0
DW_OP_lit11               0x3b 0
DW_OP_lit12               0x3c 0
DW_OP_lit13               0x3d 0
DW_OP_lit14               0x3e 0
DW_OP_lit15               0x3f 0
DW_OP_lit16               0x40 0
DW_OP_lit17               0x41 0
DW_OP_lit18               0x42 0
DW_OP_lit19               0x43 0
DW_OP_lit20               0x44 0
DW_OP_lit21               0x45 0
DW_OP_lit22               0x46 0
DW_OP_lit23               0x47 0
DW_OP_lit24               0x48 0
DW_OP_lit25               0x49 0
DW_OP_lit26               0x4a 0
DW_OP_lit27               0x4b 0
DW_OP_lit28               0x4c 0
DW_OP_lit29               0x4d 0
DW_OP_lit30               0x4e 0
DW_OP_lit31               0x4f 0
DW_OP_reg0                0x50 1 reg 0..31 = (DW_OP_reg0 + regnum)
DW_OP_reg1                0x51 1
DW_OP_reg2                0x52 1
DW_OP_reg3                0x53 1
DW_OP_reg4                0x54 1
DW_OP_reg5                0x55 1
DW_OP_reg6                0x56 1
DW_OP_reg7                0x57 1
DW_OP_reg8                0x58 1
DW_OP_reg9                0x59 1
DW_OP_reg10               0x5a 1
DW_OP_reg11               0x5b 1
DW_OP_reg12               0x5c 1
DW_OP_reg13               0x5d 1
DW_OP_reg14               0x5e 1
DW_OP_reg15               0x5f 1
DW_OP_reg16               0x60 1
DW_OP_reg17               0x61 1
DW_OP_reg18               0x62 1
DW_OP_reg19               0x63 1
DW_OP_reg20               0x64 1
DW_OP_reg21               0x65 1
DW_OP_reg22               0x66 1
DW_OP_reg23               0x67 1
DW_OP_reg24               0x68 1
DW_OP_reg25               0x69 1
DW_OP_reg26               0x6a 1
DW_OP_reg27               0x6b 1
DW_OP_reg28               0x6c 1
DW_OP_reg29               0x6d 1
DW_OP_reg30               0x6e 1
DW_OP_reg31               0x6f 1 
DW_OP_breg0               0x70 1 base register 0..31 = (DW_OP_breg0 + regnum)
DW_OP_breg1               0x71 1
DW_OP_breg2               0x72 1
DW_OP_breg3               0x73 1
DW_OP_breg4               0x74 1
DW_OP_breg5               0x75 1
DW_OP_breg6               0x76 1
DW_OP_breg7               0x77 1
DW_OP_breg8               0x78 1
DW_OP_breg9               0x79 1
DW_OP_breg10              0x7a 1
DW_OP_breg11              0x7b 1
DW_OP_breg12              0x7c 1
DW_OP_breg13              0x7d 1
DW_OP_breg14              0x7e 1
DW_OP_breg15              0x7f 1
DW_OP_breg16              0x80 1
DW_OP_breg17              0x81 1
DW_OP_breg18              0x82 1
DW_OP_breg19              0x83 1
DW_OP_breg20              0x84 1
DW_OP_breg21              0x85 1
DW_OP_breg22              0x86 1
DW_OP_breg23              0x87 1
DW_OP_breg24              0x88 1
DW_OP_breg25              0x89 1
DW_OP_breg26              0x8a 1
DW_OP_breg27              0x8b 1
DW_OP_breg28              0x8c 1
DW_OP_breg29              0x8d 1
DW_OP_breg30              0x8e 1
DW_OP_breg31              0x8f 1 
DW_OP_regx                0x90 1 ULEB128 register
DW_OP_fbreg               0x91 1 SLEB128 offset
DW_OP_bregx               0x92 2 ULEB128 register followed by SLEB128 offset
DW_OP_piece               0x93 1 ULEB128 size of piece addressed
DW_OP_deref_size          0x94 1 1-byte size of data retrieved
DW_OP_xderef_size         0x95 1 1-byte size of data retrieved
DW_OP_nop                 0x96 0 
DW_OP_push_object_address 0x97 0 
DW_OP_call2               0x98 1 2-byte offset of DIE
DW_OP_call4               0x99 1 4-byte offset of DIE
DW_OP_call_ref            0x9a 1 4- or 8-byte offset of DIE
DW_OP_form_tls_address    0x9b 0 
DW_OP_call_frame_cfa      0x9c 0 
DW_OP_bit_piece           0x9d 2 ULEB128 size followed by ULEB128 offset
DW_OP_implicit_value      0x9e 2 ULEB128 size followed by block of that size
DW_OP_stack_value         0x9f 0 
DW_OP_lo_user             0xe0 
DW_OP_hi_user             0xff 
*)

(** dwarf representation types *)

type abbreviation_declaration = 
    <| 
    ad_abbreviation_code : natural;
    ad_tag : natural;
    ad_has_children : bool;
    ad_attribute_specifications : list (natural * natural);
  |>

type abbreviations_table = list abbreviation_declaration


type die = 
    <|
    die_pos : natural;
    die_abbreviation_code : natural;
    die_abbreviation_declaration : abbreviation_declaration;
    die_attribute_values : list (natural (*pos*) * attribute_value);
    die_children : list die;
  |>


type compilation_unit_header = 
    <| 
    cuh_offset : natural; 
    cuh_dwarf_format : dwarf_format;
    cuh_unit_length : natural;
    cuh_version : natural;
    cuh_debug_abbrev_offset : natural;
    cuh_address_size : natural;
  |> 
    
type compilation_unit = 
    <| 
    cu_header : compilation_unit_header;
    cu_die : die;
    cu_abbreviations_table : abbreviations_table;
    cu_str : list byte;
  |>
    


(* pp of encodings *)

val lookupb : forall 'a 'b. Eq 'b => 'b -> list ('a * 'b) -> maybe 'a
let rec lookupb y0 xys = 
  match xys with
  | [] -> Nothing
  | (x,y)::xys' -> if y=y0 then Just x else lookupb y0 xys'  
  end

val lookupc : forall 'a 'b 'c. Eq 'b => 'b -> list ('a * 'b * 'c) -> maybe 'a
let rec lookupc y0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if y=y0 then Just x else lookupc y0 xyzs'  
  end

val lookupd : forall 'a 'b 'c. Eq 'a => 'a -> list ('a * 'b * 'c) -> maybe 'b
let rec lookupd x0 xyzs = 
  match xyzs with
  | [] -> Nothing
  | (x,y,_)::xyzs' -> if x=x0 then Just y else lookupd x0 xyzs'  
  end


let pp_maybe ppf n = match ppf n with Just s -> s | Nothing -> "encoding not found: " ^ show n end

let pp_tag_encoding n = pp_maybe (fun n -> lookupb n tag_encodings) n
let pp_attribute_encoding n = pp_maybe (fun n -> lookupc n attribute_encodings) n
let pp_attribute_form_encoding n = pp_maybe (fun n -> lookupc n attribute_form_encodings) n

let attribute_form_encode (s: string) : natural = 
  match lookupd s attribute_form_encodings with
  | Just n -> n
  | Nothing -> Assert_extra.failwith "attribute_form_encode"
  end



(** basic pretty printing *)

let pphex n = "0x" ^ unsafe_hex_string_of_natural 0 n

let ppbytes xs = show (List.map (fun x -> show x) xs)

let rec ppbytes2 n xs = match xs with | [] -> "" | x::xs' -> "<"^pphex n^">  "^show x^"\n"^ppbytes2 (n+1) xs' end

  (* workaround: from String *)
val mytoString : list char -> string
declare ocaml    target_rep function mytoString = `Xstring.implode`

let string_of_bytes bs = mytoString (List.map Missing_pervasives.char_of_byte bs)


(** basic parsing *)

(* parsing combinators *)

type parse_context = <| pc_bytes: list byte; pc_offset: natural |> 

type parse_result 'a =
  | PR_success of 'a * parse_context
  | PR_fail of string * parse_context



let pp_parse_context pc = "pc_offset = " ^ pphex pc.pc_offset

let pp_parse_fail s pc = 
  "Parse fail\n" ^ s ^ " at " ^ pp_parse_context pc ^ "\n"

let pp_parse_result ppa pr = 
  match pr with
  | PR_success x pc -> "Parse success\n" ^ ppa x ^ "\n" ^ pp_parse_context pc ^ "\n"
  | PR_fail s pc -> pp_parse_fail s pc  
  end


(* [(>>>=)] is the monadic binding function for [parse_result].  *)
(* there's a type clash if we use >>=, and lem seems to output bad ocaml for >>>= *)

(* workaround debug.lem linking *)
val print_endline : string -> unit
declare ocaml target_rep function print_endline = `print_endline`

let parse_debug s = () (*print_endline s*)
let parse_debug2 s = () (*print_endline s*)
let parse_debug3 s = () (*print_endline s*)
let parse_debug4 s = print_endline s

val pr_bind : forall 'a 'b. parse_result 'a -> ('a -> parse_context -> parse_result 'b) -> parse_result 'b
let pr_bind x f =
  match x with
  | PR_success v pc -> f v pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_return : forall 'a. 'a -> (parse_context -> parse_result 'a)
let pr_return x pc = PR_success x pc

val pr_map : forall 'a 'b. ('a -> 'b) -> parse_result 'a -> parse_result 'b
let pr_map f x =
  match x with
  | PR_success v pc -> PR_success (f v) pc
  | PR_fail err pc  -> PR_fail err pc
  end

val pr_map2 : forall 'a 'b. ('a -> 'b) -> (parse_context -> parse_result 'a) -> (parse_context -> parse_result 'b)
let pr_map2 f p = fun pc -> pr_map f (p pc)

val pr_post_map1 : forall 'a 'b. (parse_result 'a) -> ('a -> 'b) -> (parse_result 'b)
let pr_post_map1 x f = pr_map f x

val pr_post_map : forall 'a 'b 'c. ('c -> parse_result 'a) -> ('a -> 'b) -> ('c -> parse_result 'b)
let pr_post_map g f = fun x ->  pr_map f (g x)


val pr_with_pos : forall 'a. (parse_context -> parse_result 'a) -> (parse_context -> parse_result (natural * 'a))
let pr_with_pos p = fun pc -> pr_map (fun x -> (pc.pc_offset,x)) (p pc)


val parse_pair : forall 'a 'b. (parse_context -> parse_result 'a) -> (parse_context -> parse_result 'b) -> (parse_context -> parse_result ('a * 'b))
let parse_pair p1 p2 = 
  fun pc -> 
    let _ = parse_debug "pair " in 
    pr_bind (p1 pc) (fun x pc' -> match p2 pc' with 
    | PR_success y pc'' -> PR_success (x,y) pc''
    | PR_fail s pc'' -> PR_fail s pc''
    end)


open import List
val parse_list' : forall 'a. (parse_context -> parse_result (maybe 'a)) -> (list 'a -> parse_context -> parse_result (list 'a))
let rec parse_list' p1 =
  fun acc pc ->   let _ = parse_debug "list' " in pr_bind (p1 pc) (fun mx pc' -> 
    match mx with
    | Nothing -> PR_success acc pc'
    | Just x -> parse_list' p1 (x :: acc) pc'
    end)

val parse_list : forall 'a. (parse_context -> parse_result (maybe 'a)) -> (parse_context -> parse_result (list 'a))
let parse_list p1 = 
  pr_post_map 
    (parse_list' p1 [])
    (List.reverse) 


val parse_parser_list : forall 'a. (list (parse_context -> parse_result 'a)) -> (parse_context -> parse_result (list 'a))
let rec parse_parser_list ps = 
  match ps with
  | [] -> pr_return []
  | p::ps' -> 
      (fun pc -> pr_bind (p pc) (fun x pc' -> 
        match parse_parser_list ps' pc' with
        | PR_success xs pc'' -> PR_success (x::xs) pc''
        | PR_fail s pc'' -> PR_fail s pc''
        end))
  end


let rec mytake' (n:natural) acc xs = 
  match (n,xs) with
  | (0, _) -> Just (List.reverse acc, xs)
  | (_, []) -> Nothing
  | (_, x::xs') -> mytake' (n-1) (x::acc) xs'
  end

val mytake : forall 'a.  natural -> (list 'a) -> maybe (list 'a * list 'a)
let mytake n xs = mytake' n [] xs

let parse_n_bytes (n:natural) (pc:parse_context) : parse_result (list byte) =
  match mytake n pc.pc_bytes with
  | Nothing -> PR_fail "parse_n_bytes" pc
  | Just (xs,bs) -> PR_success xs (<|pc_bytes=bs; pc_offset= pc.pc_offset + naturalFromNat (List.length xs) |> )
  end

let rec mytakestring' acc xs = 
  match xs with
  | [] -> Nothing
  | x::xs' -> if natural_of_byte x = 0 then Just (List.reverse acc, xs') else mytakestring' (x::acc) xs'
  end

let parse_string (pc:parse_context) : parse_result (list byte) =
  match mytakestring' [] pc.pc_bytes with
  | Nothing -> PR_fail "parse_string" pc
  | Just (xs,bs) -> PR_success xs (<|pc_bytes=bs; pc_offset = pc.pc_offset + naturalFromNat (List.length xs) + naturalFromNat 1 |> )
  end


let parse_uint8 (pc:parse_context) : parse_result natural = 
  let _ = parse_debug "uint8 " in
  match pc.pc_bytes with
  | b0::bytes' -> 
      let v = natural_of_byte b0 in
      PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |>)
  | _ -> PR_fail "parse_uint32 not given enough bytes" pc
  end

let parse_uint16 (pc:parse_context) : parse_result natural = 
  let _ = parse_debug "uint16 " in
  match pc.pc_bytes with
  | b0::b1::bytes' -> 
      let v = natural_of_byte b0 + 256*natural_of_byte b1 in
      PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 2 |>)
  | _ -> PR_fail "parse_uint32 not given enough bytes" pc
  end

let parse_uint32 (pc:parse_context) : parse_result natural = 
  let _ = parse_debug "uint32 " in
  match pc.pc_bytes with
  | b0::b1::b2::b3::bytes' -> 
      let v = natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3 in
      PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 4 |>)
  | _ -> PR_fail "parse_uint32 not given enough bytes" pc
  end

let parse_uint64 (pc:parse_context) : parse_result natural = 
  let _ = parse_debug "uint64 " in
  match pc.pc_bytes with
  | b0::b1::b2::b3::b4::b5::b6::b7::bytes' -> 
      let v = natural_of_byte b0 + 256*natural_of_byte b1 + 256*256*natural_of_byte b2 + 256*256*256*natural_of_byte b3 
          + (256*256*256*256*(natural_of_byte b4 + 256*natural_of_byte b5 + 256*256*natural_of_byte b6 + 256*256*256*natural_of_byte b7))
      in
      PR_success v (<| pc_bytes = bytes'; pc_offset = pc.pc_offset + 8 |>)
  | _ -> PR_fail "parse_uint64 not given enough bytes" pc
  end

let rec parse_ULEB128' (acc: natural) (shift_factor: natural) (pc:parse_context) : parse_result natural = 
  let _ = parse_debug "ULEB128' " in
  match pc.pc_bytes with
  | b::bytes' -> 
      let n = natural_of_byte b in
      let acc' = (natural_land n 127) * shift_factor + acc in
      let finished = ((natural_land n 128) = 0) in
      let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
      if finished then 
        PR_success acc' pc'
      else
        parse_ULEB128' acc' (shift_factor * 128) pc'
  | _ ->
      PR_fail "parse_ULEB128' not given enough bytes" pc
  end    

let parse_ULEB128 (pc:parse_context) : parse_result natural = 
  parse_ULEB128' 0 1 pc


let rec parse_SLEB128' (acc: natural) (shift_factor: natural) (pc:parse_context) : parse_result (bool * natural * natural) = 
  let _ = parse_debug "SLEB128' " in
  match pc.pc_bytes with
  | b::bytes' -> 
      let n = natural_of_byte b in
      let acc' = (natural_land n 127) * shift_factor + acc in
      let shift_factor' = shift_factor * 128 in
      let finished = ((natural_land n 128) = 0) in
      let positive = ((natural_land n 64) = 0) in
      let pc' = <| pc_bytes = bytes'; pc_offset = pc.pc_offset + 1 |> in
      if finished then 
        PR_success (positive, shift_factor', acc') pc'
      else
        parse_SLEB128' acc' shift_factor' pc'
  | _ ->
      PR_fail "parse_SLEB128' not given enough bytes" pc
  end    

let parse_SLEB128 (pc:parse_context) : parse_result integer = 
  pr_bind (parse_SLEB128' 0 1 pc) (fun (positive, shift_factor, acc) pc' ->
    let v = if positive then integerFromNatural acc else 0 - (integerFromNatural shift_factor - integerFromNatural acc) in
    PR_success v pc')
    
let parse_nonzero_ULEB128_pair : parse_context -> parse_result (maybe (natural*natural)) =
  let _ = parse_debug "nonzero_ULEB128_pair " in
  pr_post_map 
    (parse_pair parse_ULEB128 parse_ULEB128)
    (fun (n1,n2) -> if n1=0 && n2=0 then Nothing else Just (n1,n2))

let parse_zero_terminated_ULEB128_pair_list : parse_context -> parse_result (list (natural*natural)) = 
  let _ = parse_debug "zero_terminated_ULEB128_pair_list " in
  parse_list parse_nonzero_ULEB128_pair 



(** abbreviations table *)

(* quick hacky workaround: this is in String.lem, in src_lem_library, but the linker doesn't find it *)
val myconcat : string -> list string -> string
let rec myconcat sep ss =
  match ss with
    | [] -> ""
    | s :: ss' ->
      match ss' with
      | [] -> s
      | _ -> s ^ sep ^ myconcat sep ss'
      end
  end

let pp_abbreviation_declaration (x:abbreviation_declaration) =
  "   " 
  ^ show x.ad_abbreviation_code ^ "      " 
  ^ pp_tag_encoding x.ad_tag ^ "    " 
  ^ (if x.ad_has_children then "[has children]" else "[no children]")
  ^ "\n"
(*  ^ " "^show (List.length x.ad_attribute_specifications) ^ " attributes\n"*)
  ^ myconcat "" 
      (List.map 
         (fun (n1,n2) ->
           "    " ^ pp_attribute_encoding n1 ^ "     " ^ pp_attribute_form_encoding n2 ^ "\n") 
         x.ad_attribute_specifications)

let pp_abbreviations_table (x:abbreviations_table) = 
  myconcat "" (List.map pp_abbreviation_declaration x)

let parse_abbreviation_declaration (pc: parse_context) : parse_result (maybe abbreviation_declaration) =
  pr_bind (parse_ULEB128 pc) (fun n1 pc' -> 
    if n1 = 0 then 
      PR_success Nothing pc'
    else 
      pr_bind (parse_ULEB128 pc') (fun n2 pc'' -> 
        pr_bind (parse_uint8 pc'') (fun c pc''' -> 
          pr_post_map1 
            (parse_zero_terminated_ULEB128_pair_list pc''')
            (fun l ->
              Just ( let ad = 
                <|
                ad_abbreviation_code = n1;
                ad_tag = n2;
                ad_has_children = (c<>0);
                ad_attribute_specifications = l;
              |> in let _ = parse_debug2 (pp_abbreviation_declaration ad) in ad)
            ))))

let parse_abbreviations_table =
  parse_list parse_abbreviation_declaration


(** debug_str entry *)

val mydrop : forall 'a. natural -> list 'a -> maybe (list 'a)
let rec mydrop n xs = 
  if n=0 then Just xs 
  else 
    match xs with
    | x::xs' -> mydrop (n-1) xs' 
    | [] -> Nothing
    end

let rec null_terminated_list (acc: list byte) (xs: list byte) : list byte = 
  match xs with
  | [] -> List.reverse acc (* TODO: flag failure? *)
  | x::xs' -> if natural_of_byte x = 0 then List.reverse acc else null_terminated_list (x::acc) xs'
  end

let pp_debug_str_entry (str: list byte) (n: natural) =
  match mydrop n str with
  | Nothing -> "strp beyond .debug_str extent"
  | Just xs -> string_of_bytes (null_terminated_list [] xs)
  end

(** attribute values *)

val pp_attribute_value : list byte -> attribute_value -> string
let pp_attribute_value str v = 
  match v with
  | AV_addr x -> "AV_addr " ^ pphex x
  | AV_block n bs -> "AV_block " ^ show n ^ " " ^ ppbytes bs
  | AV_constantN n bs -> "AV_constantN " ^ show n ^ " " ^ ppbytes bs
  | AV_constant_SLEB128 i -> "AV_constant_SLEB128 " ^ show i
  | AV_constant_ULEB128 n -> "AV_constant_ULEB128 " ^ show n
  | AV_exprloc n bs -> "AV_exprloc natural " ^ show n ^ " " ^ ppbytes bs
  | AV_flag b -> "AV_flag " ^ show b
  | AV_ref n -> "AV_ref " ^ pphex n
  | AV_ref_addr n -> "AV_ref_addr " ^ pphex n 
  | AV_ref_sig8 n -> "AV_ref_sig8 " ^ pphex n 
  | AV_sec_offset n -> "AV_sec_offset " ^ pphex  n
  | AV_string bs -> string_of_bytes bs
  | AV_strp n -> "AV_sec_offset " ^ pphex n ^ " " ^ pp_debug_str_entry str n
  end


val parser_of_attribute_form_non_indirect : compilation_unit_header -> natural -> (parse_context -> parse_result attribute_value)
let parser_of_attribute_form_non_indirect cuh n = 
(* address*)
  if n = attribute_form_encode "DW_FORM_addr"         then 
    match cuh.cuh_address_size with
    | 4 -> pr_map2 (fun n -> AV_addr n) parse_uint32
    | 8 -> pr_map2 (fun n -> AV_addr n) parse_uint64
    | _ -> Assert_extra.failwith "cuh_address_size not 4 or 8"
  end
(* block *)
  else if n = attribute_form_encode "DW_FORM_block1"       then 
    (fun pc -> pr_bind (parse_uint8 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block2"       then 
    (fun pc -> pr_bind (parse_uint16 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block4"       then 
    (fun pc -> pr_bind (parse_uint32 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
  else if n = attribute_form_encode "DW_FORM_block"        then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_block n bs) (parse_n_bytes n pc')))
(* constant *)
  else if n = attribute_form_encode "DW_FORM_data1"        then 
    pr_map2 (fun bs -> AV_block 1 bs) (parse_n_bytes 1)
  else if n = attribute_form_encode "DW_FORM_data2"        then 
    pr_map2 (fun bs -> AV_block 2 bs) (parse_n_bytes 2)
  else if n = attribute_form_encode "DW_FORM_data4"        then 
    pr_map2 (fun bs -> AV_block 4 bs) (parse_n_bytes 4)
  else if n = attribute_form_encode "DW_FORM_data8"        then 
    pr_map2 (fun bs -> AV_block 8 bs) (parse_n_bytes 8)
  else if n = attribute_form_encode "DW_FORM_sdata"        then 
    pr_map2 (fun i -> AV_constant_SLEB128 i) parse_SLEB128
  else if n = attribute_form_encode "DW_FORM_udata"        then 
    pr_map2 (fun n -> AV_constant_ULEB128 n) parse_ULEB128
(* exprloc *)
  else if n = attribute_form_encode "DW_FORM_exprloc"      then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n pc' -> 
      pr_map (fun bs -> AV_exprloc n bs) (parse_n_bytes n pc')))
(* flag *)
  else if n = attribute_form_encode "DW_FORM_flag"         then 
    pr_map2 (fun n -> AV_flag (n<>0)) parse_uint8
  else if n = attribute_form_encode "DW_FORM_flag_present" then 
    pr_map2 (fun () -> AV_flag true) (pr_return ())
(* lineptr, loclistptr, macptr, rangelistptr *)
  else if n = attribute_form_encode "DW_FORM_sec_offset"   then 
    match cuh.cuh_dwarf_format with
    | Dwarf32 -> pr_map2 (fun n -> AV_sec_offset n) parse_uint32
    | Dwarf64 -> pr_map2 (fun n -> AV_sec_offset n) parse_uint64
    end
(* reference - first type *)
  else if n = attribute_form_encode "DW_FORM_ref1"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint8
  else if n = attribute_form_encode "DW_FORM_ref2"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint16
  else if n = attribute_form_encode "DW_FORM_ref4"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint32
  else if n = attribute_form_encode "DW_FORM_ref8"         then 
    pr_map2 (fun n -> AV_ref n) parse_uint64
  else if n = attribute_form_encode "DW_FORM_ref_udata"    then 
    pr_map2 (fun n -> AV_ref n) parse_ULEB128
(* reference - second type *)
  else if n = attribute_form_encode "DW_FORM_ref_addr"     then 
    match cuh.cuh_dwarf_format with
    | Dwarf32 -> pr_map2 (fun n -> AV_ref_addr n) parse_uint32
    | Dwarf64 -> pr_map2 (fun n -> AV_ref_addr n) parse_uint64
    end
(* reference - third type *)
  else if n = attribute_form_encode "DW_FORM_ref_sig8"     then 
    pr_map2 (fun n -> AV_ref_sig8 n) parse_uint64
(* string *)
  else if n = attribute_form_encode "DW_FORM_string"       then 
    pr_map2 (fun bs -> AV_string bs) parse_string
  else if n = attribute_form_encode "DW_FORM_strp"         then 
    match cuh.cuh_dwarf_format with
    | Dwarf32 -> pr_map2 (fun n -> AV_strp n) parse_uint32
    | Dwarf64 -> pr_map2 (fun n -> AV_strp n) parse_uint64
    end
(* indirect (cycle detection) *)
  else if n = attribute_form_encode "DW_FORM_indirect"     then 
    Assert_extra.failwith "DW_FORM_INDIRECT cycle"
(* unknown *)
  else
    Assert_extra.failwith "parser_of_attribute_form_non_indirect: unknown attribute form"


let parser_of_attribute_form cuh n = 
  if n = attribute_form_encode "DW_FORM_indirect"     then 
    (fun pc -> pr_bind (parse_ULEB128 pc) (fun n ->
      parser_of_attribute_form_non_indirect cuh n) )
  else 
    parser_of_attribute_form_non_indirect cuh n 





(** compilation unit header *)

let pp_cuh_header (x:compilation_unit_header) : string = 
  "Contents of the .debug_info section:\n\n"
  ^ "  Compilation Unit @ offset " ^ pphex x.cuh_offset ^ ":\n"
  ^ "   Length:        " ^ pphex x.cuh_unit_length ^ " " ^ match x.cuh_dwarf_format with Dwarf32 -> "(32-bit)" | Dwarf64 -> "(64-bit)" end ^ "\n"
  ^ "   Version:       " ^ show x.cuh_version ^ "\n"
  ^ "   Abbrev Offset: " ^ show x.cuh_debug_abbrev_offset ^ "\n"
  ^ "   Pointer Size:  " ^ show x.cuh_address_size ^ "\n"

let parse_cuh_unit_length (pc: parse_context) : parse_result (dwarf_format * natural) =
  pr_bind (parse_uint32 pc) (fun x pc' ->
    if x < natural_of_hex "0xfffffff0" then PR_success (Dwarf32,x) pc'
    else if x <> natural_of_hex "0xffffffff" then PR_fail "bad unit_length" pc
    else 
      pr_bind (parse_uint64 pc') (fun x' pc'' -> 
        PR_success (Dwarf64, x') pc'))

let parse_cuh_version (pc: parse_context) : parse_result natural = 
  pr_bind (parse_uint16 pc) (fun x pc' ->
    (*if x=4 then *) PR_success x pc')
    (*else PR_fail "bad dwarf version, not equal to 4" pc)*)

let parse_cuh_debug_abbrev_offset (df: dwarf_format) (pc: parse_context) : parse_result natural =
  (* TODO: in sanity check, assert this is within the .debug_abbrev section *)
  match df with
  | Dwarf32 -> parse_uint32 pc
  | Dwarf64 -> parse_uint64 pc
  end

let parse_cuh_address_size (pc: parse_context) : parse_result natural = 
  parse_uint8 pc
      
let parse_cuh_header (pc: parse_context) : parse_result compilation_unit_header = 
  pr_bind (parse_cuh_unit_length pc) (fun (df,ul) pc' ->  
    pr_bind (parse_cuh_version pc') (fun v pc'' ->
      pr_bind (parse_cuh_debug_abbrev_offset df pc'') (fun dao pc''' -> 
        pr_bind (parse_cuh_address_size pc''') (fun as' pc'''' ->
          PR_success ( 
          <|
          cuh_offset = pc.pc_offset;
          cuh_dwarf_format = df;
          cuh_unit_length = ul;
          cuh_version = v;
          cuh_debug_abbrev_offset = dao;
          cuh_address_size = as';
        |>
         ) pc''''))))


(** debugging information entries *)

(*
 <2><51>: Abbrev Number: 3 (DW_TAG_variable)
    <52>   DW_AT_name        : x	
    <54>   DW_AT_decl_file   : 1	
    <55>   DW_AT_decl_line   : 2	
    <56>   DW_AT_type        : <0x6a>	
    <5a>   DW_AT_location    : 2 byte block: 91 6c 	(DW_OP_fbreg: -20)
*)

let pp_pos pos = "<" ^ pphex pos ^">"

let pp_die_attribute (str : list byte) (((at: natural), (af: natural)), ((pos: natural),(av:attribute_value))) : string = 
  pp_pos pos  ^ "   " 
  ^ pp_attribute_encoding at ^ "     : "
  ^ "(" ^ pp_attribute_form_encoding af ^ ") "
  ^ pp_attribute_value str av
  ^ "\n"

val pp_die : list byte -> natural -> die -> string
let rec pp_die str level die = 
  "<" ^ show level ^ ">" 
  ^ pp_pos die.die_pos
  ^ ": Abbrev Number: " ^ show die.die_abbreviation_code 
  ^ " (" ^ pp_tag_encoding die.die_abbreviation_declaration.ad_tag ^")\n"
  ^
    let ats = List.zip 
        die.die_abbreviation_declaration.ad_attribute_specifications 
        die.die_attribute_values in
    (myconcat "" (List.map (pp_die_attribute str) ats))
    ^
      (myconcat "" (List.map (pp_die str (level +1)) die.die_children))


val parse_die : list byte -> compilation_unit_header -> (natural->abbreviation_declaration) -> (parse_context -> parse_result (maybe die))
let rec parse_die str cuh find_abbreviation_declaration pc = 
  let _ = parse_debug3 ("parse_die called at " ^ pp_parse_context pc ^ "\n") in
  pr_bind (parse_ULEB128 pc) (fun abbreviation_code pc' -> 
    if abbreviation_code = 0 then PR_success Nothing pc' 
    else
      let _ = parse_debug3 ("parse_die abbreviation code "^pphex abbreviation_code ^"\n") in
      let ad = find_abbreviation_declaration abbreviation_code in
      let attribute_value_parsers = List.map (fun (at,af) -> pr_with_pos (parser_of_attribute_form cuh af)) ad.ad_attribute_specifications in
      pr_bind (parse_parser_list attribute_value_parsers pc') (fun avs pc'' ->

        let die_header = 
          <| 
          die_pos = pc.pc_offset;
          die_abbreviation_code = abbreviation_code;
          die_abbreviation_declaration = ad;
          die_attribute_values = avs;
          die_children = [];
        |> in let _ = parse_debug3 ("die_header " ^ pp_die str 999 die_header) in 

        pr_bind 
          (if ad.ad_has_children then parse_list (parse_die str cuh find_abbreviation_declaration) pc'' else pr_return [] pc'')
          (fun dies pc''' -> 
            PR_success (Just ( let die = 
                        <| 
                        die_pos = pc.pc_offset;
                        die_abbreviation_code = abbreviation_code;
                        die_abbreviation_declaration = ad;
                        die_attribute_values = avs;
                        die_children = dies;
                      |> in (* let _ = parse_debug3 ("die entire " ^ pp_die str 999 die) in *)die)) pc''')))


(** compilation unit *)
                        
val myfindNonPure : forall 'a. ('a -> bool) -> list 'a -> 'a 
let myfindNonPure P l = match (List.find P l) with 
  | Just e      -> e
  | Nothing     -> Assert_extra.failwith "List_extra.findNonPure"
end



let parse_compilation_unit 
    (debug_info_section_body: list byte) 
    (debug_abbrev_section_body: list byte) 
    (debug_str_section_body: list byte) 
    : compilation_unit =

  let pc_abbrev = <|pc_bytes = debug_abbrev_section_body; pc_offset = 0  |> in
  let pc_info = <|pc_bytes = debug_info_section_body; pc_offset = 0  |> in
  
  let abbreviations_table = 
    match parse_abbreviations_table pc_abbrev with
    | PR_fail s pc_abbrev' -> Assert_extra.failwith ("parse_abbrevations_table fail: " ^ pp_parse_fail s pc_abbrev')
    | PR_success at pc_abbrev' -> at
    end in

  let _ = parse_debug3 (pp_abbreviations_table abbreviations_table) in

  let (cuh, pc_info') = 
    match parse_cuh_header pc_info with
    | PR_fail s pc_info' -> Assert_extra.failwith ("parse_cuh_header fail: " ^ pp_parse_fail s pc_info')
    | PR_success cuh pc_info' -> (cuh,pc_info')
    end in

  let _ = parse_debug3 (pp_cuh_header cuh) in 

  let find_abbreviation_declaration (ac:natural) : abbreviation_declaration = 
    myfindNonPure (fun ad -> ad.ad_abbreviation_code = ac) abbreviations_table  in

  let die = 
    match parse_die debug_str_section_body cuh find_abbreviation_declaration pc_info' with
    | PR_fail s pc_info'' -> Assert_extra.failwith ("parse_die fail: " ^ pp_parse_fail s pc_info'')
    | PR_success (Nothing) pc_info'' -> Assert_extra.failwith ("parse_die returned Nothing: " ^ pp_parse_context pc_info'')
    | PR_success (Just die) pc_info'' -> die
    end in

    <| 
    cu_header = cuh;
    cu_die = die;
    cu_abbreviations_table = abbreviations_table;
    cu_str = debug_str_section_body;
  |>
  

let pp_compilation_unit cu = 
   pp_abbreviations_table cu.cu_abbreviations_table
   ^ pp_cuh_header cu.cu_header
   ^ pp_die cu.cu_str 0 cu.cu_die


(** top level *)


let just_one s xs = 
  match xs with
  | [] -> Assert_extra.failwith ("no " ^ s)
  | x1::x2::_ -> Assert_extra.failwith ("more than one " ^ s)
  | [x] -> x
  end

val harness_string_of_elf64_debug_info_section : elf64_file -> byte_sequence -> (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf64_debug_info_section f1 bs0 os proc usr hdr sht stbl =

  let extract_section_body section_name = 
    let sections = 
      List.filter 
        (fun x -> 
          x.Elf_interpreted_section.elf64_section_name_as_string = section_name
        ) f1.elf64_file_interpreted_sections in
    let section = just_one (section_name ^ " sections")  sections  in
    let section_body =  match section.Elf_interpreted_section.elf64_section_body with Sequence bs -> bs end in
    let _ = parse_debug3 (section_name ^ ": \n" ^ Elf_interpreted_section.string_of_elf64_interpreted_section section ^ "\n"
                          ^ "  body = " ^ ppbytes2 0 section_body ^ "\n") in
    section_body in



  let debug_abbrev_section_body = extract_section_body ".debug_abbrev" in
  let debug_info_section_body = extract_section_body ".debug_info" in
  let debug_str_section_body = extract_section_body ".debug_str" in

  let cu = parse_compilation_unit debug_info_section_body debug_abbrev_section_body debug_str_section_body in
  pp_compilation_unit cu
                                                                                                                       

 


val harness_string_of_elf32_debug_info_section : elf32_file -> byte_sequence -> (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table -> string
let {ocaml} harness_string_of_elf32_debug_info_section f1 bs0 os proc usr hdr sht stbl =
"NOT IMPLEMENTED"
