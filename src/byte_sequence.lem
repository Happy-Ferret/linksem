open import Basic_classes
open import Bool
open import List
open import Num
open import String
open import Assert_extra

open import Error
open import Missing_pervasives
open import Show

type byte_sequence =
  Sequence of list byte

val byte_list_of_byte_sequence : byte_sequence -> list byte
let byte_list_of_byte_sequence bs0 =
  match bs0 with
    | Sequence xs -> xs
  end

let compare_byte_sequence s1 s2 = compare (byte_list_of_byte_sequence s1) (byte_list_of_byte_sequence s2)

instance (Ord byte_sequence) 
    let compare = compare_byte_sequence
    let (<) = fun f1 -> (fun f2 -> (compare_byte_sequence f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> let result = compare_byte_sequence f1 f2 in result = LT || result = EQ)
    let (>) = fun f1 -> (fun f2 -> (compare_byte_sequence f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> let result = compare_byte_sequence f1 f2 in result = GT || result = EQ)
end

val acquire_byte_list : string -> error (list byte)
declare ocaml target_rep function acquire_byte_list = `Byte_sequence_wrapper.acquire_char_list`

val acquire : string -> error byte_sequence
let {ocaml} acquire fname =
  acquire_byte_list fname >>= fun bs ->
  return (Sequence bs)

val serialise_byte_list : string -> list byte -> error unit
declare ocaml target_rep function serialise_byte_list = `Byte_sequence_wrapper.serialise_char_list`

val serialise : string -> byte_sequence -> error unit
let {ocaml} serialise fname ss =
  match ss with
    | Sequence ts -> serialise_byte_list fname ts
  end

val empty : byte_sequence
let empty = Sequence []

val read_char : byte_sequence -> error (byte * byte_sequence)
let read_char (Sequence ts) =
  match ts with
    | []    -> fail "read_char: sequence is empty"
    | x::xs -> return (x, Sequence xs)
  end

val repeat : natural -> byte -> list byte
let rec repeat count c =
  match count with
    | 0 -> []
    | m -> c::repeat (count - 1) c
  end

val create : natural -> byte -> byte_sequence
let create count c =
  Sequence (repeat count c)

val zeros : natural -> byte_sequence
let zeros m =
  create m Missing_pervasives.null_byte

val length : byte_sequence -> natural
let length (Sequence ts) =
  naturalFromNat (List.length ts)
;;

val concat : list byte_sequence -> byte_sequence
let rec concat ts =
  match ts with
    | []                 -> Sequence []
    | ((Sequence x)::xs) ->
      match concat xs with
        | Sequence tail -> Sequence (x ++ tail)
      end
  end

declare {isabelle} rename function concat = concat_byte_sequence

val zero_pad_to_length : natural -> byte_sequence -> byte_sequence
let zero_pad_to_length len bs = 
  let curlen = length bs in 
    if curlen >= len then
      bs
    else
      concat [bs ; (zeros (len - curlen))]

val from_byte_lists : list (list byte) -> byte_sequence
let from_byte_lists ts =
  Sequence (List.concat ts)

val string_of_char_list : list char -> string

declare ocaml target_rep function string_of_char_list = `Byte_sequence_wrapper.string_of_char_list`

val char_list_of_byte_list : list byte -> list char

declare ocaml    target_rep function char_list_of_byte_list = ``
declare isabelle target_rep function char_list_of_byte_list xs = `List.map` `undefined` xs

val string_of_byte_sequence : byte_sequence -> string
let string_of_byte_sequence (Sequence ts) =
  let cs = char_list_of_byte_list ts in
    String.toString cs

val equal : byte_sequence -> byte_sequence -> bool
let rec equal left right =
  match (left, right) with
    | (Sequence [], Sequence []) -> true
    | (Sequence (x::xs), Sequence (y::ys)) ->
        x = y && equal (Sequence xs) (Sequence ys)
    | (_, _) -> false
  end

let inline {isabelle} equal = unsafe_structural_equality

val dropbytes : natural -> byte_sequence -> error byte_sequence
let rec dropbytes count (Sequence ts) =
  if count = Missing_pervasives.naturalZero then
    return (Sequence ts)
  else
    match ts with
      | []    -> fail "dropbytes: cannot drop more bytes than are contained in sequence"
      | x::xs -> dropbytes (count - 1) (Sequence xs)
    end

val takebytes_r_with_length: nat -> natural -> byte_sequence -> error byte_sequence
let rec takebytes_r_with_length count ts_length (Sequence ts) = 
  if ts_length >= (naturalFromNat count) then 
    return (Sequence (list_take_with_accum count [] ts))
  else
    fail "takebytes: cannot take more bytes than are contained in sequence"

val takebytes : natural -> byte_sequence -> error byte_sequence
let takebytes count (Sequence ts) =
  (* let _ = Missing_pervasives.prints ("Trying to take " ^ (show count) ^ " bytes from sequence of " ^ (show (List.length ts)) ^ "\n") in *)
  let result = takebytes_r_with_length (Missing_pervasives.unsafe_nat_of_natural count) (Missing_pervasives.length ts) (Sequence ts) in 
  (*let _ = Missing_pervasives.prints ("Succeeded\n") in *)
    result

val takebytes_with_length : natural -> natural -> byte_sequence -> error byte_sequence
let takebytes_with_length count ts_length (Sequence ts) =
  (* let _ = Missing_pervasives.prints ("Trying to take " ^ (show count) ^ " bytes from sequence of " ^ (show (List.length ts)) ^ "\n") in *)
  let result = takebytes_r_with_length (Missing_pervasives.unsafe_nat_of_natural count) ts_length (Sequence ts) in 
  (*let _ = Missing_pervasives.prints ("Succeeded\n") in *)
    result

val read_2_bytes_le : byte_sequence -> error ((byte * byte) * byte_sequence)
let read_2_bytes_le bs0 =
  read_char bs0 >>= fun (b0, bs1) ->
  read_char bs1 >>= fun (b1, bs2) ->
  return ((b1, b0), bs2)

val read_2_bytes_be : byte_sequence -> error ((byte * byte) * byte_sequence)
let read_2_bytes_be bs0 =
  read_char bs0 >>= fun (b0, bs1) ->
  read_char bs1 >>= fun (b1, bs2) ->
  return ((b0, b1), bs2)

val read_4_bytes_le : byte_sequence -> error ((byte * byte * byte * byte) * byte_sequence)
let read_4_bytes_le bs0 =
  read_char bs0 >>= fun (b0, bs1) ->
  read_char bs1 >>= fun (b1, bs2) ->
  read_char bs2 >>= fun (b2, bs3) ->
  read_char bs3 >>= fun (b3, bs4) ->
  return ((b3, b2, b1, b0), bs4)

val read_4_bytes_be : byte_sequence -> error ((byte * byte * byte * byte) * byte_sequence)
let read_4_bytes_be bs0 =
  read_char bs0 >>= fun (b0, bs1) ->
  read_char bs1 >>= fun (b1, bs2) ->
  read_char bs2 >>= fun (b2, bs3) ->
  read_char bs3 >>= fun (b3, bs4) ->
  return ((b0, b1, b2, b3), bs4)

val read_8_bytes_le : byte_sequence -> error ((byte * byte * byte * byte * byte * byte * byte * byte) * byte_sequence)
let read_8_bytes_le bs0 =
  read_char bs0 >>= fun (b0, bs1) ->
  read_char bs1 >>= fun (b1, bs2) ->
  read_char bs2 >>= fun (b2, bs3) ->
  read_char bs3 >>= fun (b3, bs4) ->
  read_char bs4 >>= fun (b4, bs5) ->
  read_char bs5 >>= fun (b5, bs6) ->
  read_char bs6 >>= fun (b6, bs7) ->
  read_char bs7 >>= fun (b7, bs8) ->
  return ((b7, b6, b5, b4, b3, b2, b1, b0), bs8)

val read_8_bytes_be : byte_sequence -> error ((byte * byte * byte * byte * byte * byte * byte * byte) * byte_sequence)
let read_8_bytes_be bs0 =
  read_char bs0 >>= fun (b0, bs1) ->
  read_char bs1 >>= fun (b1, bs2) ->
  read_char bs2 >>= fun (b2, bs3) ->
  read_char bs3 >>= fun (b3, bs4) ->
  read_char bs4 >>= fun (b4, bs5) ->
  read_char bs5 >>= fun (b5, bs6) ->
  read_char bs6 >>= fun (b6, bs7) ->
  read_char bs7 >>= fun (b7, bs8) ->
  return ((b0, b1, b2, b3, b4, b5, b6, b7), bs8)

val partition : natural -> byte_sequence -> error (byte_sequence * byte_sequence)
let partition idx bs0 =
  takebytes idx bs0 >>= fun l ->
  dropbytes idx bs0 >>= fun r ->
  return (l, r)

val partition_with_length : natural -> natural -> byte_sequence -> error (byte_sequence * byte_sequence)
let partition_with_length idx bs0_length bs0 =
  takebytes_with_length idx bs0_length bs0 >>= fun l ->
  dropbytes idx bs0 >>= fun r ->
  return (l, r)

val offset_and_cut : natural -> natural -> byte_sequence -> error byte_sequence
let offset_and_cut off cut bs0 =
  dropbytes off bs0 >>= fun bs1 ->
  takebytes cut bs1 >>= fun res ->
  return res

instance (Show byte_sequence)
  let show = string_of_byte_sequence
end

instance (Eq byte_sequence)
  let (=) = equal
  let (<>) l r = not (equal l r)
end
