open import Num
open import String

open import Endianness

open import Byte_sequence
open import Error
open import Show

(** unsigned char type and bindings *)

type unsigned_char

declare ocaml target_rep type unsigned_char = `Uint32.t`

(** [string_of_unsigned_char uc] provides a string representation of unsigned
  * char [uc] (in base 10).
  *)
val string_of_unsigned_char : unsigned_char -> string

(** [natural_of_unsigned_char uc] converts an unsigned char [uc] into a natural.
  *)
val natural_of_unsigned_char : unsigned_char -> natural

(** [unsigned_char_of_int32 i] converts an [int32] into an unsigned char, wrapping
  * around if the size of the nat exceeds the storage capacity of an unsigned
  * char.
  *)
val unsigned_char_of_int32 : int32 -> unsigned_char

(** [unsigned_char_land uc0 uc1] bitwise ANDs two unsigned chars, [uc0] and [uc1]
  * together.
  *)
val unsigned_char_land   : unsigned_char -> unsigned_char -> unsigned_char

(** [unsigned_char_lshift uc n] performs a left bitshift of [n] places on unsigned
  * char [uc].
  *)
val unsigned_char_lshift : unsigned_char -> nat -> unsigned_char

(** [unsigned_char_rshift uc n] performs a right bitshift of [n] places on unsigned
  * char [uc].
  *)
val unsigned_char_rshift : unsigned_char -> nat -> unsigned_char

(** [unsigned_char_plus uc0 uc1] adds two unsigned chars, [uc0] and [uc1].
  *)
val unsigned_char_plus   : unsigned_char -> unsigned_char -> unsigned_char

(** [read_unsigned_char end bs0] reads an unsigned char from byte_sequence [bs0]
  * assuming endianness [end].  Returns the unsigned char and the remainder of
  * the byte_sequence.  Fails if an unsigned char cannot be read from the byte_sequence,
  * e.g. if [bs0] is too small.
  *)
val read_unsigned_char   : endianness -> byte_sequence -> error (unsigned_char * byte_sequence)

declare ocaml target_rep function string_of_unsigned_char = `Uint32.to_string`
declare ocaml target_rep function natural_of_unsigned_char = `Ml_bindings.natural_of_unsigned_char`
declare ocaml target_rep function unsigned_char_of_int32 = `Uint32.of_int32`
declare ocaml target_rep function unsigned_char_land = `Uint32.logand`
declare ocaml target_rep function unsigned_char_lshift = `Uint32.shift_left`
declare ocaml target_rep function unsigned_char_rshift = `Uint32.shift_right`
declare ocaml target_rep function unsigned_char_plus = `Uint32.add`
declare ocaml target_rep function read_unsigned_char = `Ml_bindings.read_unsigned_char`

instance (Show unsigned_char)
	let show = string_of_unsigned_char
end

(** elf32_addr type and bindings *)

type elf32_addr

declare ocaml target_rep type elf32_addr = `Uint32.t`

val string_of_elf32_addr : elf32_addr -> string
val natural_of_elf32_addr : elf32_addr -> natural
val read_elf32_addr : endianness -> byte_sequence -> error (elf32_addr * byte_sequence)

declare ocaml target_rep function string_of_elf32_addr = `Uint32.to_string`
declare ocaml target_rep function read_elf32_addr = `Ml_bindings.read_elf32_addr`
declare ocaml target_rep function natural_of_elf32_addr = `Ml_bindings.natural_of_elf32_addr`

instance (Show elf32_addr)
	let show = string_of_elf32_addr
end

(** elf64_addr type and bindings *)

type elf64_addr

declare ocaml target_rep type elf64_addr = `Uint64.t`

val string_of_elf64_addr : elf64_addr -> string
val natural_of_elf64_addr : elf64_addr -> natural
val read_elf64_addr : endianness -> byte_sequence -> error (elf64_addr * byte_sequence)

declare ocaml target_rep function string_of_elf64_addr = `Uint64.to_string`
declare ocaml target_rep function read_elf64_addr = `Ml_bindings.read_elf64_addr`
declare ocaml target_rep function natural_of_elf64_addr = `Ml_bindings.natural_of_elf64_addr`

instance (Show elf64_addr)
  let show = string_of_elf64_addr
end

(** elf32_half type and bindings *)

type elf32_half

declare ocaml target_rep type elf32_half = `Uint32.t`

val string_of_elf32_half : elf32_half -> string
val read_elf32_half : endianness -> byte_sequence -> error (elf32_half * byte_sequence)
val natural_of_elf32_half : elf32_half -> natural

declare ocaml target_rep function string_of_elf32_half = `Uint32.to_string`
declare ocaml target_rep function read_elf32_half = `Ml_bindings.read_elf32_half`
declare ocaml target_rep function natural_of_elf32_half = `Ml_bindings.natural_of_elf32_half`

instance (Show elf32_half)
	let show = string_of_elf32_half
end

(** elf64_half type and bindings *)

type elf64_half

declare ocaml target_rep type elf64_half = `Uint32.t`

val string_of_elf64_half : elf64_half -> string
val read_elf64_half : endianness -> byte_sequence -> error (elf64_half * byte_sequence)
val natural_of_elf64_half : elf64_half -> natural

declare ocaml target_rep function string_of_elf64_half = `Uint32.to_string`
declare ocaml target_rep function read_elf64_half = `Ml_bindings.read_elf64_half`
declare ocaml target_rep function natural_of_elf64_half = `Ml_bindings.natural_of_elf64_half`

instance (Show elf64_half)
  let show = string_of_elf64_half
end

(** elf32_off type and bindings *)

type elf32_off

declare ocaml target_rep type elf32_off = `Uint32.t`

val string_of_elf32_off : elf32_off -> string
val natural_of_elf32_off : elf32_off -> natural
val read_elf32_off : endianness -> byte_sequence -> error (elf32_off * byte_sequence)

declare ocaml target_rep function string_of_elf32_off = `Uint32.to_string`
declare ocaml target_rep function read_elf32_off = `Ml_bindings.read_elf32_off`
declare ocaml target_rep function natural_of_elf32_off = `Ml_bindings.natural_of_elf32_off`

instance (Show elf32_off)
	let show = string_of_elf32_off
end

(** elf64_off type and bindings *)

type elf64_off

declare ocaml target_rep type elf64_off = `Uint64.t`

val string_of_elf64_off : elf64_off -> string
val natural_of_elf64_off : elf64_off -> natural
val read_elf64_off : endianness -> byte_sequence -> error (elf64_off * byte_sequence)

declare ocaml target_rep function string_of_elf64_off = `Uint64.to_string`
declare ocaml target_rep function read_elf64_off = `Ml_bindings.read_elf64_off`
declare ocaml target_rep function natural_of_elf64_off = `Ml_bindings.natural_of_elf64_off`

instance (Show elf64_off)
  let show = string_of_elf64_off
end

(** elf32_word type and bindings *)

type elf32_word

declare ocaml target_rep type elf32_word = `Uint32.t`

val string_of_elf32_word : elf32_word -> string
val natural_of_elf32_word : elf32_word -> natural
val elf32_word_of_int32 : int32 -> elf32_word
val elf32_word_land : elf32_word -> elf32_word -> elf32_word
val elf32_word_rshift : elf32_word -> nat -> elf32_word
val read_elf32_word : endianness -> byte_sequence -> error (elf32_word * byte_sequence)
val unsigned_char_of_elf32_word : elf32_word -> unsigned_char

declare ocaml target_rep function string_of_elf32_word = `Uint32.to_string`
declare ocaml target_rep function read_elf32_word = `Ml_bindings.read_elf32_word`
declare ocaml target_rep function natural_of_elf32_word = `Ml_bindings.natural_of_elf32_word`
declare ocaml target_rep function elf32_word_of_int32 = `Uint32.of_int32`
declare ocaml target_rep function elf32_word_land = `Uint32.logand`
declare ocaml target_rep function elf32_word_rshift = `Uint32.shift_right`
declare ocaml target_rep function unsigned_char_of_elf32_word = ``

instance (Show elf32_word)
	let show = string_of_elf32_word
end

(** elf64_word type and bindings *)

type elf64_word

declare ocaml target_rep type elf64_word = `Uint32.t`

val string_of_elf64_word : elf64_word -> string
val natural_of_elf64_word : elf64_word -> natural
val elf64_word_of_int32 : int32 -> elf64_word
val elf64_word_land : elf64_word -> elf64_word -> elf64_word
val read_elf64_word : endianness -> byte_sequence -> error (elf64_word * byte_sequence)

declare ocaml target_rep function string_of_elf64_word = `Uint32.to_string`
declare ocaml target_rep function read_elf64_word = `Ml_bindings.read_elf64_word`
declare ocaml target_rep function natural_of_elf64_word = `Ml_bindings.natural_of_elf64_word`
declare ocaml target_rep function elf64_word_of_int32 = `Uint32.of_int32`
declare ocaml target_rep function elf64_word_land = `Uint32.logand`

instance (Show elf64_word)
  let show = string_of_elf64_word
end

(** elf32_sword type and bindings *)

type elf32_sword

declare ocaml target_rep type elf32_sword = `Int32.t`

val string_of_elf32_sword : elf32_sword -> string
val natural_of_elf32_sword : elf32_sword -> natural
val read_elf32_sword : endianness -> byte_sequence -> error (elf32_sword * byte_sequence)

declare ocaml target_rep function string_of_elf32_sword = `Int32.to_string`
declare ocaml target_rep function read_elf32_sword = `Ml_bindings.read_elf32_sword`
declare ocaml target_rep function natural_of_elf32_sword = `Ml_bindings.natural_of_elf32sword`

instance (Show elf32_sword)
	let show = string_of_elf32_sword
end

(** elf64_sword type and bindings *)

type elf64_sword

declare ocaml target_rep type elf64_sword = `Int32.t`

val string_of_elf64_sword : elf64_sword -> string
val natural_of_elf64_sword : elf64_sword -> natural
val read_elf64_sword : endianness -> byte_sequence -> error (elf64_sword * byte_sequence)

declare ocaml target_rep function string_of_elf64_sword = `Int32.to_string`
declare ocaml target_rep function read_elf64_sword = `Ml_bindings.read_elf64_sword`
declare ocaml target_rep function natural_of_elf64_sword = `Ml_bindings.natural_of_elf64_sword`

instance (Show elf64_sword)
  let show = string_of_elf64_sword
end

(** elf64_sword type and bindings *)

type elf64_xword

declare ocaml target_rep type elf64_xword = `Uint64.t`

val string_of_elf64_xword : elf64_xword -> string
val natural_of_elf64_xword : elf64_xword -> natural
val read_elf64_xword : endianness -> byte_sequence -> error (elf64_xword * byte_sequence)
val elf64_xword_rshift : elf64_xword -> nat -> elf64_xword
val elf64_xword_land : elf64_xword -> elf64_xword -> elf64_xword
val elf64_xword_of_int64 : int64 -> elf64_xword

declare ocaml target_rep function string_of_elf64_xword = `Uint64.to_string`
declare ocaml target_rep function read_elf64_xword = `Ml_bindings.read_elf64_xword`
declare ocaml target_rep function natural_of_elf64_xword = `Ml_bindings.natural_of_elf64_xword`
declare ocaml target_rep function elf64_xword_rshift = `Uint64.shift_right`
declare ocaml target_rep function elf64_xword_land = `Uint64.logand`
declare ocaml target_rep function elf64_xword_of_int64 = `Uint64.of_int64`

instance (Show elf64_xword)
  let show = string_of_elf64_xword
end

(** elf64_sxword type and bindings *)

type elf64_sxword

declare ocaml target_rep type elf64_sxword = `Int64.t`

val string_of_elf64_sxword : elf64_sxword -> string
val natural_of_elf64_sxword : elf64_sxword -> natural
val read_elf64_sxword : endianness -> byte_sequence -> error (elf64_sxword * byte_sequence)

declare ocaml target_rep function string_of_elf64_sxword = `Int64.to_string`
declare ocaml target_rep function read_elf64_sxword = `Ml_bindings.read_elf64_sxword`
declare ocaml target_rep function natural_of_elf64_sxword = `Ml_bindings.natural_of_elf64_sxword`

instance (Show elf64_sxword)
  let show = string_of_elf64_sxword
end