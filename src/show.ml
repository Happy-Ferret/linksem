(*Generated by Lem from show.lem.*)
(** [show.lem] exports the typeclass [Show] and associated functions for pretty
  * printing arbitrary values.
  *)

open Lem_function
open Lem_list
open Lem_num
open Lem_string

open Missing_pervasives

type 'a show_class={
  show_method : 'a -> string
}

(** [string_of_bool b] produces a string representation of boolean [b].
  *)
(*val string_of_bool : bool -> string*)
let string_of_bool b =  
((match b with
    | true  -> "true"
    | false -> "false"
  ))

let instance_Show_Show_bool_dict =({

  show_method = string_of_bool})

let instance_Show_Show_string_dict =({

  show_method = id})

(** [string_of_pair p] produces a string representation of pair [p].
  *)
(*val string_of_pair : forall 'a 'b. Show 'a, Show 'b => ('a * 'b) -> string*)
let string_of_pair dict_Show_Show_a dict_Show_Show_b (left, right) =  
("(" ^ (dict_Show_Show_a.show_method left ^ (", " ^ (dict_Show_Show_b.show_method right ^ ")"))))

let instance_Show_Show_tup2_dict dict_Show_Show_a dict_Show_Show_b =({

  show_method = 
  (string_of_pair dict_Show_Show_a dict_Show_Show_b)})

(** [string_of_list l] produces a string representation of list [l].
  *)
(*val string_of_list : forall 'a. Show 'a => list 'a -> string*)
let string_of_list dict_Show_Show_a l =  
(let result = (intercalate "," (List.map  
  dict_Show_Show_a.show_method l)) in
  let folded = (List.fold_right (^) result "") in
    "[" ^ (folded ^ "]"))

let instance_Show_Show_list_dict dict_Show_Show_a =({

  show_method = 
  (string_of_list dict_Show_Show_a)})

let instance_Show_Show_nat_dict =({

  show_method = string_of_int})
