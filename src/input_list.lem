open import Basic_classes
open import Function
open import String
open import String_extra
open import Tuple
open import Bool
open import List
open import List_extra
open import Sorting
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show

open import Archive
open import Command_line
open import Elf_types_native_uint
open import Elf_file
open import Elf_header

(* Here we elaborate away various properties of the command line: 
 * archives, groups, library paths, -l, --as-needed, --whole-archive,
 * and which inputs can be used to resolve symbols undefined in which other inputs.
 * 
 * What we get out is a list of input files and the options applying to them.
 * Input files are either relocatable files, shared objects or linker scripts.
 *)

type input_blob =  Reloc of byte_sequence
                 | Shared of byte_sequence
                 | Script of byte_sequence

type input_item = string * input_blob

val string_of_input_blob : input_blob -> string
let string_of_input_blob item = match item with
    Reloc(seq) -> "relocatable file (" ^ (show (Byte_sequence.length seq)) ^ " bytes)"
  | Shared(seq) -> "shared object (" ^ (show (Byte_sequence.length seq)) ^ " bytes)"
  | Script(seq) -> "script (" ^ (show (Byte_sequence.length seq)) ^ " bytes)"
end

instance (Show input_blob)
    let show = string_of_input_blob
end

(* About symbol resolution and "suppliers".
 * 
 * Normally, 
 * 
 * - any .o file can supply any other .o file on the command line
 * - any .a file supplies only files appearing to its left
 *      i.e. "it is searched once for definitions"
 * - does a .o file supply a .a file? to both its right and left? Experimentally, YES.
 * 
 * Groups change this.
 * 
 * When we expand a .a file into a list of .o files, what is the supplier
 * relation among them? I *THINK* that within the archive, each can supply any other,
 * but outside the archive, each can only supply leftmore.
 * 
 * What's the best way to encode this? 
 * A completely manifest representation of "who can supply who" 
 * could easily get broken as we expand archives independently
 * or otherwise make substitutions in the input list.
 * So we make it a function from input lists to a list of bool.
 * We also give it an int, denoting its *own* position in the
 * input list; we fail if this isn't a sane value.
 * The question of whether an object can supply itself is not
 * completely obvious (it can, I *think* ).
 *)

type can_supply_function = list input_item -> nat -> list bool

type input_options =  <| item_fmt : string
                       ; item_check_sections : bool
                       ; item_copy_dt_needed : bool
                       ; item_force_output : bool  (* true for .o, false for .a unless --whole-archive, 
                                                 true for .so with --no-as-needed, 
                                                 false for .so with --as-needed *)
                       ; item_can_supply_definitions_to : can_supply_function (* which inputs we can supply symbol definitions to *)
                       |>

val string_of_input_options : input_options -> string
let string_of_input_options opts = "(some options)"

instance (Show input_options)
    let show = string_of_input_options
end

type input_list = list (input_item * input_options)

val toplevel_dot_o_can_supply : list input_item -> nat -> list bool
let toplevel_dot_o_can_supply inputs pos 
 = List.genlist (fun _ -> true) (List.length inputs)

val toplevel_shared_can_supply : list input_item -> nat -> list bool
let toplevel_shared_can_supply inputs pos 
 = List.genlist (fun ndx -> ndx <= pos) (List.length inputs)
 
val toplevel_archive_can_supply : list input_item -> nat -> list bool
let toplevel_archive_can_supply inputs pos 
 = List.genlist (fun ndx -> ndx <= pos) (List.length inputs)

val lib_filename_from_spec : string -> string -> string
let lib_filename_from_spec spec ext =
    match (toCharList spec) with
        #':' :: more -> (toString more)
        | _ -> "lib" ^ spec ^ "." ^ ext
    end

val find_library_in : string -> list string -> list string -> maybe string
let find_library_in spec extensions pathlist = 
    (* Recall the GNU libc's "libc.so is a linker script" hack. 
     * This tells us that we should only look at file extensions, not contents. *)
    let file_exists name = 
        match Byte_sequence.acquire name with (* FIXME: use cheaper call *)
            Success _ -> true
            | Fail _ -> false
        end
    in
    let expand_candidate_libname = fun path -> fun ext -> (path ^ "/" ^ (lib_filename_from_spec spec ext))
    in
    let get_expansions_existing = fun path -> 
        [cand | forall (cand MEM (List.map (expand_candidate_libname path) extensions)) | file_exists cand]
    in
    let found_by_path = List.map (fun path -> (path, get_expansions_existing path)) pathlist
    in 
    (* Do we take the first path for which some extension is found? 
     * Or do we keep going if we prefer shared libraries, say? 
     * I think it's the former. *)
    match List.find (fun (path, exps) -> (List.length exps) > 0) found_by_path with
        Just (path, exps) -> Just(head exps)
        | Nothing -> Nothing
    end

val find_one_library_filename : input_file_options -> string -> string
let find_one_library_filename options str = 
    let extensions = if options.input_link_sharedlibs then ["so"; "a"] else ["a"]
    in
    let found = find_library_in str extensions options.input_libpath
    in match found with
        Nothing -> failwith ("couldn't find library matching '" ^ str ^ "'")
        | Just result -> result
    end

val is_elf64_with_type : elf64_half -> byte_sequence -> bool
let is_elf64_with_type typ seq = 
    (*let _ = Missing_pervasives.prints ("elf64? " ^ 
        (match seq with Sequence(bs) -> show (List.take 16 bs) end))
    in*)
    match Elf_file.read_elf64_file seq with
    Success(e) -> (* let _ = Missing_pervasives.println ": yes" in *) (e.elf64_file_header.elf64_type = typ)
    | Fail _ -> (* let _ = Missing_pervasives.println ": no" in *) false
    end

val is_archive : byte_sequence -> bool
let is_archive seq =
    match read_archive_global_header seq with
        Success _ -> true
        | Fail _ -> false
    end

val open_file_and_expand : string -> list input_item
let open_file_and_expand fname = 
    match Byte_sequence.acquire fname with
        Fail _ -> failwith ("could not open file " ^ fname)
        | Success seq ->
            if is_elf64_with_type (elf64_half_of_natural elf_ft_rel) seq then [(fname, Reloc(seq))]
            else if is_elf64_with_type (elf64_half_of_natural elf_ft_dyn) seq then [(fname, Shared(seq))]
            else if is_archive seq then
                match read_archive seq with
                    Fail _ -> failwith ("could not read archive " ^ fname)
                    | Success pairs -> 
                        let _ = Missing_pervasives.println (fname ^ " is an archive with " ^ (show (List.length pairs)) ^ " members")
                        in 
                        let not_elf = List.filter (fun (fname, seq) -> not (is_elf64_with_type (elf64_half_of_natural elf_ft_rel) seq)) pairs 
                        in
                        if List.length not_elf = 0 
                        then List.map (fun (fname, seq) -> (fname, Reloc(seq))) pairs
                        else let (names, seqs) = unzip not_elf in 
                            failwith ("archive with unsupported contents (" ^ (show names) ^ ")")
                end
            else [(fname, Script(seq))]
    end

val make_input_items_and_options : list input_item -> Command_line.input_file_options -> nat -> list (input_item * input_options)
let make_input_items_and_options file_list cmdopts rightmore_items_in_group =
    match file_list with
         [] -> failwith "impossible: empty list of files"
       | [(fname, Reloc(seq))] -> 
            [((fname, Reloc(seq)), 
                <| item_fmt = cmdopts.input_fmt
                 ; item_check_sections = cmdopts.input_check_sections
                 ; item_copy_dt_needed = cmdopts.input_copy_dt_needed
                 ; item_force_output = true
                 ; item_can_supply_definitions_to = toplevel_dot_o_can_supply
                 |>)]
       | [(fname, Shared(seq))] ->
            [((fname, Shared(seq)), 
                 <| item_fmt = cmdopts.input_fmt
                  ; item_check_sections = cmdopts.input_check_sections
                  ; item_copy_dt_needed = cmdopts.input_copy_dt_needed
                  ; item_force_output = if cmdopts.input_as_needed then false else true
                  ; item_can_supply_definitions_to = toplevel_shared_can_supply
                  |>)]
       | [(fname, Script(seq))] ->
            [((fname, Script(seq)), 
                <| item_fmt = cmdopts.input_fmt
                 ; item_check_sections = cmdopts.input_check_sections
                 ; item_copy_dt_needed = cmdopts.input_copy_dt_needed
                 ; item_force_output = true
                 ; item_can_supply_definitions_to = toplevel_dot_o_can_supply (* CHECK!? *)
                 |>)]
       | relocpair :: more_relocpairs (* guaranteed to be all relocs, from one archive *) -> 
            mapMaybei (fun i -> (fun (fname, reloc) -> Just
                ((fname, reloc), <| item_fmt = cmdopts.input_fmt
                                   ; item_check_sections = cmdopts.input_check_sections
                                   ; item_copy_dt_needed = cmdopts.input_copy_dt_needed
                                   ; item_force_output = if cmdopts.input_whole_archive then true else false
                                   ; item_can_supply_definitions_to = 
                                    let rightmore_items_in_list = List.length file_list - (natFromNatural i)
                                    in
                                    (fun input_list -> (fun pos -> 
                                        List.genlist 
                                            (fun ndx -> ndx <= pos + rightmore_items_in_list + rightmore_items_in_group) 
                                            (List.length input_list)))
                                   |>)
            )) file_list
       | _ -> failwith "impossible expanded input item"
   end

val elaborate_input_helper : list Command_line.input_file -> input_list -> input_list
let rec elaborate_input_helper inputs acc = 
    match inputs with
        [] -> acc
        | input :: more_inputs -> 
            match input with 
                File(spec, options)
                    -> match spec with
                        Filename(str)
                            -> elaborate_input_helper more_inputs 
                                (acc ++ (make_input_items_and_options (open_file_and_expand str) options 0))
                        | Libname(str) 
                            -> elaborate_input_helper more_inputs 
                                (acc ++ (make_input_items_and_options 
                                            (open_file_and_expand (find_one_library_filename options str)) 
                                            options 0))
                        end
                | Group(specs_and_options) ->
                    (* Every member of a group is either a filename or a libname.
                     * First expand the libnames, leaving the Group intact. *)
                    let group_with_lib_files
                     = List.map (fun (spec, options) -> match spec with 
                         Filename(str) -> (str, options)
                         | Libname(str) -> (find_one_library_filename options str, options)
                         end) specs_and_options
                    in
                    (* Now expand archives into file lists. *)
                    let group_with_file_lists 
                     = List.map (fun (str, options) -> (open_file_and_expand str, options)) group_with_lib_files
                    in
                    (* Now expand them into files and fix up the options appropriately *)
                    let to_add
                     = mapMaybei (fun group_index -> (fun (file_list, options) -> (
                        let rightmore_objects_in_group = 
                            let group_remainder
                             = List.drop (natFromNatural (group_index + 1)) group_with_file_lists
                            in
                            let group_remainder_object_counts
                             = List.map (fun (fl, optl) -> Missing_pervasives.length fl) group_remainder
                            in
                            let total_object_count 
                             = foldl (+) 0 group_remainder_object_counts
                            in
                            total_object_count
                        in Just(
                            make_input_items_and_options file_list options (natFromNatural rightmore_objects_in_group)
                        )))) group_with_file_lists
                    in
                    elaborate_input_helper more_inputs (acc ++ (List.concat to_add))
            end
    end
    
val elaborate_input : list Command_line.input_file -> input_list
let rec elaborate_input inputs = elaborate_input_helper inputs []
