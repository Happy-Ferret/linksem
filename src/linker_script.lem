open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Num
open import Maybe
open import Assert_extra
import Map

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show

open import Elf_header
open import Elf_file
open import Elf_interpreted_section

open import Abis
open import Command_line
open import Input_list
open import Memory_image
open import Elf_memory_image (* HMM -- ideally we'd be ELF-agnostic in this file. 
     But Abstract_abi is now merged into Elf_memory_image, so never mind. *)
open import Elf_memory_image_of_elf64_file
open import Elf_symbol_table
open import Elf_section_header_table
open import Elf_types_native_uint

(* We model two kinds of linker script: "implicit scripts", which are supplied 
 * on the command line as input objects, and "control scripts" of which there
 * is exactly one per link job. The abstract syntax of each script comes from the
 * same grammar. 
 * 
 * We define the control script as a bunch of functions, to allow for
 * link jobs where we don't have an AST and the script behaviour is hard-coded. 
 *)

(* Input sections come from individual (relocatable) ELF files. 
 * The name of this file is important! 
 * 
 * Each input "section" is always an identified section or common symbol 
 * *within* some ELF memory image. *)

type input_section_rec = <| 
    fname : string
;   img   : elf_memory_image
;   shndx : natural
;   secname: string
;   isec : elf64_interpreted_section
|>

type input_spec
 = Common of (string * elf_memory_image * symbol_definition) (* string is symbol name -- must be a COMMON symbol *)
 | InputSection of input_section_rec

(* A control script defines
 * - output sections
 * - a mapping from output sections to (ordered) input sections
 * - extra symbols
 * - output format etc. (skip this for now)
 *)

(* We will have to deal with merging etc. at some point, somewhere
 * (maybe here, maybe not); for now we just produce an ordered list 
 * of sections. 
 *)
 
(* We can't model linker scripts as plain Lem functions without writing
 * them to a very different structure than that of scripts. The reason is that
 * certain features of the script language necessitate multiple passes
 * over the script structure. For example, to figure out how big an
 * output section is, hence where to begin the next section, you need to 
 * know which of the input sections are marked for KEEP. For that, you need 
 * a def-use graph over input sections. But for that, you also need to account 
 * for *all* symbol definitions, and the script itself is allowed to add new 
 * ones (right in among its input sections). So we have to do one pass to
 * enumerate the symbol additions, and another pass to eliminate sections
 * that we don't want to KEEP.
 *
 * Other gotchas include:
 * 
 * - symbol provision and address advancement can occur in among the input 
 * section queries, but also outside any output section. 
 * 
 * - semantics of DATA_SEGMENT_ALIGN depend on future script contents
 * 
 * - ONLY_IF_RO and ONLY_IF_RW are tricky: need to evaluate the input section
 * queries
 * 
 * - semantics of empty sections are subtle (". = ." will force an empty section
 * to be emitted, but ". = . + 0" will not do so).
 * 
 * Our approach is to define an interpreter for (at present) most of the script 
 * language.
 *)

type symbol_def_policy = AlwaysDefine
                        | ProvideIfUsed

type input_selector  = list input_spec -> list input_spec

type address_expr = Memory_image.expr

type output_guard = AlwaysOutput
                  | OnlyIfRo
                  | OnlyIfRw
                  
type symbol_spec = (natural * unsigned_char * unsigned_char) (* size, info, other *)

type script_element =
  DefineSymbol of (symbol_def_policy * string * symbol_spec)
| AdvanceAddress of address_expr_fn
| MarkAndAlignDataSegment of (natural * natural) (* maxpagesize, commonpagesize *)
| MarkDataSegmentEnd
| MarkDataSegmentRelroEnd of ((list output_section_spec) -> (natural * (natural -> natural)))
| OutputSection of (output_guard * (maybe (* address_expr *) address_expr_fn) * string * list script_element)
| DiscardInput of input_selector 
  (* Input queries can only occur within an output section. 
     Output sections may not nest within other output sections. 
     (Ideally we would use something like polymorphic variants to encode this.)
   *)
| InputQuery of (retain_policy * sort_policy * input_selector)
and 
 retain_policy = DefaultKeep
                    | KeepEvenWhenGC
and
 sort_policy = DefaultSort (* Use command line sort option, else input order *)
                  | InputOrder (* Always use input order *)
                  | ByName
                  | ByNameThenAlignment
                  | ByAlignment
                  | ByAlignmentThenName
                  | ByInitPriority
and 
 output_section_composition_element = 
    IncludeInputSection of (retain_policy * string (* file *) * natural (* shndx *) * elf64_interpreted_section * elf_memory_image)
    | IncludeCommonSymbol of (retain_policy * string (* file *) * symbol_definition * elf_memory_image)
    | Hole of natural (* size *)
    | ProvideSymbol of (symbol_def_policy * string * symbol_spec)
and 
(* This mirrors the OutputSection constructor, except that the script elements have become
 * output_section_composition_elements. *)
 output_section_spec = (output_guard * maybe natural * string * (list output_section_composition_element))
and
 allocated_sections_map = Map.map string output_section_spec
and
 address_expr_fn = natural -> allocated_sections_map -> natural

(* A linker control script is a function from inputs to output elements. 
 * We can define them in syntax (using an interpreter) 
 * or in Lem directly (as functions). *)
type linker_control_script = list script_element

val all_suffixes : list char -> list (list char)
let rec all_suffixes chars =
    match chars with 
        [] -> [[]]
        | c :: morecs -> chars :: (all_suffixes morecs)
    end

val glob_match : list char -> list char -> bool
let rec glob_match pat str = 
    match (pat, str) with
        ([], []) -> true
        | (#'?':: morepat, _ :: morestr) -> glob_match morepat morestr
        | (#'*':: morepat, _) ->
            (* if any suffix of the remaining string matches
             * the remaining pattern, we've matched the pattern 
             * from '*' onwards. *)
            let or_suffix_match = fun matched -> (fun newlist ->
                matched || glob_match morepat newlist)
            in 
            List.foldl (or_suffix_match) false (all_suffixes str)
        | (patc :: morepat, c :: morestr) -> patc = c && glob_match morepat morestr
        | ([], _) -> (* ran out of pattern *) false
        | (_, []) -> (* ran out of str *) false
    end

val default_symbol_spec : symbol_spec
let default_symbol_spec = (0, unsigned_char_of_natural 0, unsigned_char_of_natural 0)

(* These Lem functions replicate linker script functions or builtin behaviours. *)

val only_sections : input_selector 
let only_sections inputs = mapMaybe
    (fun i -> match i with 
      | InputSection(_) -> Just(i)
      | _ -> Nothing
    end) inputs

val filter_and_concat : (input_spec -> bool) -> input_selector (* a.k.a. (list input_spec) -> list elf64_interpreted_section *)
let filter_and_concat p inputs = List.filter p (only_sections inputs)

val name_matches : string -> input_spec -> bool
let name_matches pat input =
    match input with
        InputSection(inp) -> glob_match (toCharList pat) (toCharList inp.secname)
        | _ -> false
    end

val file_matches : string -> input_spec -> bool
let file_matches pat input = 
    match input with
        InputSection(inp) -> glob_match (toCharList pat) (toCharList inp.fname)
        | _ -> false
    end

val align_up : natural -> natural -> natural
let align_up addr align = 
    let quot = addr / align
    in
    if quot * align = addr then addr else (quot + 1) * align

val size_of_output_section_composition_element : output_section_composition_element -> natural
let size_of_output_section_composition_element el = match el with
    IncludeInputSection(rp, fname, shndx, isec, img) -> isec.elf64_section_size
    | IncludeCommonSymbol(rp, fname, def, img) -> natural_of_elf64_xword def.def_syment.elf64_st_size
    | Hole(sz) -> sz
end

(* DATA_SEGMENT_ALIGN is defined by two formulae 
 * (over pos and commonpagesize/maxpagesize)
 * "... depending on whether the latter uses fewer COMMONPAGESIZE sized
  pages for the data segment (area between the result of this
  expression and `DATA_SEGMENT_END') than the former or not.  If the
  latter form is used, it means COMMONPAGESIZE bytes of runtime
  memory will be saved at the expense of up to COMMONPAGESIZE wasted
  bytes in the on-disk file."

  So the amount of padding that gets inserted here depends on the location
  of something that comes *later*, namely DATA_SEGMENT_END. 
  So, we can't model it as a function of the current position. 
  Instead, we add MarkDataSegmentEnd and friends 
  to the script_element ADT.
 *)

let has_writability = fun writable -> (fun input_sec -> (
    match input_sec with
        Common(_, _, _)
            -> (* all common symbols are potentially writable *) true
        | InputSection(inp)
            -> let (flags : natural) = match elf_memory_image_section_by_index inp.shndx inp.img with 
                          Just x -> x.elf64_section_flags
                        | Nothing -> failwith "impossible: no such section"
                     end
                in 
                flag_is_set shf_write flags
    end
))

(* LARGE_COMMON seems to have been defined in this patch set:
    https://sourceware.org/ml/binutils/2005-07/txt00014.txt
   and at the time was "only for x86-64". It seems to be analogous
   to ".lbss", i.e. "large bss". libbfd defines SHF_X86_64_LARGE.
   The best comment seems to be in llvm's Support/ELF.h:
   
0814   // If an object file section does not have this flag set, then it may not hold
0815   // more than 2GB and can be freely referred to in objects using smaller code
0816   // models. Otherwise, only objects using larger code models can refer to them.
0817   // For example, a medium code model object can refer to data in a section that
0818   // sets this flag besides being able to refer to data in a section that does
0819   // not set it; likewise, a small code model object can refer only to code in a
0820   // section that does not set this flag.
   
 *)

val address_zero : address_expr_fn
let address_zero = fun pos -> (fun secs -> 0)

val output_sec_composition_size : list output_section_composition_element -> natural
let output_sec_composition_size comp = List.foldl (+) 0 (List.map size_of_output_section_composition_element comp)

val sizeof : string -> list output_section_spec -> natural
let sizeof secname secs = 
    let allSizes = mapMaybe (fun (guard, maybe_addr, name, compos) -> 
        if name = secname then
            Just (output_sec_composition_size compos)
        else Nothing
    ) secs
    in
    match allSizes with
        [sz] -> sz
        | [] -> failwith ("error: sizeof applied to non-existent section name " ^ secname)
        | _  -> failwith ("internal error: sizeof applied to section name with multiple definitions (" ^ secname ^ ")")
    end

val default_linker_control_script : abi any_abi_feature -> maybe natural -> maybe natural -> maybe natural -> natural -> linker_control_script
let default_linker_control_script a user_text_segment_start user_data_segment_start user_rodata_segment_start elf_headers_size = 
    let segment_start name default = match name with 
      "ldata-segment" -> match user_data_segment_start with 
        Nothing -> default
        | Just addr -> (* fun _ -> *) addr
        end
    | "text-segment" -> match user_text_segment_start with 
        Nothing -> default
        | Just addr -> (* fun _ -> *) addr
        end
    end
    in
    let is_large_common = (fun isec -> match isec with 
    Common(fname, img, def)
         -> let referenced_sec
             = match elf_memory_image_section_by_index (natural_of_elf64_half def.def_syment.elf64_st_shndx) img with
                Just s -> s
                | Nothing -> failwith "impossible: symbol references invalid section index"
            end
            in 
            a.section_is_large referenced_sec img
    | _ -> false
    end)
    in
    let is_common = (fun isec -> match isec with 
        Common(fname, _, _) -> not (is_large_common isec)
         | _ -> false
    end)
    in
    [
        (* For now, we base our script on the GNU bfd linker's scripts. 
           Here's the static -z combreloc one.
           
/* Script for -z combreloc: combine and sort reloc sections */
/* Copyright (C) 2014 Free Software Foundation, Inc.
   Copying and distribution of this script, with or without modification,
   are permitted in any medium without royalty provided the copyright
   notice and this notice are preserved.  */
OUTPUT_FORMAT("elf64-x86-64", "elf64-x86-64",
              "elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SEARCH_DIR("=/usr/x86_64-linux-gnu/lib64"); SEARCH_DIR("=/usr/local/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/local/lib64"); SEARCH_DIR("=/lib/x86_64-linux-gnu"); SEARCH_DIR("=/lib64"); SEARCH_DIR("=/usr/lib/x86_64-linux-gnu"); SEARCH_DIR("=/usr/lib64"); SEARCH_DIR("=/usr/x86_64-linux-gnu/lib"); SEARCH_DIR("=/usr/local/lib"); SEARCH_DIR("=/lib"); SEARCH_DIR("=/usr/lib");
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = SEGMENT_START("text-segment", 0x400000)); . = SEGMENT_START("text-segment", 0x400000) + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rela.dyn       :
    {
      *(.rela.init)
      *(.rela.text .rela.text.* .rela.gnu.linkonce.t.* )
      *(.rela.fini)
      *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.* )
      *(.rela.data .rela.data.* .rela.gnu.linkonce.d.* )
      *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.* )
      *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.* )
      *(.rela.ctors)
      *(.rela.dtors)
      *(.rela.got)
      *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.* )
      *(.rela.ldata .rela.ldata.* .rela.gnu.linkonce.l.* )
      *(.rela.lbss .rela.lbss.* .rela.gnu.linkonce.lb.* )
      *(.rela.lrodata .rela.lrodata.* .rela.gnu.linkonce.lr.* )
      *(.rela.ifunc)
    }
  .rela.plt       :
    {
      *(.rela.plt)
      PROVIDE_HIDDEN (__rela_iplt_start = .);
      *(.rela.iplt)
      PROVIDE_HIDDEN (__rela_iplt_end = .);
    }
  .init           :
  {
    KEEP ( *(SORT_NONE(.init)))
  }
  .plt            : { *(.plt) *(.iplt) }
  .plt.bnd        : { *(.plt.bnd) }
  .text           :
  {
    *(.text.unlikely .text.*_unlikely .text.unlikely.* )
    *(.text.exit .text.exit.* )
    *(.text.startup .text.startup.* )
    *(.text.hot .text.hot.* )
    *(.text .stub .text.* .gnu.linkonce.t.* )
    /* .gnu.warning sections are handled specially by elf32.em.  */
    *(.gnu.warning)
  }
  .fini           :
  {
    KEEP ( *(SORT_NONE(.fini)))
  }
   PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.* ) }
  .rodata1        : { *(.rodata1) }
  .eh_frame_hdr : { *(.eh_frame_hdr) }
  .eh_frame       : ONLY_IF_RO { KEEP ( *(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RO { *(.gcc_except_table
  .gcc_except_table.* ) }
  /* These sections are generated by the Sun/Oracle C++ compiler.  */
  .exception_ranges   : ONLY_IF_RO { *(.exception_ranges
  .exception_ranges* ) }
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN (CONSTANT (MAXPAGESIZE)) - ((CONSTANT (MAXPAGESIZE) - .) & (CONSTANT (MAXPAGESIZE) - 1)); . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
  /* Exception handling  */
  .eh_frame       : ONLY_IF_RW { KEEP ( *(.eh_frame)) }
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.* ) }
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges .exception_ranges* ) }
  /* Thread Local Storage sections  */
  .tdata          : { *(.tdata .tdata.* .gnu.linkonce.td.* ) }
  .tbss           : { *(.tbss .tbss.* .gnu.linkonce.tb.* ) *(.tcommon) }
  .preinit_array     :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP ( *(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  }
  .init_array     :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP ( *(SORT_BY_INIT_PRIORITY(.init_array.* ) SORT_BY_INIT_PRIORITY(.ctors.* )))
    KEEP ( *(.init_array EXCLUDE_FILE ( *crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  }
  .fini_array     :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP ( *(SORT_BY_INIT_PRIORITY(.fini_array.* ) SORT_BY_INIT_PRIORITY(.dtors.* )))
    KEEP ( *(.fini_array EXCLUDE_FILE ( *crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  }
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP ( *crtbegin.o(.ctors))
    KEEP ( *crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP ( *(EXCLUDE_FILE ( *crtend.o *crtend?.o ) .ctors))
    KEEP ( *(SORT(.ctors.* )))
    KEEP ( *(.ctors))
  }
  .dtors          :
  {
    KEEP ( *crtbegin.o(.dtors))
    KEEP ( *crtbegin?.o(.dtors))
    KEEP ( *(EXCLUDE_FILE ( *crtend.o *crtend?.o ) .dtors))
    KEEP ( *(SORT(.dtors.* )))
    KEEP ( *(.dtors))
  }
  .jcr            : { KEEP ( *(.jcr)) }
  .data.rel.ro : { *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.* ) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.* ) }
  .dynamic        : { *(.dynamic) }
  .got            : { *(.got) *(.igot) }
  . = DATA_SEGMENT_RELRO_END (SIZEOF (.got.plt) >= 24 ? 24 : 0, .);
  .got.plt        : { *(.got.plt)  *(.igot.plt) }
  .data           :
  {
    *(.data .data.* .gnu.linkonce.d.* )
    SORT(CONSTRUCTORS)
  }
  .data1          : { *(.data1) }
  _edata = .; PROVIDE (edata = .);
  . = .;
  __bss_start = .;
  .bss            :
  {
   *(.dynbss)
   *(.bss .bss.* .gnu.linkonce.b.* )
   *(COMMON)
   /* Align here to ensure that the .bss section occupies space up to
      _end.  Align after .bss to ensure correct alignment even if the
      .bss section disappears because there are no input sections.
      FIXME: Why do we need it? When there is no .bss section, we don't
      pad the .data section.  */
   . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  .lbss   :
  {
    *(.dynlbss)
    *(.lbss .lbss.* .gnu.linkonce.lb.* )
    *(LARGE_COMMON)
  }
  . = ALIGN(64 / 8);
  . = SEGMENT_START("ldata-segment", .);
  .lrodata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.lrodata .lrodata.* .gnu.linkonce.lr.* )
  }
  .ldata   ALIGN(CONSTANT (MAXPAGESIZE)) + (. & (CONSTANT (MAXPAGESIZE) - 1)) :
  {
    *(.ldata .ldata.* .gnu.linkonce.l.* )
    . = ALIGN(. != 0 ? 64 / 8 : 1);
  }
  . = ALIGN(64 / 8);
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
  .stab          0 : { *(.stab) }
  .stabstr       0 : { *(.stabstr) }
  .stab.excl     0 : { *(.stab.excl) }
  .stab.exclstr  0 : { *(.stab.exclstr) }
  .stab.index    0 : { *(.stab.index) }
  .stab.indexstr 0 : { *(.stab.indexstr) }
  .comment       0 : { *(.comment) }
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
  /* DWARF 1 */
  .debug          0 : { *(.debug) }
  .line           0 : { *(.line) }
  /* GNU DWARF 1 extensions */
  .debug_srcinfo  0 : { *(.debug_srcinfo) }
  .debug_sfnames  0 : { *(.debug_sfnames) }
  /* DWARF 1.1 and DWARF 2 */
  .debug_aranges  0 : { *(.debug_aranges) }
  .debug_pubnames 0 : { *(.debug_pubnames) }
  /* DWARF 2 */
  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.* ) }
  .debug_abbrev   0 : { *(.debug_abbrev) }
  .debug_line     0 : { *(.debug_line .debug_line.* .debug_line_end ) }
  .debug_frame    0 : { *(.debug_frame) }
  .debug_str      0 : { *(.debug_str) }
  .debug_loc      0 : { *(.debug_loc) }
  .debug_macinfo  0 : { *(.debug_macinfo) }
  /* SGI/MIPS DWARF 2 extensions */
  .debug_weaknames 0 : { *(.debug_weaknames) }
  .debug_funcnames 0 : { *(.debug_funcnames) }
  .debug_typenames 0 : { *(.debug_typenames) }
  .debug_varnames  0 : { *(.debug_varnames) }
  /* DWARF 3 */
  .debug_pubtypes 0 : { *(.debug_pubtypes) }
  .debug_ranges   0 : { *(.debug_ranges) }
  /* DWARF Extension.  */
  .debug_macro    0 : { *(.debug_macro) }
  .gnu.attributes 0 : { KEEP ( *(.gnu.attributes)) }
  /DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_* ) }
}
         *)
         
         (*  function from 
                  inputs and configuration
             to
                  output sections-with-address-and-policy, output symbols-with-address-and-attributes, 
                      discards, orphans
             BUT
                   1. policy is not a property of output sections, but of *inputs within outputs*
                         i.e. KEEP( *(.init))
         
             what's helpful for writing such functions?
             
             e.g. only_if_ro (input_query) (output ): 
             
             i.e.    ++ only_if_ro OutputSection(AlwaysOutput, Nothing, ".eh_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame"))])

                 want to take a bunch of outputs
                         and return a bunch of outputs?
                         
                         if so, need to return a "current address"
             
          *)
    (DefineSymbol(ProvideIfUsed, "__executable_start", default_symbol_spec))
  ; AdvanceAddress((* BinRel(Eq, Constant( *) fun _ -> (fun _ -> 
        (segment_start "text-segment" (4 * 1048576)) + elf_headers_size))
  ; OutputSection(AlwaysOutput, Nothing, ".interp", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".interp"))])
  ; OutputSection(AlwaysOutput, Nothing, ".note.gnu.build-id", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".note.gnu.build-id"))])
  ; OutputSection(AlwaysOutput, Nothing, ".hash", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".hash"))])
  ; OutputSection(AlwaysOutput, Nothing, ".gnu_hash", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.hash"))])
  ; OutputSection(AlwaysOutput, Nothing, ".dynsym", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynsym"))])
  ; OutputSection(AlwaysOutput, Nothing, ".dynstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynstr"))])
  ; OutputSection(AlwaysOutput, Nothing, ".gnu.version", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.version"))])
  ; OutputSection(AlwaysOutput, Nothing, ".gnu.version_d", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.version_d"))])
  ; OutputSection(AlwaysOutput, Nothing, ".gnu.version_r", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".gnu.version_r"))])
  ; OutputSection(AlwaysOutput, Nothing, ".rela.dyn", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.init"))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.text" s || name_matches ".rela.text.*" s || name_matches ".rela.gnu.linkonce.t.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.rodata" s || name_matches ".rela.rodata.*" s || name_matches ".rela.gnu.linkonce.r.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.data" s || name_matches ".rela.data.*" s || name_matches ".rela.gnu.linkonce.d.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.tdata" s || name_matches ".rela.tdata.*" s || name_matches ".rela.gnu.linkonce.td.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.tbss" s || name_matches ".rela.tbss.*" s || name_matches ".rela.gnu.linkonce.tb.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.ctors"))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.got"))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.bss" s || name_matches ".rela.bss.*" s || name_matches ".rela.gnu.linkonce.b.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.ldata" s || name_matches ".rela.ldata.*" s || name_matches ".rela.gnu.linkonce.l.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
      fun s -> name_matches ".rela.lbss" s || name_matches ".rela.lbss.*" s || name_matches ".rela.gnu.linkonce.lb.*" s))
                                       ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.ifunc"))
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".rela.plt", [
      InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.plt"))
    ; DefineSymbol(ProvideIfUsed, "__rela_iplt_start", (0, make_symbol_info stb_local stt_notype (* FIXME *), make_symbol_other stv_hidden))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".rela.iplt"))
    ; DefineSymbol(ProvideIfUsed, "__rela_iplt_end", (0, make_symbol_info stb_local stt_notype (* FIXME *), make_symbol_other stv_hidden))
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".init", [
      InputQuery(KeepEvenWhenGC, InputOrder, filter_and_concat (name_matches ".init"))
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".plt", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".plt"))
                         ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".iplt"))
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".plt.bnd", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".plt.bnd"))])
  ; OutputSection(AlwaysOutput, Nothing, ".text", [
      InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".text.unlikely" s || name_matches ".text.*_unlikely" s || name_matches ".text.unlikely.*" s
       ))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (  
        fun s -> name_matches ".text.exit" s || name_matches ".text.exit.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".text.startup" s || name_matches ".text.startup.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".text.hot" s || name_matches ".text.hot.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".text" s || name_matches ".stub" s || name_matches ".text.*" s || name_matches ".gnu.linkonce.t.*" s))
    ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
         (* ".gnu.warning sections are handled specially by elf32.em."
          * GAH. That means that what we specify here is not (completely) what 
          * needs to happen with these sections. *)
        fun s -> name_matches ".gnu_warning" s))
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".fini", [
      InputQuery(KeepEvenWhenGC, InputOrder, filter_and_concat (name_matches ".fini"))
    ])
  ; DefineSymbol(ProvideIfUsed, "__etext", default_symbol_spec)
  ; DefineSymbol(ProvideIfUsed, "_etext", default_symbol_spec)
  ; DefineSymbol(ProvideIfUsed, "etext", default_symbol_spec)
  ; OutputSection(AlwaysOutput, Nothing, ".rodata", [
    InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".rodata" s || name_matches ".rodata.*" s || name_matches ".gnu.linkonce.r.*" s
    ))])
  ; OutputSection(AlwaysOutput, Nothing, ".eh_frame_hdr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame_hdr")) ])
  ; OutputSection(OnlyIfRo, Nothing, ".eh_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame"))])
  ; OutputSection(OnlyIfRo, Nothing, ".gcc_except_table", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun s -> name_matches ".gcc_except_table" s || name_matches ".gcc_except_table.*" s))])
  ; OutputSection(OnlyIfRo, Nothing, ".exception_ranges", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun s -> name_matches ".exception_ranges" s || name_matches ".exception_ranges*" s))])
  ; AdvanceAddress(fun addr -> (fun _ -> 
      (* BinRel(Eq, Constant( *)
    align_up addr (a.maxpagesize - (unsafe_natural_land (a.maxpagesize - addr) (a.maxpagesize - 1)))
    ))
  ; MarkAndAlignDataSegment(a.maxpagesize, a.commonpagesize)
  ; OutputSection(OnlyIfRw, Nothing, ".eh_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".eh_frame"))])
  ; OutputSection(OnlyIfRw, Nothing, ".gcc_except_table", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun s -> name_matches ".gcc_except_table" s || name_matches ".gcc_except_table.*" s))])
  ; OutputSection(OnlyIfRw, Nothing, ".exception_ranges", [InputQuery(DefaultKeep, DefaultSort, 
    filter_and_concat (fun s -> name_matches ".exception_ranges" s || name_matches ".exception_ranges*" s))])
  ; OutputSection(AlwaysOutput, Nothing, ".tdata", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat 
        (fun s -> name_matches ".tdata" s || name_matches ".tdata.*" s || name_matches ".gnu.linkonce.td.*" s))])
  ; OutputSection(AlwaysOutput, Nothing, ".tbss", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat 
        (fun s -> name_matches ".tbss" s || name_matches ".tbss.*" s || name_matches ".gnu.linkonce.tb.*" s))
        ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".tcommon"))])
  ; OutputSection(AlwaysOutput, Nothing, ".preinit_array", [
        DefineSymbol(ProvideIfUsed, "__preinit_array_start", default_symbol_spec)
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun s -> name_matches ".preinit_array" s))
      ; DefineSymbol(ProvideIfUsed, "__preinit_array_end", default_symbol_spec)
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".init_array", [
        DefineSymbol(ProvideIfUsed, "__init_array_start", default_symbol_spec)
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun s -> name_matches ".init_array.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun s -> name_matches ".ctors.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat 
            (fun s -> name_matches ".init_array" s
            || (name_matches ".ctors" s && not (file_matches "*crtbegin.o" s || file_matches "*crtbegin?.o" s
                 || file_matches "*crtend.o" s || file_matches "*crtend?.o " s)))
            )
      ; DefineSymbol(ProvideIfUsed, "__init_array_end", default_symbol_spec)
    ])
  ; OutputSection(AlwaysOutput, Nothing, ".fini_array", [
        DefineSymbol(ProvideIfUsed, "__fini_array_start", default_symbol_spec)
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun s -> name_matches ".fini_array.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat (fun s -> name_matches ".dtors.*" s))
      ; InputQuery(KeepEvenWhenGC, ByInitPriority, filter_and_concat 
            (fun s -> name_matches ".fini_array" s
            || (name_matches ".dtors" s && not (file_matches "*crtbegin.o" s || file_matches "*crtbegin?.o" s
                 || file_matches "*crtend.o" s || file_matches "*crtend?.o " s)))
            )
      ; DefineSymbol(ProvideIfUsed, "__fini_array_end", default_symbol_spec)
    ])
   ; OutputSection(AlwaysOutput, Nothing, ".ctors", [
        InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun s -> file_matches "*crtbegin.o" s && name_matches ".ctors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun s -> file_matches "*crtbegin?.o" s && name_matches ".ctors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
            (fun s -> not (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".ctors" s))
      ; InputQuery(KeepEvenWhenGC, ByName, filter_and_concat (fun s -> name_matches ".ctors.*" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
        (fun s -> (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".ctors" s))
        (* NOTE: this exclusion is implicit in the usual linker script, 
         * because it won't match an input section more than once. We should
         * just replicate this behaviour, since other parts of the script might rely on it
         * less obviously. *)
    ])
   ; OutputSection(AlwaysOutput, Nothing, ".dtors", [
        InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun s -> file_matches "*crtbegin.o" s && name_matches ".dtors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (fun s -> file_matches "*crtbegin?.o" s && name_matches ".dtors" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
            (fun s -> not (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".dtors" s))
      ; InputQuery(KeepEvenWhenGC, ByName, filter_and_concat (fun s -> name_matches ".dtors.*" s))
      ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat 
        (fun s -> (file_matches "*crtend.o" s || file_matches "*crtend?.o" s) && name_matches ".dtors" s))
    ])
   ; OutputSection(AlwaysOutput, Nothing, ".jcr", [InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (name_matches ".jcr"))])
   ; OutputSection(AlwaysOutput, Nothing, ".data.rel.ro", [
        InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
            fun s -> name_matches ".data.rel.ro.local*" s || name_matches ".gnu.linkonce.d.rel.ro.local.*" s
        ));
        InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
            fun s -> name_matches ".data.rel.ro" s || name_matches ".data.rel.ro.*" s || name_matches ".gnu.linkonce.d.rel.ro.*" s
        ))
     ])
    ; OutputSection(AlwaysOutput, Nothing, ".dynamic", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynamic"))])
    ; OutputSection(AlwaysOutput, Nothing, ".got",     [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".got"))
                               ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".igot"))
                               ])
    ; MarkDataSegmentRelroEnd(fun secs -> (if (sizeof ".got.plt" secs) >= 24 then 24 else 0, (fun pos -> pos)))
    ; OutputSection(AlwaysOutput, Nothing, ".got.plt", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".got.plt"))
                               ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".igot.plt"))
     ])
    ; OutputSection(AlwaysOutput, Nothing, ".data", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".data" s || name_matches ".data.*" s || name_matches ".gnu.linkonce.d.*" s))
        (* the script also has SORT(CONSTRUCTORS) here, but it has no effect for ELF (I think) *)
        ])
    ; OutputSection(AlwaysOutput, Nothing, ".data1", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".data1"))])
    ; DefineSymbol(AlwaysDefine, "_edata", default_symbol_spec)
    ; DefineSymbol(ProvideIfUsed, "edata", default_symbol_spec)
    ; (* . = .;    <-- does this do anything? YES! It forces an output section to be emitted. 
         Since it occurs *outside* any output section, 
         it is assumed to start 
       *) 
      DefineSymbol(AlwaysDefine, "__bss_start", default_symbol_spec)
    ; OutputSection(AlwaysOutput, Nothing, ".bss", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynbss"))
                           ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
                                fun s -> name_matches ".bss" s || name_matches ".bss.*" s || name_matches ".gnu.linkonce.b.*" s))
                           ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat is_common)
      ])
    ; AdvanceAddress(fun pos -> (fun secs -> align_up (if pos = 0 then (64/8) else 1) pos))
    ; OutputSection(AlwaysOutput, Nothing, ".lbss", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynlbss"))
                            ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".dynlbss"))
                            ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
                                fun s -> name_matches ".lbss" s || name_matches ".lbss.*" s || name_matches ".gnu.linkonce.lb.*" s
                                ))
                            ; InputQuery(DefaultKeep, DefaultSort, filter_and_concat (is_large_common))
      ])
    ; AdvanceAddress(fun pos -> (fun secs -> align_up (64/8) pos))
    ; AdvanceAddress(fun pos -> (fun secs -> segment_start "ldata-segment" pos))
    ; OutputSection(AlwaysOutput, Just (fun pos -> fun secs -> align_up (a.maxpagesize + ((unsafe_natural_land pos a.maxpagesize) - 1)) pos), 
         ".lrodata",
         [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
            fun s -> name_matches ".lrodata" s || name_matches ".lrodata.*" s || name_matches ".gnu.linkonce.lr.*" s
            ))
        ; AdvanceAddress(fun pos -> (fun secs -> (if pos <> 0 then 64 / 8 else 1)))
        ])
    ; AdvanceAddress(fun pos -> (fun secs -> align_up (64/8) pos))
    ; DefineSymbol(AlwaysDefine, "_end", default_symbol_spec)
    ; DefineSymbol(ProvideIfUsed, "end", default_symbol_spec)
    ; MarkDataSegmentEnd
    ; OutputSection(AlwaysOutput, Just address_zero, ".stab", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".stabstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stabstr"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".stab.excl", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.excl"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".stab.exclstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.exclstr"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".stab.index", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.index"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".stab.indexstr", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".stab.indexstr"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".comment", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".comment"))])
      (* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  *)
      (* DWARF 1 *)
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".line", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".line"))])
      (* GNU DWARF 1 extensions *)
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_srcinfo", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_srcinfo"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_sfnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_sfname"))])
      (* DWARF 1.1 and DWARF 2 *)
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_aranges", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_aranges"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_pubnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_pubnames"))])
      (* DWARF 2 *)
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_info", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".debug_info" s || name_matches ".gnu.linkonce.wi.*" s))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_abbrev", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_abbrev"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_line", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (
        fun s -> name_matches ".debug_line" s || name_matches ".debug_line.*" s || name_matches ".debug_line_end" s))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_frame", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_frame"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_str", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_str"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_loc", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_loc"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_macinfo", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_macinfo"))])
      (* SGI/MIPS DWARF 2 extensions *)
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_weaknames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_weaknames"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_funcnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_funcnames"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_typenames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_typenames"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_varnames", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_varnames"))])
      (* DWARF 3 *) 
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_pubtypes", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_pubtypes"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_ranges", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_ranges"))])
      (* DWARF Extension.  *) 
    ; OutputSection(AlwaysOutput, Just address_zero, ".debug_macro", [InputQuery(DefaultKeep, DefaultSort, filter_and_concat (name_matches ".debug_macro"))])
    ; OutputSection(AlwaysOutput, Just address_zero, ".gnu.attributes", [InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (name_matches ".gnu.attributes"))])
    ; DiscardInput(filter_and_concat (fun s -> name_matches ".note.GNU-stack" s || name_matches ".gnu_debuglink" s || name_matches ".gnu.lto_*" s))
    (* FIXME: orphan sections? This 
       probably needs to go in the core linking logic,
       not the script. *)
    ]

(* Passes over the script: 
 * 
 * 1. assign input sections to output sections (or discard) and define symbols.
 * 
 * 2. compute def-use and optionally GC, removing unwanted sections and symbols
 * 
 * 3. build image, assigning addresses as we go. 
 *)

val assign_inputs_to_output_sections : 
    (list input_spec * list output_section_spec) ->  (* accumulator: list of discards, list of output compositions (these include symbols)  *)
    list input_spec ->            (* remaining inputs *)
    maybe output_section_spec ->  (* cur_sec -- the current output section spec *)
    maybe input_spec ->           (* last input section to be output -- might not have one *)
    linker_control_script -> 
    (list input_spec * list output_section_spec)     (* accumulated result *)
let rec assign_inputs_to_output_sections acc inputs cur_output_sec last_input_sec script = 
    let (rev_discards, rev_outputs) = acc in 
    let flush_output_sec 
     = fun output_sec -> match output_sec with
        Just (guard, addr, name, comp) -> 
            (* evaluate the guard *)
            if match guard with
                Always -> true
                | OnlyIfRo -> List.all (fun comp_el -> match comp_el with
                    IncludeInputSection(retainpol, fname, shndx, isec, img) -> 
                        (* is this section read-only? if it doesn't have shf_write, yes *)
                        0 = unsafe_natural_land isec.elf64_section_flags shf_write
                    | _ -> (* holes, common symbols and provided symbols shouldn't prevent ONLY_IF_RO *) true
                  end) comp
                | OnlyIfRw -> List.all (fun comp_el -> match comp_el with
                    IncludeInputSection(retainpol, fname, shndx, isec, img) -> 
                        (* is this section read-only? if it doesn't have shf_write, yes *)
                        0 <> unsafe_natural_land isec.elf64_section_flags shf_write
                    | _ -> (* holes etc. shouldn't prevent ONLY_IF_RW *) true
                  end) comp
            end 
            then (* do it     *) (rev_discards, (guard, addr, name, comp) :: rev_outputs)
            else (* ignore it *) acc
        | Nothing -> (* for convenience, make this a no-op rather than error *)
            (* failwith "internal error: flushing output section with no current output section" *)
            acc
    end
    in
    match script with
        [] -> flush_output_sec cur_output_sec
        | element :: more_elements ->
            let do_nothing = (acc, cur_output_sec, last_input_sec) 
            in
            let (new_acc, new_cur_output_sec, new_last_input_sec)
             = match element with
                DefineSymbol(symdefpol, name, (symsize, syminfo, symother)) ->
                    (* Label the current section in the image 
                     * with a new symbol definition. If there isn't
                     * a current section, use the ABS section (what is that labelling?). *)
                    (* (Map.insert , , , ) *)
                    do_nothing
                | AdvanceAddress(advance_fn) ->
                     (* If we're inside a section, insert a hole, 
                      * else just update the logical address *)
                     match cur_output_sec with
                        Nothing -> do_nothing
                            (* This assignment is setting a new LMA. *)
                            (* (acc,  *)
                        | Just sec -> do_nothing
                     end
                | MarkAndAlignDataSegment(maxpagesize, commonpagesize) -> 
                     (* The "data segment end" is a distinguished label, 
                      * so we can encode the whole thing into a conditional. *)
                     do_nothing
                | MarkDataSegmentEnd -> do_nothing
                | MarkDataSegmentRelroEnd(align_and_expr_fun) -> do_nothing
                | OutputSection(outputguard, maybe_expr, name, sub_elements) -> 
                    (* If we have a current output section, finish it and add it to the image.
                     * Q. Where do guards ("ONLY_IF_RO" etc) get evaluated?
                     * A. Inside flush_output_sec. *)
                    let acc_with_output_sec = flush_output_sec cur_output_sec
                    in
                    let new_cur_output_sec = Just(outputguard, (* maybe_expr pos secs *) Nothing, name, [])
                    in
                    (* Recurse down the list of input queries. Note that 
                       output sections may not nest within other output sections. *)
                    let final_acc
                    = assign_inputs_to_output_sections acc inputs new_cur_output_sec last_input_sec sub_elements
                    in
                    (* NOTE that this sub-accumulation will never add a new output section
                     * because output sections can't nest. *)
                    (* FIXME: place any orphans. PROBLEM: linkers are allowed to differ in how they do this. *)
                    (final_acc, cur_output_sec, last_input_sec) 
                | DiscardInput(selector) -> 
                    let selected = selector inputs
                    in
                    let (rev_discards, rev_outputs) = acc in
                    let _ = Missing_pervasives.errln ("Processing discard rule; selected " ^ (show (length selected))
                        ^ " inputs.")
                    in
                    (((List.reverse [i | forall (i MEM selected) | true]) ++ rev_discards, rev_outputs), cur_output_sec, last_input_sec)
                | InputQuery(retainpol, sortpol, selector) -> 
                    (* Input queries can only occur within an output section. *)
                    match cur_output_sec with
                        Nothing -> failwith "linker script error: input query without output section"
                        | Just (output_guard, output_sec_addr, output_sec_name, output_composition) ->
                            (* Search input memory images for matching sections. *)
                            let (matchList : list input_section_rec) = mapMaybe (fun inp -> 
                                match inp with
                                    InputSection(x) -> Just x
                                   | _ -> Nothing
                                end) (selector inputs)
                            in
                            (* Add them to the current output spec *)
                            (acc, Just (output_guard, output_sec_addr, output_sec_name, 
                                output_composition ++ 
                                [IncludeInputSection(retainpol, input_sec.fname, input_sec.shndx, input_sec.isec, input_sec.img)
                                     | forall (input_sec MEM matchList) | true]),
                            last_input_sec)
                    end
            end
            in
            assign_inputs_to_output_sections new_acc (inputs : list input_spec)
                (new_cur_output_sec : maybe output_section_spec)
                (new_last_input_sec : maybe input_spec)
                (more_elements : linker_control_script)
    end

(* NOTE: this is also responsible for deleting any PROVIDEd symbols that 
 * were not actually referenced. BUT HOW, if we haven't built the image and 
 * hence haven't added the symbols yet? Symbols affect reachability, so 
 * we're going to have to figure this out. Really we want a memory image that
 * does not yet have addresses assigned, but does have the symbols inserted. 
 * BUT even that is not right, because we want to be able to remove some
 * sections (GC them). So the section composition is not yet fixed. So we have 
 * a problem.
 *
 * Note that the only symbols we have to remove are ones that were PROVIDEd 
 * in our output composition. So doing the GC on output compositions seems
 * sane. We can get the graph's edge list by inspecting the constituent memory
 * images from which each output section composition element is drawn.
 * Collecting sections and collecting symbols seems fair. Note that symbols
 * can never be placed mid-section (I don't think?? they can use arbitrary
 * expressions, but not that depend on whether an input section is included
 * or not) so removing a section should never imply the removal of a symbol.
 * 
 * So that implies we need not yet build a memory image.
 *)
val compute_def_use_and_gc : Map.map string output_section_spec -> Map.map string output_section_spec
let compute_def_use_and_gc outputs_by_name = outputs_by_name

val build_image : 
    elf_memory_image ->          (* accumulator *)
    natural ->                   (* location counter *)
    Map.map string output_section_spec ->  (* outputs constructed earlier *)
    linker_control_script -> 
    (elf_memory_image * Map.map string output_section_spec)            (* accumulated result *)
let rec build_image acc pos outputs_by_name script = 
     let (add_output_section : (natural * elf_memory_image) -> output_section_spec -> (natural * elf_memory_image * output_section_spec))
     = fun (pos, acc_img) ->
        (fun (guard, addr, secname, comp) -> 
            let start_addr = match addr with 
                Just a -> a (* already aligned, above *)
                | Nothing -> pos
            end
            in
            (* map out where we plumb in each section, accounting for their alignment *)
            let (end_addr, comp_addrs) = List.foldl (fun (next_free_addr, addr_list) -> (fun comp_el -> match comp_el with
                  IncludeInputSection(retain_pol, fname, shndx, isec, img) -> 
                        let aligned_next_free = align_up next_free_addr isec.elf64_section_align
                        in
                        (aligned_next_free + isec.elf64_section_size, addr_list ++ [aligned_next_free])
                | IncludeCommonSymbol(retain_pol, fname, def, img) -> 
                        let aligned_next_free = align_up next_free_addr (natural_of_elf64_half def.def_syment.elf64_st_shndx)
                        in
                        (aligned_next_free + (natural_of_elf64_xword def.def_syment.elf64_st_size), addr_list ++ [aligned_next_free])
                | Hole(sz) -> (next_free_addr + sz, addr_list ++ [next_free_addr])
            end
            )) (start_addr, []) comp
            in
            let size = end_addr - start_addr
            in
            let _ = Missing_pervasives.outln (
                (space_padded_and_maybe_newline 16 secname) ^ (if List.null comp then "" else
                    ("0x" ^ (left_zero_padded_to 16 (hex_string_of_natural start_addr))) ^ 
                    (left_space_padded_to 10 ("0x" ^ (hex_string_of_natural size)))
                )
            )
            in
            let concatenated_content = List.foldl (fun accum_pat -> (fun (comp_el, comp_addr) ->
                let (comp_el_pat, namestr, addrstr, szstr, rhs) = match comp_el with
                    IncludeInputSection(retainpolicy, fname, shndx, isec, img) -> 
                        (* We want to get the input section as a byte pattern *)
                        let maybe_secname = elf_memory_image_element_coextensive_with_section shndx img 
                        in
                        match maybe_secname with
                            Nothing -> failwith "impossible: no such section"
                            | Just idstr -> match Map.lookup idstr img.elements with
                                Just el -> (el.contents, isec.elf64_section_name_as_string, 
                                    hex_string_of_natural comp_addr, 
                                    hex_string_of_natural isec.elf64_section_size,
                                    fname)
                                | _     -> failwith "impossible: no such element"
                            end
                        end
                    | IncludeCommonSymbol(retain_pol, fname, def, img) -> 
                        (* We want to get the common symbol as a byte pattern *)
                        let sz = natural_of_elf64_xword def.def_syment.elf64_st_size
                        in
                        let content = Missing_pervasives.replicate sz (Just(byte_of_natural 0))
                        in
                        (content, "COMMON", 
                             hex_string_of_natural comp_addr, 
                             hex_string_of_natural sz,
                             fname)
                    | Hole(sz) -> 
                        let content = Missing_pervasives.replicate sz Nothing
                        in 
                        (content, "*fill*", 
                             hex_string_of_natural comp_addr, 
                             hex_string_of_natural sz,
                             "")
                end
                in
                let _ = Missing_pervasives.outln (
                    (space_padded_and_maybe_newline 16 (" " ^ namestr)) ^ ("0x" ^ (left_zero_padded_to 16 addrstr)) ^ (left_space_padded_to 10 ("0x" ^ szstr)) ^ " " ^ rhs
                )
                in
                append_to_byte_pattern_at_offset (comp_addr - start_addr) accum_pat comp_el_pat
            )) [] (zip comp comp_addrs)
            in
            let concat_sec_el = <|
                Memory_image.startpos = Just(start_addr)
              ; Memory_image.length   = Just(size)
              ; Memory_image.contents = concatenated_content
            |>
            in
            (* make a new element in the image *)
            (start_addr + size, <|
                elements   = Map.insert secname concat_sec_el acc_img.elements
                (* tag it as a section, and transfer any tags *)
             ;  by_range   = acc_img.by_range (* FIXME *)
             ;  by_tag     = acc_img.by_tag   (* FIXME *)
             |>,
                (guard, Just(start_addr), secname, comp)
             )
        )
    in
    match script with
        [] -> (acc, outputs_by_name)
        | element :: more_elements ->
             let do_nothing = (acc, pos, outputs_by_name) in 
             let (new_acc, new_pos, new_outputs_by_name) = 
             match element with
                DefineSymbol(symdefpol, name, (symsize, syminfo, symother)) -> do_nothing
                | AdvanceAddress(advance_fn) -> 
                    let new_pos = advance_fn pos outputs_by_name
                    in
                    (acc, new_pos, outputs_by_name)
                    (* FIXME: the allocated sections map is the subset of the outputs_by_name map 
                     * that has been allocated -- meaning *both* sized *and* placed. 
                     * Since we're a multi-pass interpreter, we've sized everything already, but 
                     * only a subset has been placed. So we need to weed out all elements from
                     * outputs_by_name that don't correspond to a section in the accumulated image.
                     * We should probably include the section's range_tag in the allocated_sections_map,
                     * which would force us to do this, but at the moment neither of these is done. *)
                | MarkAndAlignDataSegment(maxpagesize, commonpagesize) -> 
                    (* GNU linker manual says:
                    
                    "DATA_SEGMENT_ALIGN(MAXPAGESIZE, COMMONPAGESIZE)
                            is equivalent to either
                           (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - 1)))
                      or
                           (ALIGN(MAXPAGESIZE) + (. & (MAXPAGESIZE - COMMONPAGESIZE)))
                      depending on whether the latter uses fewer COMMONPAGESIZE sized
                      pages for the data segment (area between the result of this
                      expression and `DATA_SEGMENT_END') than the former or not.  If the
                      latter form is used, it means COMMONPAGESIZE bytes of runtime
                      memory will be saved at the expense of up to COMMONPAGESIZE wasted
                      bytes in the on-disk file."
                      
                        In other words, we're marking the beginning of the data segment
                        by aligning our position upwards by an amount that 
                        
                        - guarantees we're on a new page
                        
                        - depends on where the data segment *ends* , trying 
                          to avoid wasting too much space or memory.
                          
                        Note that intervening commands can do arbitrary things to the location
                        counter, so we can't do any short-cut arithmetic based on section sizes;
                        we actually have to run the layout procedure til we hit the end of the 
                        data segment, and then see how we do. 
                        
                        We run this function *forward* with the first option on a subset
                        of the script ending with the end of the data segment.
                        We then see what comes back. 
                    
                     *)
                    (* let num_pages_used *)
                    do_nothing
                | MarkDataSegmentEnd -> do_nothing
                | MarkDataSegmentRelroEnd(align_and_expr_fun) -> do_nothing
                | OutputSection(outputguard, maybe_expr, name, sub_elements) -> 
                    (* Get the composition we computed earlier, and actually put it in
                     * the image, assigning an address to it. *)
                    let maybe_found = Map.lookup name outputs_by_name
                    in
                    let found = match maybe_found with
                        Just f -> f
                        | Nothing -> failwith "internal error: output section not found"
                    end
                    in
                    let (new_pos, new_acc, replacement_output_sec) = add_output_section (pos, acc) found
                    in
                    (new_acc, new_pos, Map.insert name replacement_output_sec (Map.delete name outputs_by_name))
                | DiscardInput(selector) -> do_nothing
                | InputQuery(retainpol, sortpol, selector) -> do_nothing
            end
            in
            build_image new_acc new_pos new_outputs_by_name more_elements
    end

let rec consecutive_commons rev_acc l = 
    match l with
    [] -> reverse rev_acc
    | IncludeCommonSymbol(pol, fname, def, img) :: rest -> 
        consecutive_commons ((pol, fname, def, img) :: rev_acc) rest
    | _ -> reverse rev_acc
end

val interpret_linker_control_script : 
    linker_control_script
    -> abi any_abi_feature
    -> list input_spec 
    -> elf_memory_image
let interpret_linker_control_script script a inputs = 
    let (discards, outputs) = assign_inputs_to_output_sections ([], []) inputs Nothing Nothing script
    in
    let outputs_by_name = 
        (let insert_fun = fun m -> (fun (guard, maybe_addr, name, compos) -> Map.insert name (guard, maybe_addr, name, compos) m)
        in
        List.foldl insert_fun Map.empty outputs)
    in
    (* Print the link map's "discarded input sections" output. *)
    let _ = Missing_pervasives.outln "Discarded input sections\n"
    in
    let discard_line = fun i -> (match i with
        InputSection(s) -> 
            let lpadded_secname = (" " ^ s.secname)
            in
            lpadded_secname ^ (space_padding_and_maybe_newline 16 lpadded_secname) ^ "0x0000000000000000" (* FIXME *)
            ^ "        0x" ^ (hex_string_of_natural s.isec.elf64_section_size) ^ " "
            ^ s.fname ^ "\n"
        | Common(symname, img, def) -> "" (* don't print discard lines for discarded commons *)
    end)
    in
    let _ = Missing_pervasives.outs (List.foldl (fun str -> (fun input -> (str ^ (discard_line input)))) "" (reverse discards))
    in
    let outputs_by_name_after_gc = compute_def_use_and_gc outputs_by_name
    in
    let _ = Missing_pervasives.outs "Memory Configuration\n\nName             Origin             Length             Attributes\n*default*        0x0000000000000000 0xffffffffffffffff\n\n"
    in
    let _ = Missing_pervasives.outln "Linker script and memory map\n"
    in
    (* FIXME: print LOAD and START_GROUP trace *)
    let (img, outputs_by_name_with_position) = build_image empty_elf_memory_image 0 outputs_by_name_after_gc script
    in
    (* The link map output for the section/address assignment basically mirrors our notion of 
     * output section composition.  In the following:
     
                0x0000000000400000                PROVIDE (__executable_start, 0x400000)
                0x0000000000400190                . = (0x400000 + SIZEOF_HEADERS)

.interp
 *(.interp)

.note.ABI-tag   0x0000000000400190       0x20
 .note.ABI-tag  0x0000000000400190       0x20 crt1.o

.note.gnu.build-id
                0x00000000004001b0       0x24
 *(.note.gnu.build-id)
 .note.gnu.build-id
                0x00000000004001b0       0x24 crt1.o

.hash
 *(.hash)

.gnu.hash
 *(.gnu.hash)

... we can see that 

        - symbol provision, holes and output sections all get lines
        
        - each output section appears with its name left-aligned, and its address,
             if any, appearing afterwards; if so, the section's total size also follows.
        
        - each input query is printed verbatim, e.g. "*(.note.gnu.build-id)"
        
        - underneath this, a line is printed for each input section that was included,
             with its address and size. This can spill onto a second line in the usual way.
        
        - holes are shown as "*fill*"
        
        - provided symbols are shown as in the linker script source.
        
    PROBLEM: we don't have the script in source form, so we can't print the queries verbatim.
    I should really annotate each query with its source form; when the script is parsed from source,
    this can be inserted automatically. For the moment, what to do? I could annotate each script
    element manually. For the moment, for diffing purposes, filter out lines with asterisks.
     
     *)
    img

    (* What is the output of a linker script?
     * Recall that we need multiple passes:
     * 
     * 1. enumerate output sections
                       + their constituent input sections
                              + the *input* sections' attributes (keep; others?)
                       + symbols defined in the script, with attributes (hidden, provide-or-...)
              
              ** we haven't yet calculated addresses
              ** ... because some input sections might go away on GC
              ** in this step, what do we *eliminate* from the input language?
                     -- input queries, I suppose
                     -- sorting (we can put sections in order)
                     
            memory image interpretation:
            - label all input sections/commons with 
                  output section name   (or "orphan" or "discard")
            - instantiate all output sections in the output memory image
                  with vague address (a fresh symbolic value) and vague length
            - symbolify address assignments/advancements in the script
                  --- this labelling is a key part of the link map!
                  --- what do we label? ideally don't want to label input sections
                          -- the start of output sections *only*
                          -- holes in input sections
            - 

     * 2. optionally do GC; erase now-unneeded input sections & attributes
     * 
     * 3. place orphans?
     * 
     * 4. fix address assignments (including data segment alignment)
     * 
     * This function just does the first one. It creates the output memory image
     * and labels it with all the information that is directly embodied in the script.
     * We can do this by recursing down the script, accumulating the image as we go.
     *)

(* 
val place_orphans :                  elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val section_gc :                     elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val concretise_addresses :           elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val remove_algorithm_features  :     elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val generate_missing_abi_features :  elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val generate_missing_file_features : elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val remove_non_output_features :     elf_memory_image 'abifeature -> elf_memory_image 'abifeature
val to_elf_file :                    elf_memory_image 'abifeature -> elf64_file
*)
