open import Num

type integer_bit_width
  = I8        (** Signed 8 bit *)
  | I12
  | U12       (** Unsigned 12 bit *)
  | Low14
  | U15       (** Unsigned 15 bit *)
  | I15
  | I16       (** Signed 16 bit *)
  | Half16ds
  | I20       (** Signed 20 bit *)
  | Low24
  | I27
  | Word30
  | I32       (** Signed 32 bit *)
  | I48       (** Signed 48 bit *)
  | I64       (** Signed 64 bit *)
  | I64X2     (** Signed 128 bit *)
  | U16       (** Unsigned 16 bit *)
  | U24       (** Unsigned 24 bit *)
  | U32       (** Unsigned 32 bit *)
  | U48       (** Unsigned 48 bit *)
  | U64       (** Unsigned 64 bit *)
  
val natural_of_integer_bit_width : integer_bit_width -> natural
let natural_of_integer_bit_width i =
  match i with
    | I8       -> 8
    | I12      -> 12
    | U12      -> 12
    | Low14    -> 14
    | I15      -> 15
    | U15      -> 15
    | I16      -> 16
    | Half16ds -> 16
    | U16      -> 16
    | I20      -> 20
    | Low24    -> 24
    | U24      -> 24
    | I27      -> 27
    | Word30   -> 30
    | I32      -> 32
    | U32      -> 32
    | I48      -> 48
    | U48      -> 48
    | I64      -> 64
    | U64      -> 64
    | I64X2    -> 128
  end
  
type relocation_operator
  = TPRel
  | LTOff
  | DTPMod
  | DTPRel
  | Page
  | GDat
  | G
  | GLDM
  | GTPRel
  | GTLSDesc
  | Delta
  | LDM
  | TLSDesc
  | Indirect
  | Lo
  | Hi
  | Ha
  | Higher
  | HigherA
  | Highest
  | HighestA
  
type relocation_operator2 =
  | GTLSIdx
  
type relocation_operator_expression 'a
  = Lift   of 'a
  | Apply  of (relocation_operator * relocation_operator_expression 'a)
  | Apply2 of (relocation_operator2 * relocation_operator_expression 'a * relocation_operator_expression 'a)
  | Plus   of (relocation_operator_expression 'a * relocation_operator_expression 'a)
  | Minus  of (relocation_operator_expression 'a * relocation_operator_expression 'a)
  | RShift of (relocation_operator_expression 'a * natural)
  
(** Some relocations may fail, for example:
  * Page 58, Power ABI: relocation types whose Field column is marked with an
  * asterisk are subject to failure is the value computed does not fit in the
  * allocated bits.  [can_fail] type passes this information back to the caller
  * of the relocation application function.
  *)
type can_fail 'a
  = CanFail                       (** [CanFail] signals a potential failing relocation calculation when width constraints are invalidated *)
  | CanFailOnTest of ('a -> bool) (** [CanFailOnTest p] signals a potentially failing relocation calculation when predicate [p] on the result of the calculation returns [false] *)
  | CannotFail                    (** [CannotFail] states the relocation calculation cannot fail and bit-width constraints should be ignored *)
