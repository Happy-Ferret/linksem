(** [abi_aarch64_le] contains top-level definition for the AArch64 ABI (little-endian case).
  *)

open import Basic_classes
open import Bool
open import List
open import Num
open import Maybe

open import Error
open import Missing_pervasives

open import Elf_header
open import Elf_types_native_uint
open import Elf_file
open import Elf_interpreted_segment
open import Elf_interpreted_section

open import Endianness
open import Elf_memory_image
open import Abi_aarch64_relocation
open import Abi_aarch64_le_elf_header

(** [abi_aarch64_le_compute_program_entry_point segs entry] computes the program
  * entry point using ABI-specific conventions.  On AArch64 the entry point in
  * the ELF header ([entry] here) is the real entry point.  On other ABIs, e.g.
  * PowerPC64, the entry point [entry] is a pointer into one of the segments
  * constituting the process image (passed in as [segs] here for a uniform
  * interface).
  *)
val abi_aarch64_le_compute_program_entry_point : list elf64_interpreted_segments -> elf64_addr -> error elf64_addr
let abi_aarch64_le_compute_program_entry_point segs entry =
	return entry

val header_is_aarch64_le : elf64_header -> bool
let header_is_aarch64_le h = 
    null_abi.is_valid_elf_header h
    && List.index h.elf64_ident (unsafe_nat_of_natural elf_ii_data) = Just (unsigned_char_of_natural elf_data_2lsb)
    && is_valid_abi_aarch64_le_machine_architecture (natural_of_elf64_half h.elf64_machine)
    && is_valid_abi_aarch64_le_magic_number h.elf64_ident
    
type aarch64_le_abi_feature = GOT | PLT (* placeholder / FIXME *)

val abiFeatureCompare : aarch64_le_abi_feature -> aarch64_le_abi_feature -> Basic_classes.ordering
let abiFeatureCompare k1 k2 = 
    match (k1, k2) with
        (GOT, GOT) -> EQ
        | (PLT, PLT) -> EQ
        (* what compares LT? *)
        | (GOT, _) -> LT
        (* else it's GT *)
        | (_, _) -> GT
    end

instance (SetType aarch64_le_abi_feature)
    let setElemCompare = abiFeatureCompare
end

val section_is_special : elf64_interpreted_section -> elf_memory_image -> bool
let section_is_special s f = 
    elf_section_is_special s f || (* FIXME *) false

val sysv_aarch64_le_std_abi : abi
let sysv_aarch64_le_std_abi = 
   <| is_valid_elf_header = header_is_aarch64_le
    ; reloc = fun r -> (width_of_aarch64_relocation r, fun _ -> Nothing)
    ; section_is_special = section_is_special
    ; section_is_large = (fun _ -> (fun _ -> false))
    ; maxpagesize = null_abi.maxpagesize
    ; minpagesize = null_abi.minpagesize
    ; commonpagesize = null_abi.commonpagesize
    |>
