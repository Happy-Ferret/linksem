(** [abi_amd64] contains top-level definition for the AMD64 ABI.
  *)

open import Basic_classes
open import Bool
open import List
open import Num
open import Maybe
open import Error
open import Map
open import Assert_extra

open import Missing_pervasives
open import Elf_header
open import Elf_types_native_uint
open import Elf_file
open import Elf_interpreted_segment
open import Elf_interpreted_section

open import Endianness
open import Memory_image
(* open import Elf_memory_image *)
open import Abi_amd64_relocation
open import Abi_amd64_elf_header

(** [abi_amd64_compute_program_entry_point segs entry] computes the program
  * entry point using ABI-specific conventions.  On AMD64 the entry point in
  * the ELF header ([entry] here) is the real entry point.  On other ABIs, e.g.
  * PowerPC64, the entry point [entry] is a pointer into one of the segments
  * constituting the process image (passed in as [segs] here for a uniform
  * interface).
  *)
val abi_amd64_compute_program_entry_point : list elf64_interpreted_segments -> elf64_addr -> error elf64_addr
let abi_amd64_compute_program_entry_point segs entry =
	return entry

val header_is_amd64 : elf64_header -> bool
let header_is_amd64 h =  
    null_abi_concrete.is_valid_elf_header h
    && List.index h.elf64_ident (unsafe_nat_of_natural elf_ii_data) = Just (unsigned_char_of_natural elf_data_2lsb)
    && is_valid_abi_amd64_machine_architecture (natural_of_elf64_half h.elf64_machine)
    && is_valid_abi_amd64_magic_number h.elf64_ident

let shf_x86_64_large : natural = (256 * 1048576) (* 0x10000000 a.k.a. 2^28 *)

type amd64_abi_feature = 
    GOT 
    | PLT (* placeholder / FIXME *)
    
val amd64AbiFeatureConstructorToNaturalList : amd64_abi_feature -> list natural
let amd64AbiFeatureConstructorToNaturalList af = match af with
    GOT -> [0]
    | PLT -> [1]
end

val abiFeatureCompare : amd64_abi_feature -> amd64_abi_feature -> Basic_classes.ordering
let abiFeatureCompare f1 f2 = 
    match (amd64AbiFeatureConstructorToNaturalList f1, amd64AbiFeatureConstructorToNaturalList f2) with
        ([], []) -> failwith "impossible: ABI feature has empty natural list (case 0)"
    |   (_, [])  -> failwith "impossible: ABI feature has empty natural list (case 1)"
    |   ([], _)  -> failwith "impossible: ABI feature has empty natural list (case 2)"
    |   ((hd1 :: tl1), (hd2 :: tl2)) -> 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                match (f1, f2) with
                    (GOT, GOT) -> EQ
                    | (PLT, PLT) -> EQ
                    | _ -> failwith "impossible: tag constructors not equal but natural list heads were equal"
                end
    end

instance (Ord amd64_abi_feature)
    let compare = abiFeatureCompare
    let (<) = fun f1 -> (fun f2 -> (abiFeatureCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (abiFeatureCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (abiFeatureCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (abiFeatureCompare f1 f2) {GT; EQ})
end

instance (ToNaturalList amd64_abi_feature)
    let toNaturalList = amd64AbiFeatureConstructorToNaturalList
end

val section_is_special : forall 'abifeature. elf64_interpreted_section -> annotated_memory_image 'abifeature -> bool
let section_is_special s img = 
    elf_section_is_special s img ||
    match s.elf64_section_name_as_string with 
        ".eh_frame" -> true (* HACK needed because SHT_X86_64_UNWIND is often not used *)
       | _ -> false
    end

val sysv_amd64_std_abi : forall 'abifeature. abi 'abifeature
let sysv_amd64_std_abi = 
   <| is_valid_elf_header = header_is_amd64
    ; reloc = fun r -> (width_of_x86_64_relocation r, fun _ -> Nothing)
    ; section_is_special = section_is_special
    ; section_is_large = (fun s -> (fun f -> flag_is_set shf_x86_64_large s.elf64_section_flags))
    ; maxpagesize = 65536
    ; minpagesize = 4096
    ; commonpagesize = 4096
    |>

instance (SetType amd64_abi_feature)
    let setElemCompare = abiFeatureCompare
end
