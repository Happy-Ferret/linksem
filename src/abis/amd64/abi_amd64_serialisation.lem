open import Basic_classes
open import List
open import Num

open import Byte_sequence

open import Elf_header
open import Elf_program_header_table
open import Elf_section_header_table
open import Elf_types

open import Abi_amd64_elf_header

(** [abi_amd64_elf_ident abi_version] produces the ELF identification field for
  * the ELF header based on ABI-specific information and the [abi_version]
  * argument passed in.
  *)
val abi_amd64_elf_ident : natural -> list unsigned_char
let abi_amd64_elf_ident abi_version =
  List.map unsigned_char_of_int32 
    [127; 69; 76; 70; (* 127 E L F *)
     unsafe_int32_of_natural abi_amd64_file_class; unsafe_int32_of_natural abi_amd64_data_encoding; unsafe_int32_of_natural abi_amd64_file_version;
     unsafe_int32_of_natural elf_osabi_none; unsafe_int32_of_natural abi_version; 0;
     0; 0; 0;
     0; 0; 0]

(** [abi_amd64_generate_elf_header entry phoff phnum] produces an ELF header for
  * 64-bit PPC ELF files.  The function expects the [entry] address to start
  * execution from, the offset of the program header table in [phoff] and the
  * number of entries in the program header table in [phnum].
  *)
val abi_amd64_generate_elf_header : elf64_addr -> elf64_off -> elf64_half -> elf64_header
let abi_amd64_generate_elf_header entry phoff phnum =
  <| elf64_ident      = abi_amd64_elf_ident 0;
      elf64_type      = elf64_half_of_int32 (unsafe_int32_of_natural elf_ft_exec);
      elf64_machine   = elf64_half_of_int32 (unsafe_int32_of_natural elf_ma_x86_64);
      elf64_version   = elf64_word_of_int32 (unsafe_int32_of_natural elf_ev_current);
      elf64_entry     = entry;
      elf64_phoff     = phoff;
      elf64_shoff     = elf64_off_of_int64 0;
      elf64_flags     = elf64_word_of_int32 0;
      elf64_ehsize    = elf64_half_of_int32 64;
      elf64_phentsize = elf64_half_of_int32 56;
      elf64_phnum     = phnum;
      elf64_shentsize = elf64_half_of_int32 0;
      elf64_shnum     = elf64_half_of_int32 0;
      elf64_shstrndx  = elf64_half_of_int32 (unsafe_int32_of_natural shn_undef) |>
(*
  <| elf64_p_type   : elf64_word  (** Type of the segment *)
   ; elf64_p_flags  : elf64_word  (** Segment flags *)
   ; elf64_p_offset : elf64_off   (** Offset from beginning of file for segment *)
   ; elf64_p_vaddr  : elf64_addr  (** Virtual address for segment in memory *)
   ; elf64_p_paddr  : elf64_addr  (** Physical address for segment *)
   ; elf64_p_filesz : elf64_xword (** Size of segment in file, in bytes *)
   ; elf64_p_memsz  : elf64_xword (** Size of segment in memory image, in bytes *)
   ; elf64_p_align  : elf64_xword (** Segment alignment memory for memory and file *)
   |>
*)
val abi_amd64_generate_null_program_header : elf64_program_header_table_entry
let abi_amd64_generate_null_program_header =
  <| elf64_p_type = elf64_word_of_int32 (unsafe_int32_of_natural elf_pt_null);
      elf64_p_flags = elf64_word_of_int32 0; elf64_p_offset = elf64_off_of_int64 0;
      elf64_p_vaddr = elf64_addr_of_int64 0; elf64_p_paddr = elf64_addr_of_int64 0;
      elf64_p_filesz = elf64_xword_of_int64 0; elf64_p_memsz = elf64_xword_of_int64 0;
      elf64_p_align = elf64_xword_of_int64 0 |>

val abi_amd64_generate_program_header_table : elf64_program_header_table
let abi_amd64_generate_program_header_table =
  let null_entry = abi_amd64_generate_null_program_header in
    [null_entry]

(** [abi_amd64_serialise exec_segment] produces byte sequence serialisation of
  * an ELF file based on the executable segment passed to the function
  * in [exec_segment].
  *
  * File layout:
  *    [ ELF Header (fixed size: 64 bytes)     ]
  *    [ Program header table at 64 byte offset]
  *    [ Null segment (0 bytes)                ]
  *    [ exec_segment                          ]
  *)
val abi_amd64_serialise : elf64_addr -> list byte -> byte_sequence
let abi_amd64_serialise entry executable_code =
  let hdr  = abi_amd64_generate_elf_header entry (elf64_off_of_int64 64)
              (elf64_half_of_int32 1) (* 2 = dummy + exec *) in
  let pht  = abi_amd64_generate_program_header_table in
  let exec = Byte_sequence.from_byte_lists [executable_code] in
    Byte_sequence.concat [
      Elf_header.bytes_of_elf64_header hdr
    ; Elf_program_header_table.bytes_of_elf64_program_header_table abi_amd64_endianness pht
    ; exec
    ]