open import Basic_classes
open import List
open import Maybe
open import Num

open import Byte_sequence

open import Elf_executable_file
open import Elf_header
open import Elf_interpreted_segment
open import Elf_program_header_table
open import Elf_section_header_table
open import Elf_types

open import Abi_amd64_elf_header

(** [abi_amd64_elf_ident abi_version] produces the ELF identification field for
  * the ELF header based on ABI-specific information and the [abi_version]
  * argument passed in.
  *)
val abi_amd64_elf_ident : natural -> list unsigned_char
let abi_amd64_elf_ident abi_version =
  List.map unsigned_char_of_int32 
    [127; 69; 76; 70; (* 127 E L F *)
     unsafe_int32_of_natural abi_amd64_file_class; unsafe_int32_of_natural abi_amd64_data_encoding; unsafe_int32_of_natural abi_amd64_file_version;
     unsafe_int32_of_natural elf_osabi_none; unsafe_int32_of_natural abi_version; 0;
     0; 0; 0;
     0; 0; 0]

(** [abi_amd64_generate_elf_header entry phoff phnum] produces an ELF header for
  * 64-bit PPC ELF files.  The function expects the [entry] address to start
  * execution from, the offset of the program header table in [phoff] and the
  * number of entries in the program header table in [phnum].
  *)
val abi_amd64_generate_elf_header : elf64_addr -> elf64_off -> elf64_half -> elf64_header
let abi_amd64_generate_elf_header entry phoff phnum =
  <| elf64_ident     = abi_amd64_elf_ident 0;
     elf64_type      = elf64_half_of_int32 (unsafe_int32_of_natural elf_ft_exec);
     elf64_machine   = elf64_half_of_int32 (unsafe_int32_of_natural elf_ma_x86_64);
     elf64_version   = elf64_word_of_int32 (unsafe_int32_of_natural elf_ev_current);
     elf64_entry     = entry;
     elf64_phoff     = phoff;
     elf64_shoff     = elf64_off_of_int64  0;
     elf64_flags     = elf64_word_of_int32 0;
     elf64_ehsize    = elf64_half_of_int32 64;
     elf64_phentsize = elf64_half_of_int32 56;
     elf64_phnum     = phnum;
     elf64_shentsize = elf64_half_of_int32 0;
     elf64_shnum     = elf64_half_of_int32 0;
     elf64_shstrndx  = elf64_half_of_int32 (unsafe_int32_of_natural shn_undef)
  |>

val int32_of_bool : bool -> int32
let int32_of_bool b =
  match b with
    | true  -> 1
    | false -> 0
  end

val elf64_pack_segment_flags : (bool * bool * bool) -> elf64_word
let elf64_pack_segment_flags (r, w, x) =
  let xflag = 1 * int32_of_bool x in
  let wflag = 2 * int32_of_bool w in
  let rflag = 4 * int32_of_bool r in
    elf64_word_of_int32 (xflag + wflag + rflag)

val elf64_header_size : natural
let elf64_header_size = 64

val elf64_program_header_table_entry_size : natural
let elf64_program_header_table_entry_size = 56

val abi_amd64_generate_program_header_table : elf64_interpreted_segment -> elf64_interpreted_segment -> elf64_interpreted_segment -> elf64_program_header_table
let abi_amd64_generate_program_header_table exec code_heap data_heap =
  (* exec segment and then base *)
  let exec_header =
    <| elf64_p_type   = elf64_word_of_int32 (unsafe_int32_of_natural exec.elf64_segment_type);
       elf64_p_flags  = elf64_pack_segment_flags exec.elf64_segment_flags;
       elf64_p_offset = elf64_off_of_int64 (unsafe_int64_of_natural (elf64_header_size + (elf64_program_header_table_entry_size * 3)));
       elf64_p_vaddr  = elf64_addr_of_int64 (unsafe_int64_of_natural exec.elf64_segment_base);
       elf64_p_paddr  = elf64_addr_of_int64 (unsafe_int64_of_natural exec.elf64_segment_paddr);
       elf64_p_filesz = elf64_xword_of_int64 (unsafe_int64_of_natural exec.elf64_segment_size);
       elf64_p_memsz  = elf64_xword_of_int64 (unsafe_int64_of_natural exec.elf64_segment_size);
       elf64_p_align  = elf64_xword_of_int64 (unsafe_int64_of_natural exec.elf64_segment_align) |>
  in
  let code_heap_header =
    <| elf64_p_type   = elf64_word_of_int32 (unsafe_int32_of_natural code_heap.elf64_segment_type);
       elf64_p_flags  = elf64_pack_segment_flags code_heap.elf64_segment_flags;
       elf64_p_offset = elf64_off_of_int64 (unsafe_int64_of_natural (elf64_header_size + (elf64_program_header_table_entry_size * 3) + exec.elf64_segment_size));
       elf64_p_vaddr  = elf64_addr_of_int64 (unsafe_int64_of_natural code_heap.elf64_segment_base);
       elf64_p_paddr  = elf64_addr_of_int64 (unsafe_int64_of_natural code_heap.elf64_segment_paddr);
       elf64_p_filesz = elf64_xword_of_int64 (unsafe_int64_of_natural code_heap.elf64_segment_size);
       elf64_p_memsz  = elf64_xword_of_int64 (unsafe_int64_of_natural code_heap.elf64_segment_size);
       elf64_p_align  = elf64_xword_of_int64 (unsafe_int64_of_natural code_heap.elf64_segment_align) |>
  in
  let data_heap_header =
    <| elf64_p_type   = elf64_word_of_int32 (unsafe_int32_of_natural data_heap.elf64_segment_type);
       elf64_p_flags  = elf64_pack_segment_flags data_heap.elf64_segment_flags;
       elf64_p_offset = elf64_off_of_int64 (unsafe_int64_of_natural (elf64_header_size + (elf64_program_header_table_entry_size * 3) + exec.elf64_segment_size + code_heap.elf64_segment_size));
       elf64_p_vaddr  = elf64_addr_of_int64 (unsafe_int64_of_natural data_heap.elf64_segment_base);
       elf64_p_paddr  = elf64_addr_of_int64 (unsafe_int64_of_natural data_heap.elf64_segment_paddr);
       elf64_p_filesz = elf64_xword_of_int64 (unsafe_int64_of_natural data_heap.elf64_segment_size);
       elf64_p_memsz  = elf64_xword_of_int64 (unsafe_int64_of_natural data_heap.elf64_segment_size);
       elf64_p_align  = elf64_xword_of_int64 (unsafe_int64_of_natural data_heap.elf64_segment_align) |>
  in
    [exec_header; code_heap_header; data_heap_header]

val abi_amd64_generate_exec_interpreted_segment : natural -> byte_sequence -> elf64_interpreted_segment
let abi_amd64_generate_exec_interpreted_segment entry_point exec_code =
  let segment_size = Byte_sequence.length exec_code in
    <| elf64_segment_body = exec_code; elf64_segment_size = segment_size;
          elf64_segment_memsz = segment_size; elf64_segment_base = entry_point;
          elf64_segment_paddr = entry_point; elf64_segment_align = 4096;
          elf64_segment_flags = (true, false, true); elf64_segment_type = elf_pt_load |>

val abi_amd64_generate_code_heap_interpreted_segment : natural -> natural -> elf64_interpreted_segment
let abi_amd64_generate_code_heap_interpreted_segment entry_point segment_size =
  let seg = Byte_sequence.create segment_size Missing_pervasives.null_char in
    <| elf64_segment_body = seg; elf64_segment_size = segment_size;
        elf64_segment_memsz = segment_size; elf64_segment_base = entry_point;
        elf64_segment_paddr = entry_point; elf64_segment_align = 4096;
        elf64_segment_flags = (true, false, true); elf64_segment_type = elf_pt_load |>

val abi_amd64_generate_data_heap_interpreted_segment : natural -> natural -> elf64_interpreted_segment
let abi_amd64_generate_data_heap_interpreted_segment entry_point segment_size =
  let seg = Byte_sequence.create segment_size Missing_pervasives.null_char in
    <| elf64_segment_body = seg; elf64_segment_size = segment_size;
        elf64_segment_memsz = segment_size; elf64_segment_base = entry_point;
        elf64_segment_paddr = entry_point; elf64_segment_align = 4096;
        elf64_segment_flags = (true, false, false); elf64_segment_type = elf_pt_load |>

val abi_amd64_entry_point_addr : elf64_addr
let abi_amd64_entry_point_addr =
  elf64_addr_of_int64 4194304 (* 0x400000 *)

val abi_amd64_data_heap_addr : elf64_addr
let abi_amd64_data_heap_addr =
  elf64_addr_of_int64 (536870912 * 2) (* 67108864 * 16 *)

val abi_amd64_code_heap_addr : elf64_addr
let abi_amd64_code_heap_addr =
  elf64_addr_of_int64 67108864 (* 16 * 4194304 *)

val byte_of_int : int -> byte

declare ocaml target_rep function byte_of_int = `Char.chr`

val unsafe_int_of_elf64_addr : elf64_addr -> int
let unsafe_int_of_elf64_addr addr =
  unsafe_int_of_natural (natural_of_elf64_addr addr)

val relocation_fixup : byte_sequence
let relocation_fixup =
  let relocation = elf64_addr_minus 
                    (elf64_addr_minus abi_amd64_data_heap_addr abi_amd64_entry_point_addr)
                    (elf64_addr_of_int64 9)
  in
    Byte_sequence.from_byte_lists
    [[ byte_of_int 72
    ; byte_of_int 199
    ; byte_of_int 68
    ; byte_of_int 36
    ; byte_of_int 248
    ; byte_of_int (unsafe_int_of_elf64_addr (elf64_addr_land relocation (elf64_addr_of_int64 255)))
    ; byte_of_int (unsafe_int_of_elf64_addr (elf64_addr_land (elf64_addr_rshift relocation 8) (elf64_addr_of_int64 255)))
    ; byte_of_int (unsafe_int_of_elf64_addr (elf64_addr_land (elf64_addr_rshift relocation 16) (elf64_addr_of_int64 255)))
    ; byte_of_int (unsafe_int_of_elf64_addr (elf64_addr_land (elf64_addr_rshift relocation 24) (elf64_addr_of_int64 255)))
    ; byte_of_int 72
    ; byte_of_int 139
    ; byte_of_int 68
    ; byte_of_int 36
    ; byte_of_int 248
    ]]

val abi_amd64_generate_executable_file : byte_sequence -> natural -> natural -> elf64_executable_file
let abi_amd64_generate_executable_file exec_code data_heap_size code_heap_size =
  let exec_code' = Byte_sequence.concat [relocation_fixup; exec_code] in
  let hdr       = abi_amd64_generate_elf_header abi_amd64_entry_point_addr
                    (elf64_off_of_int64 64) (elf64_half_of_int32 3) in
  let exec      = abi_amd64_generate_exec_interpreted_segment (natural_of_elf64_addr abi_amd64_entry_point_addr) exec_code' in
  let code_heap = abi_amd64_generate_code_heap_interpreted_segment (natural_of_elf64_addr abi_amd64_code_heap_addr) code_heap_size in
  let data_heap = abi_amd64_generate_data_heap_interpreted_segment (natural_of_elf64_addr abi_amd64_data_heap_addr) data_heap_size in
  let pht       = abi_amd64_generate_program_header_table exec code_heap data_heap in
    <| elf64_executable_file_header = hdr; elf64_executable_file_program_header_table = pht;
          elf64_executable_file_interpreted_segments = [exec; code_heap; data_heap];
          elf64_executable_file_interpreted_sections = [];
          elf64_executable_file_section_header_table = [] |>