(** The [abis] module is the top-level module for all ABI related code, including
  * some generic functionality that works across all ABIs, and a primitive attempt
  * at abstracting over ABIs for purposes of linking.
  *)

open import Basic_classes
open import Bool
open import Num
open import Maybe
open import List
open import Assert_extra

open import Elf_file
open import Elf_header
open import Elf_interpreted_section
open import Memory_image
open import Abi_amd64
open import Abi_amd64_relocation
open import Abi_aarch64_le
open import Abi_aarch64_relocation

type any_abi_feature = Amd64AbiFeature of amd64_abi_feature
                     | Aarch64LeAbiFeature of aarch64_le_abi_feature

(* null_abi captures ABI details common to all ELF-based, System V-based systems. *)
val null_abi : abi any_abi_feature 
let (null_abi : abi any_abi_feature) = <|
      is_valid_elf_header = is_valid_elf64_header
    ; reloc = noop_reloc
    ; section_is_special = elf_section_is_special
    ; section_is_large = (fun s -> (fun f -> false))
    ; maxpagesize = 2 * 256 * 4096 (* 2MB; bit of a guess, based on gdb and prelink code *)
    ; minpagesize = 1024 (* bit of a guess again *)
    ; commonpagesize = 4096
    ; symbol_is_generated_by_linker = (fun symname -> symname = "_GLOBAL_OFFSET_TABLE_")
    |>

val sysv_amd64_std_abi : abi any_abi_feature
let sysv_amd64_std_abi = 
   <| is_valid_elf_header = header_is_amd64
    ; reloc = fun r -> (width_of_x86_64_relocation r, fun _ -> Nothing)
    ; section_is_special = section_is_special
    ; section_is_large = (fun s -> (fun f -> flag_is_set shf_x86_64_large s.elf64_section_flags))
    ; maxpagesize = 65536
    ; minpagesize = 4096
    ; commonpagesize = 4096
    ; symbol_is_generated_by_linker = null_abi.symbol_is_generated_by_linker
    |>

val sysv_aarch64_le_std_abi : abi any_abi_feature
let sysv_aarch64_le_std_abi = 
   <| is_valid_elf_header = header_is_aarch64_le
    ; reloc = fun r -> (width_of_aarch64_relocation r, fun _ -> Nothing)
    ; section_is_special = section_is_special
    ; section_is_large = (fun _ -> (fun _ -> false))
    ; maxpagesize = null_abi.maxpagesize
    ; minpagesize = null_abi.minpagesize
    ; commonpagesize = null_abi.commonpagesize
    ; symbol_is_generated_by_linker = null_abi.symbol_is_generated_by_linker
    |>

val all_abis : list (abi any_abi_feature)
let all_abis = [sysv_amd64_std_abi; sysv_aarch64_le_std_abi; null_abi]

(*
val amd64AbiFeatureConstructorToNaturalList : amd64_abi_feature -> list natural
val aarch64AbiFeatureConstructorToNaturalList : aarch64_le_abi_feature -> list natural
*)

val anyAbiFeatureConstructorToNaturalList : any_abi_feature -> list natural
let anyAbiFeatureConstructorToNaturalList af = match af with
    Amd64AbiFeature(aaf) -> 0 :: (amd64AbiFeatureConstructorToNaturalList aaf)
    | Aarch64LeAbiFeature(aaf) -> 1 :: (aarch64LeAbiFeatureConstructorToNaturalList aaf)
end

let anyAbiFeatureCompare f1 f2 = 
    match ((anyAbiFeatureConstructorToNaturalList f1), (anyAbiFeatureConstructorToNaturalList f2)) with
        ([], []) -> failwith "impossible: elf file feature has empty natural list (case 0)"
    |   (_, [])  -> failwith "impossible: elf file feature has empty natural list (case 1)"
    |   ([], _)  -> failwith "impossible: elf file feature has empty natural list (case 2)"
    |   ((hd1 :: tl1), (hd2 :: tl2)) -> 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                match (f1, f2) with
                    (Amd64AbiFeature(x1), Amd64AbiFeature(x2)) -> compare x1 x2
                    | (Aarch64LeAbiFeature(x1), Aarch64LeAbiFeature(x2)) -> compare x1 x2
                    | _ -> failwith "impossible: tag constructors not equal but natural list heads were equal"
                end
    end

instance (Ord any_abi_feature)
    let compare = anyAbiFeatureCompare
    let (<) = fun f1 -> (fun f2 -> (anyAbiFeatureCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (anyAbiFeatureCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (anyAbiFeatureCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (anyAbiFeatureCompare f1 f2) {GT; EQ})
end

let anyAbiFeatureToNaturalList af = match af with 
    Amd64AbiFeature(aaf) -> amd64AbiFeatureConstructorToNaturalList aaf
    |  Aarch64LeAbiFeature(aaf) -> aarch64LeAbiFeatureConstructorToNaturalList aaf
end

instance (ToNaturalList any_abi_feature)
    let toNaturalList = anyAbiFeatureToNaturalList
end
