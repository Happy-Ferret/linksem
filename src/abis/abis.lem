(** The [abis] module is the top-level module for all ABI related code, including
  * some generic functionality that works across all ABIs, and a primitive attempt
  * at abstracting over ABIs for purposes of linking.
  *)

open import Basic_classes
open import Bool
open import Num
open import Maybe
open import List
open import String
open import Show
open import Assert_extra
open import Error
open import Missing_pervasives

open import Elf_file
open import Elf_header
open import Elf_interpreted_section
open import Elf_program_header_table
open import Elf_section_header_table
open import Memory_image

open import Abi_amd64
open import Abi_amd64_relocation

open import Abi_aarch64_le
open import Abi_aarch64_relocation

open import Abi_power64
open import Abi_power64_relocation

open import Abi_utilities
open import Elf_types_native_uint

(** Relocation operators and their validity on a given platform *)

val is_valid_abi_aarch64_relocation_operator : relocation_operator -> bool
let is_valid_abi_aarch64_relocation_operator op =
  match op with
    | Page -> true
    | G -> true
    | GDat -> true
    | GLDM -> true
    | DTPRel -> true
    | GTPRel -> true
    | TPRel -> true
    | GTLSDesc -> true
    | Delta -> true
    | LDM -> true
    | TLSDesc -> true
    | Indirect -> true
    | _ -> false
  end
  
val is_valid_abi_aarch64_relocation_operator2 : relocation_operator2 -> bool
let is_valid_abi_aarch64_relocation_operator2 op =
  match op with
    | GTLSIdx -> true
  end

val is_valid_abi_amd64_relocation_operator : relocation_operator -> bool
let is_valid_abi_amd64_relocation_operator op =
  match op with
    | Indirect -> true
    | _ -> false (* XXX: not sure about this? *)
  end
  
val is_valid_abi_amd64_relocation_operator2 : relocation_operator2 -> bool
let is_valid_abi_amd64_relocation_operator2 op =
  match op with
    | _ -> false
  end

val is_valid_abi_power64_relocation_operator : relocation_operator -> bool
let is_valid_abi_power64_relocation_operator op = false (* TODO *)

val is_valid_abi_power64_relocation_operator2 : relocation_operator2 -> bool
let is_valid_abi_power64_relocation_operator2 op =
  match op with
    | _ -> false
  end

(** Misc. ABI related stuff *)

type any_abi_feature = Amd64AbiFeature of amd64_abi_feature
                     | Aarch64LeAbiFeature of aarch64_le_abi_feature

val anyAbiFeatureToNaturalList : any_abi_feature -> list natural
let anyAbiFeatureToNaturalList f = match f with
    Amd64AbiFeature(af) -> 0 :: (toNaturalList af)
    | Aarch64LeAbiFeature(af) -> 1 :: (toNaturalList af)
end

instance (ToNaturalList any_abi_feature)
    let toNaturalList = anyAbiFeatureToNaturalList
end

val anyAbiFeatureCompare : any_abi_feature -> any_abi_feature -> Basic_classes.ordering
let anyAbiFeatureCompare f1 f2 = 
    match (anyAbiFeatureToNaturalList f1, anyAbiFeatureToNaturalList f2) with
        ([], []) -> failwith "impossible: any-ABI feature has empty natural list (case 0)"
    |   (_, [])  -> failwith "impossible: any-ABI feature has empty natural list (case 1)"
    |   ([], _)  -> failwith "impossible: any-ABI feature has empty natural list (case 2)"
    |   ((hd1 :: tl1), (hd2 :: tl2)) -> 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                match (f1, f2) with
                    (Amd64AbiFeature(af1), Amd64AbiFeature(af2)) -> compare af1 af2
                   |(Aarch64LeAbiFeature(af1), Aarch64LeAbiFeature(af2)) -> compare af1 af2
                   | _ -> failwith "impossible: tag constructors not equal but natural list heads were equal"
                end
    end

instance (Ord any_abi_feature)
    let compare = anyAbiFeatureCompare
    let (<) = fun f1 -> (fun f2 -> (anyAbiFeatureCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (anyAbiFeatureCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (anyAbiFeatureCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (anyAbiFeatureCompare f1 f2) {GT; EQ})
end

let make_elf64_header data osabi abiv ma t entry shoff phoff phnum shnum shstrndx =
      <| elf64_ident    = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3; 
                           unsigned_char_of_natural elf_class_64; 
                           unsigned_char_of_natural data;
                           unsigned_char_of_natural elf_ev_current;
                           unsigned_char_of_natural osabi;
                           unsigned_char_of_natural abiv;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0]
       ; elf64_type     = elf64_half_of_natural t
       ; elf64_machine  = elf64_half_of_natural ma
       ; elf64_version  = elf64_word_of_natural elf_ev_current
       ; elf64_entry    = elf64_addr_of_natural entry
       ; elf64_phoff    = elf64_off_of_natural phoff
       ; elf64_shoff    = elf64_off_of_natural shoff
       ; elf64_flags    = elf64_word_of_natural 0
       ; elf64_ehsize   = elf64_half_of_natural 64
       ; elf64_phentsize= elf64_half_of_natural 56
       ; elf64_phnum    = elf64_half_of_natural phnum
       ; elf64_shentsize= elf64_half_of_natural 64
       ; elf64_shnum    = elf64_half_of_natural shnum
       ; elf64_shstrndx = elf64_half_of_natural shstrndx
       |>

val make_load_phdrs : forall 'abifeature. abi 'abifeature -> annotated_memory_image 'abifeature -> list (natural * elf64_interpreted_section) -> list elf64_program_header_table_entry
let make_load_phdrs a img section_pairs_bare_sorted_by_address = 
    let (phdr_flags_from_section_flags : natural -> string -> natural) = fun section_flags -> fun sec_name ->
        let flags = natural_lor elf_pf_r (natural_lor 
            (if flag_is_set shf_write section_flags then elf_pf_w else 0)
            (if flag_is_set shf_execinstr section_flags then elf_pf_x else 0))
        in
        (*let _ = errln ("Phdr flags of section " ^ sec_name ^ "(ELF section flags 0x " ^ 
            (hex_string_of_natural section_flags) ^ ") are 0x" ^ (hex_string_of_natural flags))
        in*)
        flags
    in
    let maybe_extend_phdr = fun phdr -> fun isec -> ( 
        let new_p_type = natural_of_elf64_word phdr.elf64_p_type
        in
        let section_flags = phdr_flags_from_section_flags isec.elf64_section_flags isec.elf64_section_name_as_string
        in
        let can_combine_flags = fun flagsets -> 
            (* The GNU linker happily adds a .rodata section to a RX segment,
             * but not to a RW segment. So the only clear rule is: if any is writable,
             * all must be writable. *)
            let is_writable = fun flags -> natural_land flags elf_pf_w = elf_pf_w
            in
            let flagslist = Set_extra.toList flagsets
            in
            let union_flags = List.foldl natural_lor 0 flagslist
            in
            if List.any is_writable flagslist
            then
                if List.all is_writable flagslist then Just union_flags
                else Nothing
            else
                Just union_flags
        in
        let maybe_extended = can_combine_flags { section_flags; natural_of_elf64_word phdr.elf64_p_flags }
        in
        if maybe_extended = Nothing then (*let _ = errln "flag mismatch" in*) Nothing
        else let new_p_flags = match maybe_extended with Just flags -> flags | _ -> failwith "impossible" end in
        let new_p_offset = natural_of_elf64_off phdr.elf64_p_offset
        in
        let new_p_vaddr = natural_of_elf64_addr phdr.elf64_p_vaddr
        in
        let new_p_paddr = natural_of_elf64_addr phdr.elf64_p_paddr in
        (* The new filesz is the file end offset of this section,
         * minus the existing file start offset of the phdr. 
         * Check that the new section begins after the old offset+filesz. *)
        if isec.elf64_section_offset < (natural_of_elf64_off phdr.elf64_p_offset) + (natural_of_elf64_xword phdr.elf64_p_filesz)
        then (*let _ = errln "offset went backwards" in*) Nothing
        else 
        let new_p_filesz = isec.elf64_section_offset + (if isec.elf64_section_type = sht_progbits then isec.elf64_section_size else 0)
        - natural_of_elf64_off phdr.elf64_p_offset
        in 
        (* The new memsz is the virtual address end address of this section,
         * minus the existing start vaddr of the phdr. 
         * Check that the new section begins after the old vaddr+memsz. *)
        if isec.elf64_section_addr < (natural_of_elf64_addr phdr.elf64_p_vaddr) + (natural_of_elf64_xword phdr.elf64_p_memsz)
        then (*let _ = errln "vaddr went backwards" in*) Nothing
        else 
        let new_p_memsz = isec.elf64_section_addr + isec.elf64_section_size - natural_of_elf64_addr phdr.elf64_p_vaddr
        in
        let (one_if_zero : natural -> natural) = fun n -> if n = 0 then 1 else n
        in
        let new_p_align =  lcm (one_if_zero (natural_of_elf64_xword phdr.elf64_p_align)) (one_if_zero isec.elf64_section_align)
        in
        Just
          <| elf64_p_type   = elf64_word_of_natural new_p_type
           ; elf64_p_flags  = elf64_word_of_natural new_p_flags
           ; elf64_p_offset = elf64_off_of_natural new_p_offset
           ; elf64_p_vaddr  = elf64_addr_of_natural new_p_vaddr
           ; elf64_p_paddr  = elf64_addr_of_natural new_p_paddr
           ; elf64_p_filesz = elf64_xword_of_natural new_p_filesz
           ; elf64_p_memsz  = elf64_xword_of_natural new_p_memsz
           ; elf64_p_align  = elf64_xword_of_natural new_p_align
           |>
    )
    in
    let new_phdr = fun isec -> 
      <| elf64_p_type   = elf64_word_of_natural elf_pt_load (** Type of the segment *)
       ; elf64_p_flags  = elf64_word_of_natural (phdr_flags_from_section_flags isec.elf64_section_flags isec.elf64_section_name_as_string) (** Segment flags *)
       ; elf64_p_offset = elf64_off_of_natural (round_down_to a.commonpagesize isec.elf64_section_offset) (** Offset from beginning of file for segment *)
       ; elf64_p_vaddr  = elf64_addr_of_natural (round_down_to a.commonpagesize isec.elf64_section_addr) (** Virtual address for segment in memory *)
       ; elf64_p_paddr  = elf64_addr_of_natural 0 (** Physical address for segment *)
       ; elf64_p_filesz = elf64_xword_of_natural (if isec.elf64_section_type = sht_nobits then 0 else isec.elf64_section_size) (** Size of segment in file, in bytes *)
       ; elf64_p_memsz  = elf64_xword_of_natural isec.elf64_section_size (** Size of segment in memory image, in bytes *)
       ; elf64_p_align  = elf64_xword_of_natural (* isec.elf64_section_align *) a.maxpagesize (** Segment alignment memory for memory and file *)
       |>
    in
    (* accumulate sections into the phdr *)
    let rev_list = List.foldl (fun accum_phdr_list -> (fun (idx, isec) -> (
        (* Do we have a current phdr? *)
        match accum_phdr_list with
            [] -> (* no, so make one *)
                (*let _ = errln ("Starting the first LOAD phdr for section " ^ isec.elf64_section_name_as_string)
                in*)
                [new_phdr isec]
            | current_phdr :: more -> 
                (* can we extend it with the current section? *)
                match maybe_extend_phdr current_phdr isec with
                    Nothing -> 
                        (*let _ = errln ("Starting new LOAD phdr for section " ^ isec.elf64_section_name_as_string)
                        in*)
                        (new_phdr isec) :: current_phdr :: more
                    | Just phdr -> phdr :: more
                end
        end
    ))) [] (List.filter (fun (idx, isec) -> flag_is_set shf_alloc isec.elf64_section_flags) section_pairs_bare_sorted_by_address)
    in
    (*let _ = errln "Successfully made phdrs"
    in*)
    List.reverse rev_list
    
val make_default_phdrs : forall 'abifeature. abi 'abifeature -> natural (* file type *) -> annotated_memory_image 'abifeature -> list (natural * elf64_interpreted_section) -> list elf64_program_header_table_entry
let make_default_phdrs a t img section_pairs_bare_sorted_by_address = 
    (* FIXME: do the shared object and dyn. exec. stuff too *)
    make_load_phdrs a img section_pairs_bare_sorted_by_address

val find_start_symbol_address : forall 'abifeature. Ord 'abifeature, ToNaturalList 'abifeature => annotated_memory_image 'abifeature -> maybe natural
let find_start_symbol_address img = 
    (* Do we have a symbol called "_start"? *)
    let all_defs = Memory_image_orderings.defined_symbols_and_ranges img
    in
    let get_entry_point = (fun (maybe_range, symbol_def) -> 
        if symbol_def.def_symname = "_start"
        then Just (maybe_range, symbol_def) 
        else Nothing
    )
    in
    let all_entry_points = List.mapMaybe get_entry_point all_defs
    in
    match all_entry_points with
        [(maybe_range, symbol_def)] ->
            match maybe_range with
                Just (el_name, (el_off, len)) -> 
                    match Map.lookup el_name img.elements with
                        Nothing -> failwith ("_start symbol defined in nonexistent element `" ^ el_name ^ "'")
                        | Just el_rec -> 
                            match el_rec.startpos with
                                Nothing -> (*let _ = Missing_pervasives.errln "warning: saw `_start' in element with no assigned address" in *)Nothing
                                | Just x -> (* success! *) Just (x + el_off)
                            end
                    end
                | _ -> (*let _ = Missing_pervasives.errln "warning: `_start' symbol with no range" in*) Nothing
            end
        | [] -> (* no _start symbol *) Nothing
        | _ -> (*let _ = Missing_pervasives.errln ("warning: saw multiple `_start' symbols: " ^
            (let (ranges, defs) = unzip all_entry_points in show ranges)) in *)Nothing
    end

val pad_zeroes : natural -> list byte
let pad_zeroes n = replicate n (byte_of_natural 0)

val pad_0x90 : natural -> list byte
let pad_0x90 n = replicate n (byte_of_natural (9 * 16))

(* null_abi captures ABI details common to all ELF-based, System V-based systems.
 * HACK: for now, specialise to 64-bit ABIs. *)
val null_abi : abi any_abi_feature 
let (null_abi : abi any_abi_feature) = <|
      is_valid_elf_header = is_valid_elf64_header
    ; make_elf_header = make_elf64_header elf_data_2lsb elf_osabi_none 0 elf_ma_none
    ; reloc = noop_reloc
    ; section_is_special = elf_section_is_special
    ; section_is_large = (fun s -> (fun f -> false))
    ; maxpagesize = 2 * 256 * 4096 (* 2MB; bit of a guess, based on gdb and prelink code *)
    ; minpagesize = 1024 (* bit of a guess again *)
    ; commonpagesize = 4096
    ; symbol_is_generated_by_linker = (fun symname -> symname = "_GLOBAL_OFFSET_TABLE_")
    ; make_phdrs = make_default_phdrs
    ; max_phnum = 2
    ; guess_entry_point = find_start_symbol_address
    ; pad_data = pad_zeroes
    ; pad_code = pad_zeroes
    |>

val sysv_amd64_std_abi : abi any_abi_feature
let sysv_amd64_std_abi = 
   <| is_valid_elf_header = header_is_amd64
    ; make_elf_header = make_elf64_header elf_data_2lsb elf_osabi_none 0 elf_ma_x86_64
    ; reloc = amd64_reloc
    ; section_is_special = section_is_special
    ; section_is_large = (fun s -> (fun f -> flag_is_set shf_x86_64_large s.elf64_section_flags))
    ; maxpagesize = 65536
    ; minpagesize = 4096
    ; commonpagesize = 4096
      (* XXX: DPM, changed from explicit reference to null_abi field due to problems in HOL4. *)
    ; symbol_is_generated_by_linker = (fun symname -> symname = "_GLOBAL_OFFSET_TABLE_")
    ; make_phdrs = make_default_phdrs
    ; max_phnum = 4
    ; guess_entry_point = find_start_symbol_address
    ; pad_data = pad_zeroes
    ; pad_code = pad_0x90
    |>

val sysv_aarch64_le_std_abi : abi any_abi_feature
let sysv_aarch64_le_std_abi = 
   <| is_valid_elf_header = header_is_aarch64_le
    ; make_elf_header = make_elf64_header elf_data_2lsb elf_osabi_none 0 elf_ma_aarch64
    ; reloc = aarch64_le_reloc
    ; section_is_special = section_is_special
    ; section_is_large = (fun _ -> (fun _ -> false))
    ; maxpagesize = 2 * 256 * 4096 (* 2MB; bit of a guess, based on gdb and prelink code *)
    ; minpagesize = 1024 (* bit of a guess again *)
    ; commonpagesize = 4096
    ; symbol_is_generated_by_linker = (fun symname -> symname = "_GLOBAL_OFFSET_TABLE_")
    ; make_phdrs = make_default_phdrs
    ; max_phnum = 5
    ; guess_entry_point = find_start_symbol_address
    ; pad_data = pad_zeroes
    ; pad_code = pad_zeroes
    |>

val all_abis : list (abi any_abi_feature)
let all_abis = [sysv_amd64_std_abi; sysv_aarch64_le_std_abi; null_abi]

