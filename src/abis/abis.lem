(** The [abis] module is the top-level module for all ABI related code, including
  * some generic functionality that works across all ABIs, and a primitive attempt
  * at abstracting over ABIs for purposes of linking.
  *)

open import Basic_classes
open import Bool
open import Num
open import Maybe
open import List
open import Assert_extra

open import Elf_file
open import Elf_header
open import Elf_interpreted_section
open import Memory_image

open import Abi_amd64
open import Abi_amd64_relocation

open import Abi_aarch64_le
open import Abi_aarch64_relocation

open import Abi_power64
open import Abi_power64_relocation

open import Abi_utilities
open import Elf_types_native_uint

(** Relocation operators and their validity on a given platform *)

val is_valid_abi_aarch64_relocation_operator : relocation_operator -> bool
let is_valid_abi_aarch64_relocation_operator op =
  match op with
    | Page -> true
    | G -> true
    | GDat -> true
    | GLDM -> true
    | DTPRel -> true
    | GTPRel -> true
    | TPRel -> true
    | GTLSDesc -> true
    | Delta -> true
    | LDM -> true
    | TLSDesc -> true
    | Indirect -> true
    | _ -> false
  end
  
val is_valid_abi_aarch64_relocation_operator2 : relocation_operator2 -> bool
let is_valid_abi_aarch64_relocation_operator2 op =
  match op with
    | GTLSIdx -> true
  end

val is_valid_abi_amd64_relocation_operator : relocation_operator -> bool
let is_valid_abi_amd64_relocation_operator op =
  match op with
    | Indirect -> true
    | _ -> false (* XXX: not sure about this? *)
  end
  
val is_valid_abi_amd64_relocation_operator2 : relocation_operator2 -> bool
let is_valid_abi_amd64_relocation_operator2 op =
  match op with
    | _ -> false
  end

val is_valid_abi_power64_relocation_operator : relocation_operator -> bool
let is_valid_abi_power64_relocation_operator op = false (* TODO *)

val is_valid_abi_power64_relocation_operator2 : relocation_operator2 -> bool
let is_valid_abi_power64_relocation_operator2 op =
  match op with
    | _ -> false
  end

(** Misc. ABI related stuff *)

type any_abi_feature = Amd64AbiFeature of amd64_abi_feature
                     | Aarch64LeAbiFeature of aarch64_le_abi_feature

val anyAbiFeatureToNaturalList : any_abi_feature -> list natural
let anyAbiFeatureToNaturalList f = match f with
    Amd64AbiFeature(af) -> 0 :: (toNaturalList af)
    | Aarch64LeAbiFeature(af) -> 1 :: (toNaturalList af)
end

instance (ToNaturalList any_abi_feature)
    let toNaturalList = anyAbiFeatureToNaturalList
end

val anyAbiFeatureCompare : any_abi_feature -> any_abi_feature -> Basic_classes.ordering
let anyAbiFeatureCompare f1 f2 = 
    match (anyAbiFeatureToNaturalList f1, anyAbiFeatureToNaturalList f2) with
        ([], []) -> failwith "impossible: any-ABI feature has empty natural list (case 0)"
    |   (_, [])  -> failwith "impossible: any-ABI feature has empty natural list (case 1)"
    |   ([], _)  -> failwith "impossible: any-ABI feature has empty natural list (case 2)"
    |   ((hd1 :: tl1), (hd2 :: tl2)) -> 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                match (f1, f2) with
                    (Amd64AbiFeature(af1), Amd64AbiFeature(af2)) -> compare af1 af2
                   |(Aarch64LeAbiFeature(af1), Aarch64LeAbiFeature(af2)) -> compare af1 af2
                   | _ -> failwith "impossible: tag constructors not equal but natural list heads were equal"
                end
    end

instance (Ord any_abi_feature)
    let compare = anyAbiFeatureCompare
    let (<) = fun f1 -> (fun f2 -> (anyAbiFeatureCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (anyAbiFeatureCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (anyAbiFeatureCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (anyAbiFeatureCompare f1 f2) {GT; EQ})
end

let make_elf64_header data osabi abiv ma t entry shoff phoff phnum shnum shstrndx =
      <| elf64_ident    = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3; 
                           unsigned_char_of_natural elf_class_64; 
                           unsigned_char_of_natural data;
                           unsigned_char_of_natural elf_ev_current;
                           unsigned_char_of_natural osabi;
                           unsigned_char_of_natural abiv;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0;
                           unsigned_char_of_natural 0]
       ; elf64_type     = elf64_half_of_natural t
       ; elf64_machine  = elf64_half_of_natural ma
       ; elf64_version  = elf64_word_of_natural elf_ev_current
       ; elf64_entry    = elf64_addr_of_natural 0
       ; elf64_phoff    = elf64_off_of_natural phoff
       ; elf64_shoff    = elf64_off_of_natural shoff
       ; elf64_flags    = elf64_word_of_natural 0
       ; elf64_ehsize   = elf64_half_of_natural 64
       ; elf64_phentsize= elf64_half_of_natural 56
       ; elf64_phnum    = elf64_half_of_natural phnum
       ; elf64_shentsize= elf64_half_of_natural 64
       ; elf64_shnum    = elf64_half_of_natural shnum
       ; elf64_shstrndx = elf64_half_of_natural shstrndx
       |>

(* null_abi captures ABI details common to all ELF-based, System V-based systems.
 * HACK: for now, specialise to 64-bit ABIs. *)
val null_abi : abi any_abi_feature 
let (null_abi : abi any_abi_feature) = <|
      is_valid_elf_header = is_valid_elf64_header
    ; make_elf_header = make_elf64_header elf_data_2lsb elf_osabi_none 0 elf_ma_none
    ; reloc = noop_reloc
    ; section_is_special = elf_section_is_special
    ; section_is_large = (fun s -> (fun f -> false))
    ; maxpagesize = 2 * 256 * 4096 (* 2MB; bit of a guess, based on gdb and prelink code *)
    ; minpagesize = 1024 (* bit of a guess again *)
    ; commonpagesize = 4096
    ; symbol_is_generated_by_linker = (fun symname -> symname = "_GLOBAL_OFFSET_TABLE_")
    |>

val sysv_amd64_std_abi : abi any_abi_feature
let sysv_amd64_std_abi = 
   <| is_valid_elf_header = header_is_amd64
    ; make_elf_header = make_elf64_header elf_data_2lsb elf_osabi_none 0 elf_ma_x86_64
    ; reloc = amd64_reloc
    ; section_is_special = section_is_special
    ; section_is_large = (fun s -> (fun f -> flag_is_set shf_x86_64_large s.elf64_section_flags))
    ; maxpagesize = 65536
    ; minpagesize = 4096
    ; commonpagesize = 4096
    ; symbol_is_generated_by_linker = null_abi.symbol_is_generated_by_linker
    |>

val sysv_aarch64_le_std_abi : abi any_abi_feature
let sysv_aarch64_le_std_abi = 
   <| is_valid_elf_header = header_is_aarch64_le
    ; make_elf_header = make_elf64_header elf_data_2lsb elf_osabi_none 0 elf_ma_aarch64
    ; reloc = aarch64_le_reloc
    ; section_is_special = section_is_special
    ; section_is_large = (fun _ -> (fun _ -> false))
    ; maxpagesize = null_abi.maxpagesize
    ; minpagesize = null_abi.minpagesize
    ; commonpagesize = null_abi.commonpagesize
    ; symbol_is_generated_by_linker = null_abi.symbol_is_generated_by_linker
    |>

val all_abis : list (abi any_abi_feature)
let all_abis = [sysv_amd64_std_abi; sysv_aarch64_le_std_abi; null_abi]

