open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Map
import Set
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_file
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Elf_relocation
open import String_table

open import Memory_image
open import Memory_image_orderings

open import Elf_memory_image

val section_name_is_unique : string -> elf64_file -> bool
let section_name_is_unique name f =
    match mapMaybe (fun sec -> 
        if name = sec.elf64_section_name_as_string then Just sec else Nothing
    ) f.elf64_file_interpreted_sections
    with
        [_] -> true
        | _ -> false
    end

val unique_name_for_section_from_index : natural -> elf64_interpreted_section -> elf64_file -> string
let unique_name_for_section_from_index idx s f =
    let secname = s.elf64_section_name_as_string
    in if section_name_is_unique secname f then secname else gensym secname

val elf_memory_image_of_elf64_file : forall 'abifeature. abi 'abifeature -> string -> elf64_file -> elf_memory_image
let elf_memory_image_of_elf64_file a fname f = 
    (* Do we have program headers? This decides whether we choose a 
     * sectionwise or segmentwise view. *)
    match f.elf64_file_program_header_table with
        [] ->   let section_names_and_elements = mapMaybei (fun i -> (fun isec -> 
                   Just (unique_name_for_section_from_index i isec f, <|
                        startpos = Nothing
                      ; length = Just isec.elf64_section_size
                      ; contents = byte_pattern_of_byte_sequence isec.elf64_section_body
                    |>)
                )) f.elf64_file_interpreted_sections
                in
                (* -- annotations are reloc sites, symbol defs, ELF sections/segments/headers, PLT/GOT/...  *)
                let (elf_sections : list (element_range * elf_range_tag)) = mapMaybei (fun secidx -> (
                    (fun (isec, (secname, _)) -> 
                        let (r : element_range) = ((secname, (0, isec.elf64_section_size)))
                        in
                        Just (r, FileFeature(ElfSection(secidx, isec)))
                    )))
                    (zip f.elf64_file_interpreted_sections section_names_and_elements)
                in
                let (symbol_defs : list (element_range * elf_range_tag)) = mapMaybe
                    (fun x -> 
                        let section_num = natural_of_elf64_half x.def_syment.elf64_st_shndx
                        in
                        if      section_num = shn_abs    then
                            (* what do we label? FIXME *) Nothing
                        else if section_num = shn_common then (* FIXME *) Nothing
                        else
                            let (section_name, _) = match index section_num section_names_and_elements with
                                Just x -> x
                                | Nothing -> failwith ("symbol " ^ x.def_symname ^ " references nonexistent section")
                            end
                            in
                            Just ((section_name, (natural_of_elf64_addr x.def_syment.elf64_st_value, natural_of_elf64_xword x.def_syment.elf64_st_size)), SymbolDef(x))
                    )
                    (extract_definitions_from_symtab_of_type sht_symtab f)
                in
                let (all_reloc_sites : list (element_range * elf_range_tag)) = List.map 
                    (fun x ->
                        let (section_name, _) = match index (x.ref_src_scn) section_names_and_elements with
                            Just y -> y
                            | Nothing -> failwith "relocs came from nonexistent section"
                        end
                        in
                        let (szfun, applyfn) = a.reloc (elf64_relocation_r_type x.ref_relent.elf64_ra_info)
                        in
                        let sz = szfun Nothing (* FIXME: for copy relocs, the size depends on the *definition*.
                             AHA! a copy reloc always *has* a symbol definition locally; it just gets its *value*
                             from the shared object's definition.
                             In other words, a copy reloc always references a defined symbol, and the amount
                             copied is the minimum of that symbol's size and the overridden (copied-from .so)'s 
                             symbol's size. *)
                        in
                        let (offset : elf64_addr) = x.ref_relent.elf64_ra_offset
                        in 
                        ((section_name, (natural_of_elf64_addr offset, sz)), RelocationSite(x))
                    )
                    (extract_all_relocs_as_symbol_references fname f)
                in
                let reloc_as_triple = fun (_, x) -> (match x with
                            RelocationSite(r) -> 
                                    (r.ref_rel_scn, r.ref_rel_idx, r.ref_src_scn)
                                | _ -> failwith "unexpected tag"
                            end)
                in
                let _ = Missing_pervasives.println ("Extracted " ^ (show (length all_reloc_sites)) ^ " reloc site tags from "
                    ^ "file " ^ fname ^ ": " ^ (show (List.map reloc_as_triple all_reloc_sites)))
                in
                let retrieved_reloc_sites = Multimap.lookupBy Memory_image_orderings.tagEquiv
                    (RelocationSite(null_symbol_reference_and_reloc_site)) 
                    (let (fst, snd) = unzip all_reloc_sites in Set.fromList (zip snd fst))
                in
                let _ = Missing_pervasives.println ("Re-reading: retrieved " ^ (show (length retrieved_reloc_sites)) ^ " reloc site tags from "
                    ^ "file " ^ fname ^ ": " ^ (show (List.map reloc_as_triple (let (fst, snd) = unzip retrieved_reloc_sites in zip snd fst))))
                in
                let elf_header = [(("header", (0, natural_of_elf64_half f.elf64_file_header.elf64_ehsize)), FileFeature(ElfHeader(f.elf64_file_header)))]
                in
                let _ = Missing_pervasives.println ("ELF header contributes " ^ (show (List.length elf_header)) ^ " annotations.")
                in
                let all_annotations_list =  all_reloc_sites ++ symbol_defs ++ elf_sections ++ elf_header
                in
                let all_annotations_length = List.length all_annotations_list
                in
                let _ = Missing_pervasives.println ("total annotations: " ^ (show all_annotations_length))
                in
                let all_annotations = Set.fromList all_annotations_list
                in
                let (apply_content_relocations : string -> byte_pattern -> byte_pattern) = (fun name -> (fun content -> 
                    let this_element_reloc_annotations = List.filter (fun ((n, range), _) -> name = n) all_reloc_sites
                    in
                    let ((this_element_name_and_reloc_ranges : list (string * (natural * natural))), _) = unzip this_element_reloc_annotations
                    in
                    let (this_element_reloc_ranges : list (natural * natural)) = snd (unzip this_element_name_and_reloc_ranges)
                    in
                    let (all_ranges_expanded : list bool) = expand_unsorted_ranges this_element_reloc_ranges (Missing_pervasives.length content) []
                    in
                    relax_byte_pattern content all_ranges_expanded
                ))
                in
                let new_elements_list = List.map (fun (name, element) -> 
                    (* We can now mark the relocation sites in the section contents as "subject to change". *)
                    (
                        name, 
                        <|
                           startpos = element.startpos
                         ; length   = element.length
                         ; contents = apply_content_relocations name element.contents
                         |>
                    )
                  ) section_names_and_elements
                in
                            (*
                            List.foldr (fun acc -> (fun  element.contents this_element_reloc_ranges
                            let (expand_and_relax : list (maybe byte) -> (natural * natural) -> list (maybe byte)) = fun pat -> (fun r -> (
                                relax_byte_pattern pat (expand_ranges r)
                            ))
                            in*)
                 <|
                      elements = Map.fromList new_elements_list
                      (* : memory_image -- the image elements, without annotation, i.e. 
                        a map from string to (startpos, length, contents)
                        -- an element is the ELF header, PHT, SHT, section or segment
                        -- exploit the fact that section names beginning `.' are reserved, and 
                           the reserved ones don't use caps: ".PHT", ".SHT", ".HDR"
                        -- what about ambiguous section names? use ".GENSYM_<...>" perhaps 
                      *)
                    ; by_range = all_annotations
                    ; by_tag = let (fst, snd) = unzip all_annotations_list in Set.fromList (zip snd fst)
                        (*  : multimap (elf_range_tag 'symdef 'reloc 'filefeature 'abifeature) (string * range) 
                         -- annotations by *)
                  |>
      | pht -> let segment_names_and_images = mapMaybei (fun i -> (fun seg -> 
                    Just(gensym (show seg.elf64_segment_base) ^ "_" ^ (show seg.elf64_segment_type), 
                    <|
                        startpos = Just seg.elf64_segment_base
                      ; length = Just seg.elf64_segment_memsz
                      ; contents = [] (* FIXME *)
                     |>)
                )) f.elf64_file_interpreted_segments
                in
                (* let annotations = *)
                 <|
                      elements = Map.fromList segment_names_and_images  (* : memory_image -- the image elements, without annotation, i.e. 
                        a map from string to (startpos, length, contents)
                        -- an element is the ELF header, PHT, SHT, section or segment
                        -- exploit the fact that section names beginning `.' are reserved, and 
                           the reserved ones don't use caps: ".PHT", ".SHT", ".HDR"
                        -- what about ambiguous section names? use ".GENSYM_<...>" perhaps 
                      *)
                    ; by_range = Set.fromList []
                        (* : map element_range (list (elf_range_tag 'symdef 'reloc 'filefeature 'abifeature))
                         -- annotations are reloc sites, symbol defs, ELF sections/segments/headers, PLT/GOT/...  *)
                    ; by_tag = Set.fromList []
                        (*  : multimap (elf_range_tag 'symdef 'reloc 'filefeature 'abifeature) (string * range) 
                         -- annotations by *)
                  |>

    end

val elf_memory_image_header : elf_memory_image -> elf64_header
let elf_memory_image_header img = 
    match unique_tag_matching (FileFeature(ElfHeader(null_elf_header))) img with
        FileFeature(ElfHeader(x)) -> x
        | _ -> failwith "impossible: no header"
    end

val elf_memory_image_sht : elf_memory_image -> maybe elf64_section_header_table
let elf_memory_image_sht img = 
    match unique_tag_matching (FileFeature(null_section_header_table)) img with
        FileFeature(ElfSectionHeaderTable(x)) -> Just x
        | _ -> Nothing
    end

val elf_memory_image_section_ranges : elf_memory_image -> (list elf_range_tag * list element_range)
let elf_memory_image_section_ranges img = 
    (* find all element ranges labelled as ELF sections *)
    unzip (
        tagged_ranges_matching_tag (FileFeature(ElfSection(0, null_elf64_interpreted_section))) img
    )

val elf_memory_image_section_by_index : natural -> elf_memory_image -> maybe elf64_interpreted_section
let elf_memory_image_section_by_index idx img = 
    (* find all element ranges labelled as ELF sections *)
    let (allSectionTags, allSectionElementRanges) = elf_memory_image_section_ranges img 
    in
    let matches = mapMaybei (fun i -> (fun tag -> match tag with
         FileFeature(ElfSection(itsIdx, s)) -> if itsIdx = idx then Just s else Nothing
        | _ -> failwith "impossible"
    end)) allSectionTags
    in
    match matches with
        [] -> Nothing
        | [x] -> Just x
        | x -> failwith ("impossible: more than one ELF section with same index (" ^ (show idx) ^ ")")
    end

val elf_memory_image_element_coextensive_with_section : natural -> elf_memory_image -> maybe string
let elf_memory_image_element_coextensive_with_section idx img = 
    (* find all element ranges labelled as ELF sections *)
    let (allSectionTags, allSectionElementRanges) = elf_memory_image_section_ranges img 
    in
    let matches = mapMaybei (fun i -> (fun (tag, (elName, (rangeStart, rangeLen))) -> match tag with
         FileFeature(ElfSection(itsIdx, s)) -> if itsIdx = idx && rangeStart = 0 && rangeLen = s.elf64_section_size then Just elName else Nothing
        | _ -> failwith "impossible"
    end)) (zip allSectionTags allSectionElementRanges)
    in
    match matches with
        [] -> Nothing
        | [x] -> Just x
        | _ -> failwith ("impossible: more than one ELF section coextensive with section " ^ (show idx))
    end


val name_of_elf_interpreted_section : 
    elf64_interpreted_section -> elf64_interpreted_section -> maybe string
let name_of_elf_interpreted_section s shstrtab = 
    match get_string_at s.elf64_section_name (string_table_of_byte_sequence shstrtab.elf64_section_body) with
        Success(x) -> Just x
        | Fail(e) -> Nothing
    end

val elf_memory_image_sections_with_indices : elf_memory_image -> list (elf64_interpreted_section * natural)
let elf_memory_image_sections_with_indices img = 
    (* We have to get all sections and their names,
     * because section names need not be unique. *)
    let ((all_section_tags, all_section_ranges) : (list elf_range_tag * list element_range))
     = elf_memory_image_section_ranges img
    in
    List.map (fun tag -> 
        match tag with
            FileFeature(ElfSection(idx, i)) -> (i, idx)
            | _ -> failwith "impossible: non-section in list of sections"
        end) all_section_tags

val elf_memory_image_sections : elf_memory_image -> list elf64_interpreted_section
let elf_memory_image_sections img = 
    let (secs, _) = unzip (elf_memory_image_sections_with_indices img)
    in secs

val elf_memory_image_sections_with_name : string -> elf_memory_image -> list elf64_interpreted_section
let elf_memory_image_sections_with_name name img = 
    let all_interpreted_sections = elf_memory_image_sections img
    in
    let maybe_shstrtab = elf_memory_image_section_by_index (natural_of_elf64_half ((elf_memory_image_header img).elf64_shstrndx)) img
    in
    let shstrtab = match maybe_shstrtab with 
        Nothing -> failwith "no shtstrtab"
        | Just x -> x
    end
    in
    let all_section_names = List.map (fun i -> 
        let (stringtab : string_table) = string_table_of_byte_sequence (shstrtab.elf64_section_body) in
        match get_string_at i.elf64_section_name stringtab with
            Fail _ -> Nothing
            | Success x -> Just x
        end) all_interpreted_sections
    in
    mapMaybe (fun (n, i) -> if Just(name) = n then Just i else Nothing) (zip all_section_names all_interpreted_sections)
(*
val elf_memory_image_unique_section_with_name : string -> elf_memory_image -> elf64_interpreted_section
let elf_memory_image_unique_section_with_name name img = 
    match Map.lookup name img.image with
        Just el -> match el with
            FileFeature(ElfSection(_, x)) -> x
            | _ -> failwith "impossible: section name does not name a section"
        end
        | 
        | Nothing -> failwith ("no section named '" ^ name ^ "' but asserted unique")
    end
*)

val elf_memory_image_symbol_def_ranges : elf_memory_image -> (list elf_range_tag * list element_range)
let elf_memory_image_symbol_def_ranges img = 
    (* find all element ranges labelled as ELF symbols *)
    unzip (
        tagged_ranges_matching_tag (SymbolDef(null_symbol_definition)) img
    )

val name_of_symbol_def : symbol_definition -> string
let name_of_symbol_def sym = sym.def_symname

val elf_memory_image_defined_symbols : elf_memory_image -> list symbol_definition
let elf_memory_image_defined_symbols img = 
    let ((all_symbol_tags, all_symbol_ranges) : (list elf_range_tag * list element_range))
     = elf_memory_image_symbol_def_ranges img
    in
    List.mapMaybe (fun tag -> 
        match tag with
            SymbolDef(ent) -> Just ent
            | _ -> failwith "impossible: non-symbol def in list of symbol defs"
        end) all_symbol_tags

(*
val elf_memory_image_symbols_with_name : string -> elf_memory_image -> list symbol_definition
let elf_memory_image_symbols_with_name name img = 
    let all_interpreted_sections = elf_memory_image_sections img
    in
    let maybe_shstrtab = elf_memory_image_section_by_index (natural_of_elf64_half ((elf_memory_image_header img).elf64_shstrndx)) img
    in
    let shstrtab = match maybe_shstrtab with 
        Nothing -> failwith "no shtstrtab"
        | Just x -> x
    end
    in
    let all_section_names = List.map (fun i -> 
        let (stringtab : string_table) = string_table_of_byte_sequence (shstrtab.elf64_section_body) in
        match get_string_at i.elf64_section_name stringtab with
            Fail _ -> Nothing
            | Success x -> Just x
        end) all_interpreted_sections
    in
    mapMaybe (fun (n, i) -> if Just(name) = n then Just i else Nothing) (zip all_section_names all_interpreted_sections)
*)
(*
val elf_memory_image_unique_symbol_with_name : string -> elf_memory_image -> symbol_def
let elf_memory_image_unique_symbol_with_name name img = 
    match Map.lookup name img.image with
        Just el -> match el with
            FileFeature(ElfSection(_, x)) -> x
            | _ -> failwith "impossible: section name does not name a section"
        end
        | 
        | Nothing -> failwith ("no section named '" ^ name ^ "' but asserted unique")
    end
*)


val name_of_elf_section : elf64_interpreted_section -> elf_memory_image -> maybe string
let name_of_elf_section sec img = 
   let shstrndx = natural_of_elf64_half ((elf_memory_image_header img).elf64_shstrndx)
   in
   match elf_memory_image_section_by_index shstrndx img with
        Nothing -> Nothing
        | Just shstrtab -> name_of_elf_interpreted_section sec shstrtab
  end

val name_of_elf_element : elf_file_feature -> elf_memory_image -> maybe string
let name_of_elf_element feature img = 
    match feature with
        ElfSection(_, sec) -> name_of_elf_section sec img
        | _ -> Nothing (* FIXME *) 
    end
    
