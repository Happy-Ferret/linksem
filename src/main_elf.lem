open import Basic_classes
open import Function
open import Maybe
open import List
open import Num
open import String
open import Tuple

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Assert_extra

open import Endianness

open import Elf_header
open import Elf_file
open import Elf_program_header_table
open import Elf_section_header_table
open import Elf_types_native_uint

open import Harness_interface
open import Sail_interface

open import Abi_amd64_elf_header
open import Abi_amd64_relocation
open import Abi_amd64_serialisation

open import Abi_x86_relocation

open import Gnu_ext_program_header_table
open import Gnu_ext_section_header_table

let default_hdr_bdl =
  (default_os_specific_print, default_proc_specific_print)

let default_pht_bdl =
  (default_os_specific_print, default_proc_specific_print)

let default_sht_bdl =
  (default_os_specific_print, default_proc_specific_print, default_user_specific_print)

val reverse_nibbles : list string -> list string
let rec reverse_nibbles ss =
  match ss with
    | s1::s2::ss -> (s2 ^ s1)::(reverse_nibbles ss)
    | x          -> x
  end

val chunks : list string -> list (list string) * nat
let rec chunks ss =
  match ss with
    | s1::s2::s3::s4::s5::s6::s7::s8::ss ->
      let (tail, miss) = chunks ss in
        (([s1;s2;s3;s4;s5;s6;s7;s8]::tail), miss)
    | ss ->
      let missing = naturalFromNat (8 - List.length ss) in
        if missing = 8 then
          ([], List.length ss)
        else
          let bits    = replicate missing "    " in
          let fixed   = intercalate " " bits in
          let buff    = ss ++ [concatS fixed] in
            ([buff], List.length ss)
  end
  
val provide_offsets : (list (list string) * nat) -> list (string * list string)
let provide_offsets (ss, ed) =
  List.mapi (fun i x ->
    let hx = unsafe_hex_string_of_natural 7 ((naturalFromNat i) * 16) in
      (hx, x)) ss
  ++
    if ed = 0 then
      [(unsafe_hex_string_of_natural 7 ((naturalFromNat (List.length ss)) * 16), [])]
    else
      [(unsafe_hex_string_of_natural 7 (((naturalFromNat (List.length ss - 1)) * 16) + naturalFromNat (ed * 2)), [])]
    
val print_chunk : string * list string -> string
let print_chunk (off, ss) =
  match ss with
    | [] -> off
    | _  -> off ^ " " ^ concatS (intercalate " " ss)
  end
    
let _ =
  let res =
    let (flag, arg) =
      match argv with
        | progname::flag::fname::more -> (flag, fname)
        | _                           -> failwith "usage: main_elf <flag> <fname>"
      end
    in
    Byte_sequence.acquire arg    >>= fun bs0 ->
    repeatM' Elf_header.ei_nident bs0 (read_unsigned_char Endianness.default_endianness) >>= fun (ident, bs) ->
    match List.index ident 4 with
      | Nothing -> failwith "ELF ident transcription error"
      | Just c  ->
        if natural_of_unsigned_char c = Elf_header.elf_class_32 then
          Elf_file.read_elf32_file bs0 >>= fun f1  ->
          get_elf32_file_section_header_string_table f1 >>= fun stbl ->
          get_elf32_file_symbol_table f1 >>= fun symtab ->
            let ret =
              if flag = "--file-header" then
                Harness_interface.harness_string_of_elf32_file_header f1.elf32_file_header
              else if flag = "--program-headers" then
                Harness_interface.harness_string_of_elf32_program_headers
                  string_of_gnu_ext_segment_type 
                  (fun x ->
                    show x)
                  f1.elf32_file_header
                  f1.elf32_file_program_header_table
                  f1.elf32_file_section_header_table
                  stbl
                  bs0
              else if flag = "--section-headers" then
                Harness_interface.harness_string_of_elf32_section_headers
                  string_of_gnu_ext_section_type
                  (fun x -> show x)
                  (fun x -> show x)
                  f1.elf32_file_header
                  f1.elf32_file_section_header_table
                  stbl
              else if flag = "--relocs" then
                Harness_interface.harness_string_of_elf32_relocs
                  f1
                  string_of_x86_relocation_type (* XXX: generic way to obtain correct ABI needed *)
                  bs0
              else if flag = "--symbols" then
                Harness_interface.harness_string_of_elf32_syms
                  f1
                  show
                  show
                  bs0
              else if flag = "--in-out" then
                match Elf_file.bytes_of_elf32_file f1 with
                  | Fail    f -> f
                  | Success s ->
                    let ss =
                      List.map (unsafe_hex_string_of_natural 2)
                        (List.map natural_of_byte (Byte_sequence.byte_list_of_byte_sequence s))
                    in
                    let chunks = provide_offsets (chunks (reverse_nibbles ss)) in
                    let lines  = concatS (intercalate "\n" (List.map print_chunk chunks)) in
                    (*let _      = Byte_sequence.serialise "mainelf-inout" s in*)
                      show lines
                end
              else
                failwith "Unrecognised flag"
            in
              return ret
        else if natural_of_unsigned_char c = Elf_header.elf_class_64 then
          Elf_file.read_elf64_file bs0 >>= fun f1  ->
          get_elf64_file_section_header_string_table f1 >>= fun stbl ->
            let ret =
              if flag = "--file-header" then
                Harness_interface.harness_string_of_elf64_file_header f1.elf64_file_header
              else if flag = "--program-headers" then
                Harness_interface.harness_string_of_elf64_program_headers
                  string_of_gnu_ext_segment_type
                  show
                  f1.elf64_file_header
                  f1.elf64_file_program_header_table
                  f1.elf64_file_section_header_table
                  stbl
                  bs0
              else if flag = "--section-headers" then
                Harness_interface.harness_string_of_elf64_section_headers
                  string_of_gnu_ext_section_type
                  (fun x -> show x)
                  (fun x -> show x)
                  f1.elf64_file_header
                  f1.elf64_file_section_header_table
                  stbl
              else if flag = "--relocs" then
                Harness_interface.harness_string_of_elf64_relocs
                  f1
                  string_of_amd64_relocation_type (* XXX: generic way to obtain correct ABI needed *)
                  bs0
              else if flag = "--in-out" then
                match Elf_file.bytes_of_elf64_file f1 with
                  | Fail    f -> f
                  | Success s ->
                    let ss =
                      List.map (unsafe_hex_string_of_natural 2)
                        (List.map natural_of_byte (Byte_sequence.byte_list_of_byte_sequence s))
                    in
                    let chunks = provide_offsets (chunks (reverse_nibbles ss)) in
                    let lines  = concatS (intercalate "\n" (List.map print_chunk chunks)) in
                    (*let _      = Byte_sequence.serialise "mainelf-inout" s in*)
                      show lines
                end
              else
                failwith "Unimplemented (for ELF64) or unrecognised flag"
            in
              return ret
        else
          failwith "ELF ident transcription error"
    end
  in
    match res with
      | Fail err  -> Missing_pervasives.println ("[!]: " ^ err)
      | Success e -> Missing_pervasives.println (show e)
    end
