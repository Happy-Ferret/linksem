(** [elf_dynamic] module exports types and definitions relating to the dynamic
  * section and dynamic linking functionality of an ELF file.
  *)

open import Basic_classes
open import Bool
open import List
open import Num
open import String

open import Byte_sequence
open import Endianness
open import Error
open import Show
open import String_table

open import Elf_file
open import Elf_header
open import Elf_relocation
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_types_native_uint

(** Validity checks *)

val is_elf32_valid_program_header_table_for_dynamic_linking : elf32_program_header_table ->
  bool
let is_elf32_valid_program_header_table_for_dynamic_linking pht =
  List.length (List.filter (fun x -> natural_of_elf32_word x.elf32_p_type = elf_pt_interp) pht) = 1
  
val is_elf64_valid_program_header_table_for_dynamic_linking : elf64_program_header_table ->
  bool
let is_elf64_valid_program_header_table_for_dynamic_linking pht =
  List.length (List.filter (fun x -> natural_of_elf64_word x.elf64_p_type = elf_pt_interp) pht) = 1

(** Dynamic section entry *)

(** [dyn_union] represents the C-union type used in the definition of [elf32_dyn]
  * and [elf64_dyn] types below.  Some section tags correspond to entries where
  * the fields are either unspecified or ignored, hence the presence of the
  * [D_Ignored] constructor.
  *)
type dyn_union 'a 'b
  = D_Val of 'a
  | D_Ptr of 'b
  | D_Ignored of byte_sequence
  
type elf32_dyn =
  <| elf32_dyn_tag  : elf32_sword
   ; elf32_dyn_d_un : dyn_union elf32_word elf32_addr
   |>
   
type elf64_dyn =
  <| elf64_dyn_tag  : elf64_sxword
   ; elf64_dyn_d_un : dyn_union elf64_xword elf64_addr
   |>

(** Dynamic section tags *)

(** [dt_null] marks the end of the dynamic array *)
let dt_null : natural = 0
(** [dt_needed] holds the string table offset of a string containing the name of
  * a needed library.
  *)
let dt_needed : natural = 1
(** [dt_pltrelsz] holds the size in bytes of relocation entries associated with
  * the PLT.
  *)
let dt_pltrelsz : natural = 2
(** [dt_pltgot] holds an address associated with the PLT or GOT. *)
let dt_pltgot : natural = 3
(** [dt_hash] holds the address of a symbol-table hash. *)
let dt_hash : natural = 4
(** [dt_strtab] holds the address of the string table. *)
let dt_strtab : natural = 5
(** [dt_symtab] holds the address of a symbol table. *)
let dt_symtab : natural = 6
(** [dt_rela] holds the address of a relocation table. *)
let dt_rela : natural = 7
(** [dt_relasz] holds the size in bytes of the relocation table. *)
let dt_relasz : natural = 8
(** [dt_relaent] holds the size in bytes of a relocation table entry. *)
let dt_relaent : natural = 9
(** [dt_strsz] holds the size in bytes of the string table. *)
let dt_strsz : natural = 10
(** [dt_syment] holds the size in bytes of a symbol table entry. *)
let dt_syment : natural = 11
(** [dt_init] holds the address of the initialisation function. *)
let dt_init : natural = 12
(** [dt_fini] holds the address of the finalisation function. *)
let dt_fini : natural = 13
(** [dt_soname] holds the string table offset of a string containing the shared-
  * object name.
  *)
let dt_soname : natural = 14
(** [dt_rpath] holds the string table offset of a string containing the library
  * search path.
  *)
let dt_rpath : natural = 15
(** [dt_symbolic] alters the linker's symbol resolution algorithm so that names
  * are resolved first from the shared object file itself, rather than the
  * executable file.
  *)
let dt_symbolic : natural = 16
(** [dt_rel] is similar to [dt_rela] except its table has implicit addends. *)
let dt_rel : natural = 17
(** [dt_relsz] holds the size in bytes of the [dt_rel] relocation table. *)
let dt_relsz : natural = 18
(** [dt_relent] holds the size in bytes of a [dt_rel] relocation entry. *)
let dt_relent : natural = 19
(** [dt_pltrel] specifies the type of relocation entry to which the PLT refers. *)
let dt_pltrel : natural = 20
(** [dt_debug] is used for debugging and its purpose is not specified in the ABI.
  * Programs using this entry are not ABI-conformant.
  *)
let dt_debug : natural = 21
(** [dt_textrel] absence of this entry indicates that no relocation entry should
  * cause a modification to a non-writable segment.  Otherwise, if present, one
  * or more relocation entries may request modifications to a non-writable
  * segment.
  *)
let dt_textrel : natural = 22
(** [dt_jmprel]'s member holds the address of relocation entries associated with
  * the PLT.
  *)
let dt_jmprel : natural = 23
(** [dt_bindnow] instructs the linker to process all relocations for the object
  * containing the entry before transferring control to the program.
  *)
let dt_bindnow : natural = 24
(** [dt_init_array] holds the address to the array of pointers to initialisation
  * functions.
  *)
let dt_init_array : natural = 25
(** [dt_fini_array] holds the address to the array of pointers to finalisation
  * functions.
  *)
let dt_fini_array : natural = 26
(** [dt_init_arraysz] holds the size in bytes of the array of pointers to
  * initialisation functions.
  *)
let dt_init_arraysz : natural = 27
(** [dt_fini_arraysz] holds the size in bytes of the array of pointers to
  * finalisation functions.
  *)
let dt_fini_arraysz : natural = 28
(** [dt_runpath] holds an offset into the string table holding a string containing
  * the library search path.
  *)
let dt_runpath : natural = 29
(** [dt_flags] holds flag values specific to the object being loaded. *)
let dt_flags : natural = 30
let dt_encoding : natural = 32
(** [dt_preinit_array] holds the address to the array of pointers of pre-
  * initialisation functions.
  *)
let dt_preinit_array : natural = 32
(** [dt_preinit_arraysz] holds the size in bytes of the array of pointers of
  * pre-initialisation functions.
  *)
let dt_preinit_arraysz : natural = 33
(** [dt_loos] and [dt_hios]: this inclusive range is reserved for OS-specific
  * semantics.
  *)
let dt_loos : natural = (2 * 805306374) + 1 (* 0x6000000D *)
let dt_hios : natural = (2 * 939522048) (* 0x6ffff000 *)
(** [dt_loproc] and [dt_hiproc]: this inclusive range is reserved for processor
  * specific semantics.
  *)
let dt_loproc : natural = (2 * 939524096) (* 0x70000000 *)
let dt_hiproc : natural = (2 * 1073741823) + 1 (* 0x7fffffff *)

(** [string_of_dynamic_tag t os proc] produces a string-based representation of
  * dynamic section tag [t].  For tag values between LO_OS and HI_OS [os] is
  * used to produce the resulting value.  For tag values between LO_PROC and
  * HI_PROC [proc] is used to produce the resulting value.
  *)
val string_of_dynamic_tag : natural -> (natural -> bool) -> (natural -> string) -> (natural -> string)
  -> string
let string_of_dynamic_tag tag os_additional_ranges os proc =
  if tag = dt_null then
    "NULL"
  else if tag = dt_needed then
    "NEEDED"
  else if tag = dt_pltrelsz then
    "PLTRELSZ"
  else if tag = dt_pltgot then
    "PLTGOT"
  else if tag = dt_hash then
    "HASH"
  else if tag = dt_strtab then
    "STRTAB"
  else if tag = dt_symtab then
    "SYMTAB"
  else if tag = dt_rela then
    "RELA"
  else if tag = dt_relasz then
    "RELASZ"
  else if tag = dt_relaent then
    "RELAENT"
  else if tag = dt_strsz then
    "STRSZ"
  else if tag = dt_syment then
    "SYMENT"
  else if tag = dt_init then
    "INIT"
  else if tag = dt_fini then
    "FINI"
  else if tag = dt_soname then
    "SONAME"
  else if tag = dt_rpath then
    "RPATH"
  else if tag = dt_symbolic then
    "SYMBOLIC"
  else if tag = dt_rel then
    "REL"
  else if tag = dt_relsz then
    "RELSZ"
  else if tag = dt_relent then
    "RELENT"
  else if tag = dt_pltrel then
    "PLTREL"
  else if tag = dt_debug then
    "DEBUG"
  else if tag = dt_textrel then
    "TEXTREL"
  else if tag = dt_jmprel then
    "JMPREL"
  else if tag = dt_bindnow then
    "BINDNOW"
  else if tag = dt_init_array then
    "INIT_ARRAY"
  else if tag = dt_fini_array then
    "FINI_ARRAY"
  else if tag = dt_init_arraysz then
    "INIT_ARRAYSZ"
  else if tag = dt_fini_arraysz then
    "FINI_ARRAYSZ"
  else if tag = dt_runpath then
    "RUNPATH"
  else if tag = dt_flags then
    "FLAGS"
  else if tag = dt_encoding then
    "ENCODING"
  else if tag = dt_preinit_array then
    "PREINIT_ARRAY"
  else if tag = dt_preinit_arraysz then
    "PREINIT_ARRAYSZ"
  else if tag >= dt_loos && tag <= dt_hios then
    os tag
  else if os_additional_ranges tag then
    os tag
  else if tag >= dt_loproc && tag <= dt_hiproc then
    proc tag
  else
    "Invalid dynamic section tag"
    
type tag_correspondence
  = C_Val
  | C_Ptr
  | C_Ignored
  
val tag_correspondence_of_tag : natural -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error tag_correspondence
let tag_correspondence_of_tag tag os_additional_ranges os proc =
  if tag = dt_null then
    return C_Ignored
  else if tag = dt_needed then
    return C_Val
  else if tag = dt_pltrelsz then
    return C_Val
  else if tag = dt_pltgot then
    return C_Ptr
  else if tag = dt_hash then
    return C_Ptr
  else if tag = dt_strtab then
    return C_Ptr
  else if tag = dt_symtab then
    return C_Ptr
  else if tag = dt_rela then
    return C_Ptr
  else if tag = dt_relasz then
    return C_Val
  else if tag = dt_relaent then
    return C_Val
  else if tag = dt_strsz then
    return C_Val
  else if tag = dt_syment then
    return C_Val
  else if tag = dt_init then
    return C_Ptr
  else if tag = dt_fini then
    return C_Ptr
  else if tag = dt_soname then
    return C_Val
  else if tag = dt_rpath then
    return C_Val
  else if tag = dt_symbolic then
    return C_Ignored
  else if tag = dt_rel then
    return C_Ptr
  else if tag = dt_relsz then
    return C_Val
  else if tag = dt_relent then
    return C_Val
  else if tag = dt_pltrel then
    return C_Val
  else if tag = dt_debug then
    return C_Ptr
  else if tag = dt_textrel then
    return C_Ignored
  else if tag = dt_jmprel then
    return C_Ptr
  else if tag = dt_bindnow then
    return C_Ignored
  else if tag = dt_init_array then
    return C_Ptr
  else if tag = dt_fini_array then
    return C_Ptr
  else if tag = dt_init_arraysz then
    return C_Val
  else if tag = dt_fini_arraysz then
    return C_Val
  else if tag = dt_runpath then
    return C_Val
  else if tag = dt_flags then
    return C_Val
  else if tag = dt_encoding then
    return C_Ignored
  else if tag = dt_preinit_array then
    return C_Ptr
  else if tag = dt_preinit_arraysz then
    return C_Val
  else if tag >= dt_loos && tag <= dt_hios then
    os tag
  else if tag >= dt_loproc && tag <= dt_hiproc then
    proc tag
  else if os_additional_ranges tag then
    os tag
  else
    fail ("tag_correspondence_of_tag: invalid dynamic section tag: " ^ show tag)
    
val read_elf32_dyn : endianness -> byte_sequence -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (elf32_dyn * byte_sequence)
let read_elf32_dyn endian bs0 os_additional_ranges os proc =
  read_elf32_sword endian bs0 >>= fun (tag0, bs1) ->
  let tag = naturalFromInteger (integer_of_elf32_sword tag0) in
  tag_correspondence_of_tag tag os_additional_ranges os proc >>= fun corr ->
    match corr with
      | C_Ptr ->
        read_elf32_addr endian bs1 >>= fun (ptr, bs2) ->
        return (<| elf32_dyn_tag = tag0 ; elf32_dyn_d_un = D_Ptr ptr |>, bs2)
      | C_Val ->
        read_elf32_word endian bs1 >>= fun (vl, bs2) ->
        return (<| elf32_dyn_tag = tag0 ; elf32_dyn_d_un = D_Val vl |>, bs2)
      | C_Ignored ->
        match endian with
          | Big    ->
            read_4_bytes_be bs1 >>= fun ((b1, b2, b3, b4), bs2) ->
            let cut = Byte_sequence.from_byte_lists [[b1; b2; b3; b4]] in
            return (<| elf32_dyn_tag = tag0 ; elf32_dyn_d_un = D_Ignored cut |>, bs2)
          | Little ->
            read_4_bytes_le bs1 >>= fun ((b1, b2, b3, b4), bs2) ->
            let cut = Byte_sequence.from_byte_lists [[b1; b2; b3; b4]] in
            return (<| elf32_dyn_tag = tag0 ; elf32_dyn_d_un = D_Ignored cut |>, bs2)
        end
    end
    
val read_elf64_dyn : endianness -> byte_sequence -> (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (elf64_dyn * byte_sequence)
let read_elf64_dyn endian bs0 os_additional_ranges os proc =
  read_elf64_sxword endian bs0 >>= fun (tag0, bs1) ->
  let tag = naturalFromInteger (integer_of_elf64_sxword tag0) in
  tag_correspondence_of_tag tag os_additional_ranges os proc >>= fun corr ->
    match corr with
      | C_Ptr ->
        read_elf64_addr endian bs1 >>= fun (ptr, bs2) ->
        return (<| elf64_dyn_tag = tag0 ; elf64_dyn_d_un = D_Ptr ptr |>, bs2)
      | C_Val ->
        read_elf64_xword endian bs1 >>= fun (vl, bs2) ->
        return (<| elf64_dyn_tag = tag0 ; elf64_dyn_d_un = D_Val vl |>, bs2)
      | C_Ignored ->
        match endian with
          | Big    ->
            read_8_bytes_be bs1 >>= fun ((b1, b2, b3, b4, b5, b6, b7, b8), bs2) ->
            let cut = Byte_sequence.from_byte_lists [[b1; b2; b3; b4; b5; b6; b7; b8]] in
            return (<| elf64_dyn_tag = tag0 ; elf64_dyn_d_un = D_Ignored cut |>, bs2)
          | Little ->
            read_8_bytes_le bs1 >>= fun ((b1, b2, b3, b4, b5, b6, b7, b8), bs2) ->
            let cut = Byte_sequence.from_byte_lists [[b1; b2; b3; b4; b5; b6; b7; b8]] in
            return (<| elf64_dyn_tag = tag0 ; elf64_dyn_d_un = D_Ignored cut |>, bs2)
        end
    end
    
val obtain_elf32_dynamic_section_contents' : endianness -> byte_sequence ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (list elf32_dyn)
let rec obtain_elf32_dynamic_section_contents' endian bs0 os_additional_ranges os proc =
  if Byte_sequence.length bs0 = 0 then
    return []
  else
    read_elf32_dyn endian bs0 os_additional_ranges os proc >>= fun (head, bs0) ->
    if integer_of_elf32_sword head.elf32_dyn_tag = integerFromNatural dt_null then (* DT_NULL marks end of array *)
      return [head]
    else
    obtain_elf32_dynamic_section_contents' endian bs0 os_additional_ranges os proc >>= fun tail ->
    return (head::tail)
    
val obtain_elf64_dynamic_section_contents' : endianness -> byte_sequence ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> error (list elf64_dyn)
let rec obtain_elf64_dynamic_section_contents' endian bs0 os_additional_ranges os proc =
  if Byte_sequence.length bs0 = 0 then
    return []
  else
    read_elf64_dyn endian bs0 os_additional_ranges os proc >>= fun (head, bs0) ->
    if integer_of_elf64_sxword head.elf64_dyn_tag = integerFromNatural dt_null then (* DT_NULL marks end of array *)
      return [head]
    else
      obtain_elf64_dynamic_section_contents' endian bs0 os_additional_ranges os proc >>= fun tail ->
      return (head::tail)

val obtain_elf32_dynamic_section_contents : elf32_file ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> byte_sequence -> error (list elf32_dyn)
let obtain_elf32_dynamic_section_contents f1 os_additional_ranges os proc bs0 =
  let endian = get_elf32_header_endianness f1.elf32_file_header in
  let sht = f1.elf32_file_section_header_table in
    match List.filter (fun ent -> natural_of_elf32_word ent.elf32_sh_type = sht_dynamic) sht with
      | [] -> fail "obtain_elf32_dynamic_section_contents: no SHT_DYNAMIC section header entries"
      | [dyn] ->
        let off = natural_of_elf32_off dyn.elf32_sh_offset in
        let siz = natural_of_elf32_word dyn.elf32_sh_size in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
        obtain_elf32_dynamic_section_contents' endian rel os_additional_ranges os proc
      | _ -> fail "obtain_elf32_dynamic_section_contents: multiple SHT_DYNAMIC section header entries"
    end

val obtain_elf64_dynamic_section_contents : elf64_file ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
  (natural -> error tag_correspondence) -> byte_sequence -> error (list elf64_dyn)
let obtain_elf64_dynamic_section_contents f1 os_additional_ranges os proc bs0 =
  let endian = get_elf64_header_endianness f1.elf64_file_header in
  let sht = f1.elf64_file_section_header_table in
    match List.filter (fun ent -> natural_of_elf64_word ent.elf64_sh_type = sht_dynamic) sht with
      | [] -> fail "obtain_elf64_dynamic_section_contents: no SHT_DYNAMIC section header entries"
      | [dyn] ->
        let off = natural_of_elf64_off dyn.elf64_sh_offset in
        let siz = natural_of_elf64_xword dyn.elf64_sh_size in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
        obtain_elf64_dynamic_section_contents' endian rel os_additional_ranges os proc
      | _ -> fail "obtain_elf64_dynamic_section_contents: multiple SHT_DYNAMIC section header entries"
    end

(** DT Flags values *)

(** [df_origin] specific that the object being loaded may make reference to the
  * $(ORIGIN) substitution string.
  *)
let df_origin : natural = 1 (* 0x1 *)
(** [df_symbolic] changes the linker's symbol resolution algorithm, resolving
  * symbols first from the shared object file rather than the executable file.
  *)
let df_symbolic : natural = 2 (* 0x2 *)
(** [df_textrel] if this flag is not set then no relocation entry should cause
  * modification to a non-writable segment.
  *)
let df_textrel : natural = 4 (* 0x4 *)
(** [df_bindnow] if set this instructs the linker to process all relocation entries
  * of the containing object before transferring control to the program.
  *)
let df_bindnow : natural = 8 (* 0x8 *)
(** [df_static_tls] if set instructs the linker to reject all attempts to load
  * the containing file dynamically.
  *)
let df_static_tls : natural = 16 (* 0x10 *)

(** [string_of_dt_flag f] produces a string-based representation of dynamic
  * section flag [f].
  *)
val string_of_dt_flag : natural -> string
let string_of_dt_flag flag =
  if unsafe_natural_land flag df_origin <> 0 then
    "ORIGIN"
  else if unsafe_natural_land flag df_symbolic <> 0 then
    "SYMBOLIC"
  else if unsafe_natural_land flag df_textrel <> 0 then
    "TEXTREL"
  else if unsafe_natural_land flag df_bindnow <> 0 then
    "BIND_NOW"
  else if unsafe_natural_land flag df_static_tls <> 0 then
    "STATIC_TLS"
  else (* XXX: more as required *)
    "Invalid flag"
    
type rel_type
  = Rel
  | RelA
  
val string_of_rel_type : rel_type -> string
let string_of_rel_type r =
  match r with
    | Rel  -> "REL"
    | RelA -> "RELA"
  end
    
type dyn_value 'addr 'size
  = Address of 'addr
  | Size    of 'size
  | FName   of string
  | Path    of string
  | Library of string
  | Flags   of natural
  | Numeric of natural
  | RelType of rel_type
  | Null
  | Ignored
  
type elf32_dyn_value = dyn_value elf32_addr elf32_word
type elf64_dyn_value = dyn_value elf64_addr elf64_xword

val get_string_table_of_elf32_dyn_section : endianness -> list elf32_dyn -> elf32_section_header_table -> byte_sequence ->
  error string_table
let get_string_table_of_elf32_dyn_section endian dyns sht bs0 =
  let strtabs =
    List.filter (fun x ->
      integer_of_elf32_sword x.elf32_dyn_tag = integerFromNatural dt_strtab
    ) dyns
  in
    match strtabs with
      | [strtab] ->
        match strtab.elf32_dyn_d_un with
          | D_Val     v -> fail "get_string_table_of_elf32_dyn_section: STRTAB must be a PTR"
          | D_Ptr     p ->
            let sect =
              List.filter (fun s ->
                s.elf32_sh_addr = p &&
                  s.elf32_sh_type = elf32_word_of_natural sht_strtab
              ) sht
            in
              match sect with
                | []  -> fail "get_string_table_of_elf32_dyn_section: no section entry with same address as STRTAB"
                | [s] ->
                  let off = natural_of_elf32_off  s.elf32_sh_offset in
                  let siz = natural_of_elf32_word s.elf32_sh_size in
                  Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
                  let strings  = Byte_sequence.string_of_byte_sequence rel in
                  return (String_table.mk_string_table strings (Missing_pervasives.null_char))
                | _   -> fail "get_string_table_of_elf32_dyn_section: multiple section entries with same address as STRTAB"
              end
          | D_Ignored i -> fail "get_string_table_of_elf32_dyn_section: STRTAB must be a PTR"
        end
      | []       -> fail "get_string_table_of_elf32_dyn_section: no string table entry"
      | _        -> fail "get_string_table_of_elf32_dyn_section: multiple string table entries"
    end
    
val get_string_table_of_elf64_dyn_section : endianness -> list elf64_dyn -> elf64_section_header_table -> byte_sequence ->
  error string_table
let get_string_table_of_elf64_dyn_section endian dyns sht bs0 =
  let strtabs =
    List.filter (fun x ->
      integer_of_elf64_sxword x.elf64_dyn_tag = integerFromNatural dt_strtab
    ) dyns
  in
    match strtabs with
      | [strtab] ->
        match strtab.elf64_dyn_d_un with
          | D_Val     v -> fail "get_string_table_of_elf64_dyn_section: STRTAB must be a PTR"
          | D_Ptr     p ->
            let sect =
              List.filter (fun s ->
                s.elf64_sh_addr = p &&
                  s.elf64_sh_type = elf64_word_of_natural sht_strtab
              ) sht
            in
              match sect with
                | []  -> fail "get_string_table_of_elf64_dyn_section: no section entry with same address as STRTAB"
                | [s] ->
                  let off = natural_of_elf64_off  s.elf64_sh_offset in
                  let siz = natural_of_elf64_xword s.elf64_sh_size in
                  Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
                  let strings  = Byte_sequence.string_of_byte_sequence rel in
                  return (String_table.mk_string_table strings Missing_pervasives.null_char)
                | _   -> fail "get_string_table_of_elf64_dyn_section: multiple section entries with same address as STRTAB"
              end
          | D_Ignored i -> fail "get_string_table_of_elf64_dyn_section: STRTAB must be a PTR"
        end
      | []       -> fail "get_string_table_of_elf64_dyn_section: no string table entry"
      | _        -> fail "get_string_table_of_elf64_dyn_section: multiple string table entries"
    end
    
val get_value_of_elf32_dyn : elf32_dyn -> (natural -> bool) -> string_table -> error elf32_dyn_value
let get_value_of_elf32_dyn dyn os_additional_ranges stab =
  let tag = naturalFromInteger (integer_of_elf32_sword dyn.elf32_dyn_tag) in
    if tag = dt_null then
      return Null
    else if tag = dt_needed then
      match dyn.elf32_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf32_dyn_entry: NEEDED must be a Val"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: NEEDED must be a Val"
      end >>= fun off ->
        let off = natural_of_elf32_word off in
        String_table.get_string_at off stab >>= fun str ->
        return (Library str)
    else if tag = dt_pltrelsz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: PLTRELSZ must be a Val"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: PLTRELSZ must be a Val"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_pltgot then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: PLTGOT must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: PLTGOT must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_hash then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: HASH must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: HASH must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_strtab then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: STRTAB must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: STRTAB must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_symtab then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: SYMTAB must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: SYMTAB must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_rela then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: RELA must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RELA must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_relasz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: RELASZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RELASZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_relaent then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: RELAENT must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RELAENT must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_strsz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: STRSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: STRSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_syment then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: SYMENT must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: SYMENT must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_init then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: INIT must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: INIT must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_fini then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: FINI must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: FINI must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_soname then
      match dyn.elf32_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf32_dyn_entry: SONAME must be a Val"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: SONAME must be a Val"
      end >>= fun off ->
        let off = natural_of_elf32_word off in
        String_table.get_string_at off stab >>= fun str ->
        return (FName str)
    else if tag = dt_rpath then
      match dyn.elf32_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf32_dyn_entry: RPATH must be a Val"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RPATH must be a Val"
      end >>= fun off ->
        let off = natural_of_elf32_word off in
        String_table.get_string_at off stab >>= fun str ->
        return (Path str)
    else if tag = dt_symbolic then
      return Ignored
    else if tag = dt_rel then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: REL must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: REL must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_relsz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: RELSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RELSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_relent then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: RELENT must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RELENT must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_pltrel then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: PLTREL must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: PLTREL must be a VAL"
      end >>= fun r ->
        if natural_of_elf32_word r = dt_rel then
          return (RelType Rel)
        else if natural_of_elf32_word r = dt_rela then
          return (RelType RelA)
        else
          fail "get_value_of_elf32_dyn_entry: PLTREL neither REL nor RELA"
    else if tag = dt_debug then
      return Null
    else if tag = dt_textrel then
      return Ignored
    else if tag = dt_jmprel then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: JMPREL must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: JMPREL must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_bindnow then
      return Ignored
    else if tag = dt_init_array then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: INIT_ARRAY must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: INIT_ARRAY must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_fini_array then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: FINI_ARRAY must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: FINI_ARRAY must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_init_arraysz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: INIT_ARRAYSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: INIT_ARRAYSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_fini_arraysz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: FINI_ARRAYSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: FINI_ARRAYSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_runpath then
      match dyn.elf32_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf32_dyn_entry: RUNPATH must be a Val"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: RUNPATH must be a Val"
      end >>= fun off ->
        let off = natural_of_elf32_word off in
        String_table.get_string_at off stab >>= fun str ->
        return (Path str)
    else if tag = dt_flags then
      match dyn.elf32_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf32_dyn_entry: FLAGS must be a Val"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: FLAGS must be a Val"
      end >>= fun flags ->
        return (Flags (natural_of_elf32_word flags))
    else if tag = dt_encoding then
      fail "ENCODING"
    else if tag = dt_preinit_array then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf32_dyn_entry: PREINIT_ARRAY must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: PREINIT_ARRAY must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_preinit_arraysz then
      match dyn.elf32_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf32_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf32_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if os_additional_ranges tag then
      fail "YYY"
    else
      fail "get_value_of_elf32_dyn: unrecognised tag type"
      
val get_value_of_elf64_dyn : elf64_dyn -> (natural -> bool) -> string_table -> error elf64_dyn_value
let get_value_of_elf64_dyn dyn os_additional_ranges stab =
  let tag = naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag) in
    if tag = dt_null then
      return Null
    else if tag = dt_needed then
      match dyn.elf64_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf64_dyn_entry: NEEDED must be a Val"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: NEEDED must be a Val"
      end >>= fun off ->
        let off = natural_of_elf64_xword off in
        String_table.get_string_at off stab >>= fun str ->
        return (Library str)
    else if tag = dt_pltrelsz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: PLTRELSZ must be a Val"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: PLTRELSZ must be a Val"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_pltgot then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: PLTGOT must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: PLTGOT must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_hash then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: HASH must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: HASH must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_strtab then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: STRTAB must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: STRTAB must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_symtab then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: SYMTAB must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: SYMTAB must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_rela then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: RELA must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RELA must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_relasz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: RELASZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RELASZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_relaent then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: RELAENT must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RELAENT must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_strsz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: STRSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: STRSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_syment then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: SYMENT must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: SYMENT must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_init then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: INIT must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: INIT must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_fini then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: FINI must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: FINI must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_soname then
      match dyn.elf64_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf64_dyn_entry: SONAME must be a Val"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: SONAME must be a Val"
      end >>= fun off ->
        let off = natural_of_elf64_xword off in
        String_table.get_string_at off stab >>= fun str ->
        return (FName str)
    else if tag = dt_rpath then
      match dyn.elf64_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf64_dyn_entry: RPATH must be a Val"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RPATH must be a Val"
      end >>= fun off ->
        let off = natural_of_elf64_xword off in
        String_table.get_string_at off stab >>= fun str ->
        return (Path str)
    else if tag = dt_symbolic then
      return Ignored
    else if tag = dt_rel then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: REL must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: REL must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_relsz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: RELSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RELSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_relent then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: RELENT must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RELENT must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_pltrel then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: PLTREL must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: PLTREL must be a VAL"
      end >>= fun r ->
        if natural_of_elf64_xword r = dt_rel then
          return (RelType Rel)
        else if natural_of_elf64_xword r = dt_rela then
          return (RelType RelA)
        else
          fail "get_value_of_elf64_dyn_entry: PLTREL neither REL nor RELA"
    else if tag = dt_debug then
      return Null
    else if tag = dt_textrel then
      return Ignored
    else if tag = dt_jmprel then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: JMPREL must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: JMPREL must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_bindnow then
      return Ignored
    else if tag = dt_init_array then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: INIT_ARRAY must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: INIT_ARRAY must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_fini_array then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: FINI_ARRAY must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: FINI_ARRAY must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_init_arraysz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: INIT_ARRAYSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: INIT_ARRAYSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_fini_arraysz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: FINI_ARRAYSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: FINI_ARRAYSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if tag = dt_runpath then
      match dyn.elf64_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf64_dyn_entry: RUNPATH must be a Val"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: RUNPATH must be a Val"
      end >>= fun off ->
        let off = natural_of_elf64_xword off in
        String_table.get_string_at off stab >>= fun str ->
        return (Path str)
    else if tag = dt_flags then
      match dyn.elf64_dyn_d_un with
        | D_Val v     -> return v
        | D_Ptr p     -> fail "get_value_of_elf64_dyn_entry: FLAGS must be a Val"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: FLAGS must be a Val"
      end >>= fun flags ->
        return (Flags (natural_of_elf64_xword flags))
    else if tag = dt_encoding then
      fail "ENCODING"
    else if tag = dt_preinit_array then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> fail "get_value_of_elf64_dyn_entry: PREINIT_ARRAY must be a PTR"
        | D_Ptr     p -> return p
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: PREINIT_ARRAY must be a PTR"
      end >>= fun ptr ->
      return (Address ptr)
    else if tag = dt_preinit_arraysz then
      match dyn.elf64_dyn_d_un with
        | D_Val     v -> return v
        | D_Ptr     p -> fail "get_value_of_elf64_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
        | D_Ignored i -> fail "get_value_of_elf64_dyn_entry: PREINIT_ARRAYSZ must be a VAL"
      end >>= fun sz ->
      return (Size sz)
    else if os_additional_ranges tag then
      fail "YYY"
    else
      fail "get_value_of_elf64_dyn: unrecognised tag type"
