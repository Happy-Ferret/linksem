(*Generated by Lem from elf_program_header_table.lem.*)
open Lem_basic_classes
open Lem_bool
open Lem_function
open Lem_list
open Lem_num
open Lem_string

open Bitstring
open Error
open Elf_types
open Show

(** Segment types *)

(** Unused array element.  All other members of the structure are undefined. *)
let elf_pt_null : int =( 0)
(** A loadable segment. *)
let elf_pt_load : int =( 1)
(** Dynamic linking information. *)
let elf_pt_dynamic : int =( 2)
(** Specifies the location and size of a null-terminated path name to be used to
  * invoke an interpreter.
  *)
let elf_pt_interp : int =( 3)
(** Specifies location and size of auxiliary information. *)
let elf_pt_note : int =( 4)
(** Reserved but with unspecified semantics.  If the file contains a segment of
  * this type then it is to be regarded as non-conformant with the ABI.
  *)
let elf_pt_shlib : int =( 5)
(** Specifies the location and size of the program header table. *)
let elf_pt_phdr : int =( 6)
(** Specifies the thread local storage (TLS) template.  Need not be supported. *)
let elf_pt_tls : int =( 7)
(** Start of reserved indices for operating system specific semantics. *)
let elf_pt_loos : int =( 0) (* XXX: too big for Lem? 1610612736 (* 0x60000000 *) *)
(** End of reserved indices for operating system specific semantics. *)
let elf_pt_hios : int =( 0) (* XXX: too big for Lem? 1879048191 (* 0x6fffffff *) *)
(** Start of reserved indices for processor specific semantics. *)
let elf_pt_loproc : int =( 0) (* XXX: too big for Lem? 1879048192 (* 0x70000000 *) *)
(** End of reserved indices for processor specific semantics. *)
let elf_pt_hiproc : int =( 0) (* XXX: too big for Lem? 2147483647 (* 0x7fffffff *) *)

let string_of_elf_segment_type os proc pt =	
(if pt = elf_pt_null then
		"PT_NULL"
	else if pt = elf_pt_load then
		"PT_LOAD"
	else if pt = elf_pt_dynamic then
		"PT_DYNAMIC"
	else if pt = elf_pt_interp then
		"PT_INTERP"
	else if pt = elf_pt_note then
		"PT_NOTE"
	else if pt = elf_pt_shlib then
		"PT_SHLIB"
	else if pt = elf_pt_phdr then
		"PT_PHDR"
	else if pt = elf_pt_tls then
		"PT_TLS"
	else if (pt >= elf_pt_loos) && (pt <= elf_pt_hios) then
		os pt
	else if (pt >= elf_pt_loproc) && (pt <= elf_pt_hiproc) then
		proc pt
	else
		"XXX: invalid segment type")

(** Program header entry type *)

type elf32_program_header_entry =
  { p_type  : Int64.t (** Type of the segment *)
  ; p_offset : Int64.t  (** Offset from beginning of file for segment *)
  ; p_vaddr  : Int64.t (** Virtual address for segment in memory *)
  ; p_paddr  : Int64.t (** Physical address for segment *)
  ; p_filesz : Int64.t (** Size of segment in file, in bytes *)
  ; p_memsz  : Int64.t (** Size of segment in memory image, in bytes *)
  ; p_flags  : Int64.t (** Segment flags *)
  ; p_align  : Int64.t (** Segment alignment memory for memory and file *)
  }
  
let string_of_elf32_program_header_entry os proc entry =	
(List.fold_right (^) [
		"\t"; "Segment type: "; string_of_elf_segment_type os proc (Int64.to_int entry.p_type)
	; "\t"; "Offset: "; Int64.to_string entry.p_offset
	; "\n\t"; "Virtual address: "; Int64.to_string entry.p_vaddr
	; "\t"; "Physical address: "; Int64.to_string entry.p_paddr
	; "\n\t"; "Segment size (bytes): "; Int64.to_string entry.p_filesz
	; "\t"; "Segment size in memory image (bytes): "; Int64.to_string entry.p_memsz
	; "\n\t"; "Flags: "; Int64.to_string entry.p_flags
  ; "\t"; "Alignment: "; Int64.to_string entry.p_align; "\n\n"
	] "")
	
let string_of_elf32_program_header_entry_default =	
(string_of_elf32_program_header_entry ((fun y->"OS specific")) ((fun y->"Processor specific")))
	
let instance_Show_Show_Elf_program_header_table_elf32_program_header_entry_dict =({

  show_method = string_of_elf32_program_header_entry_default})
  
(*val read_elf32_program_header_entry : bitstring -> error (elf32_program_header_entry * bitstring)*)
let read_elf32_program_header_entry bs =	
(Ml_bindings.read_elf32_word bs >>= (fun (typ, bs) ->
	Ml_bindings.read_elf32_off  bs >>= (fun (offset, bs) ->
	Ml_bindings.read_elf32_addr bs >>= (fun (vaddr, bs) ->
	Ml_bindings.read_elf32_addr bs >>= (fun (paddr, bs) ->
	Ml_bindings.read_elf32_word bs >>= (fun (filesz, bs) ->
	Ml_bindings.read_elf32_word bs >>= (fun (memsz, bs) ->
	Ml_bindings.read_elf32_word bs >>= (fun (flags, bs) ->
	Ml_bindings.read_elf32_word bs >>= (fun (align, bs) ->
		Success (
			{ p_type = typ
			 ; p_offset = offset
			 ; p_vaddr = vaddr
			 ; p_paddr = paddr
			 ; p_filesz = filesz
			 ; p_memsz = memsz
			 ; p_flags = flags
			 ; p_align = align
			 }, bs))))))))))

(** Program header table type *)
type elf32_program_header_table = elf32_program_header_entry list

let rec read_elf32_program_header_table' bitstring1 =	
(if Bitstring.bitstring_length bitstring1 = 0 then
  	return []
  else
  	read_elf32_program_header_entry bitstring1 >>= (fun (entry, bitstring0) ->
    read_elf32_program_header_table' bitstring0 >>= (fun tail ->
    return (entry::tail))))

let read_elf32_program_header_table table_size bitstring0 =	
(let (eat, rest) = (Utility.partition_bitstring table_size bitstring0) in
		read_elf32_program_header_table' eat >>= (fun table ->
		return (table, rest)))
		
let string_of_elf32_program_header_table os proc tbl =	
("Program header table contents:" ^ ("\n" ^
		List.fold_right (^) (List.map (string_of_elf32_program_header_entry os proc) tbl) "\n"))
