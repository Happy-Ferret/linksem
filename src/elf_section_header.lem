open import Basic_classes
open import Bool
open import List
open import Maybe

open import Elf_types

(** Special section indices. *)

(** [shn_undef]: marks an undefined, missing or irrelevant section reference.
  *)
val shn_undef : nat
let shn_undef = 0
;;

(** [shn_loreserve]: this specifies the lower bound of the range of reserved
  * indices.
  *)
val shn_loreserve : nat
let shn_loreserve = 65280 (* 0xff00 *)
;;

(** [shn_loproc]: start of the range reserved for processor-specific semantics.
  *)
val shn_loproc : nat
let shn_loproc = 65280 (* 0xff00 *)
;;

(** [shn_hiproc]: end of the range reserved for processor-specific semantics.
  *)
val shn_hiproc : nat
let shn_hiproc = 65311 (* 0xff1f *)
;;

(** [shn_loos]: start of the range reserved for operating system-specific
  * semantics.
  *)
val shn_loos : nat
let shn_loos = 65312 (* 0xff20 *)
;;

(** [shn_hios]: end of the range reserved for operating system-specific
  * semantics.
  *)
val shn_hios : nat
let shn_hios = 65343 (* 0xff3f *)
;;

(** [shn_abs]: specifies the absolute values for the corresponding reference.
  * Symbols defined relative to section number [shn_abs] have absolute values
  * and are not affected by relocation.
  *)
val shn_abs : nat
let shn_abs = 65521 (* 0xfff1 *)
;;

(** [shn_common]: symbols defined relative to this index are common symbols,
  * such as unallocated C external variables.
  *)
val shn_common : nat
let shn_common = 65522 (* 0xfff2 *)
;;

(** [shn_xindex]: an escape value.  It indicates the actual section header index
  * is too large to fit in the containing field and is located in another
  * location (specific to the structure where it appears).
  *)
val shn_xindex : nat
let shn_xindex = 65535 (* 0xffff *)
;;

(** [shn_hireserve]: specifies the upper-bound of reserved values.
  *)
val shn_hireserve : nat
let shn_hireserve = 65535 (* 0xffff *)
;;


(** Section types. *)

val sht_null : nat
let sht_null = 0
;;

val sht_progbits : nat
let sht_progbits = 1
;;

val sht_symtab : nat
let sht_symtab = 2
;;

val sht_strtab : nat
let sht_strtab = 3
;;

val sht_rela : nat
let sht_rela = 4
;;

val sht_hash : nat
let sht_hash = 5
;;

val sht_dynamic : nat
let sht_dynamic = 6
;;

val sht_note : nat
let sht_note = 7
;;

val sht_nobits : nat
let sht_nobits = 8
;;

val sht_rel : nat
let sht_rel = 9
;;

val sht_shlib : nat
let sht_shlib = 10
;;

val sht_dynsym : nat
let sht_dynsym = 11
;;

val sht_init_array : nat
let sht_init_array = 14
;;

val sht_fini_array : nat
let sht_fini_array = 15
;;

val sht_preinit_array : nat
let sht_preinit_array = 16
;;

val sht_group : nat
let sht_group = 17
;;

val sht_symtab_shndx : nat
let sht_symtab_shndx = 18
;;

val sht_loos : nat
let sht_loos = 1610612736 (* 0x60000000 *)
;;

val sht_hios : nat
let sht_hios = 1879048191 (* 0x6fffffff *)
;;

val sht_loproc : nat
let sht_loproc = 1879048192 (* 0x70000000 *)
;;

val sht_hiproc : nat
let sht_hiproc = 2147483647 (* 0x7fffffff *)
;;

val sht_louser : nat
let sht_louser = 2147483648 (* 0x80000000 *)
;;

val sht_hiuser : nat
let sht_hiuser = 2415919103 (* 0x8fffffff *)
;;

(** Section header type. *)

type elf32_shdr =
  <| e32_sh_name      : elf32_word
   ; e32_sh_type      : elf32_word
   ; e32_sh_addr      : elf32_addr
   ; e32_sh_offset    : elf32_off
   ; e32_sh_size      : elf32_word
   ; e32_sh_link      : elf32_word
   ; e32_sh_info      : elf32_word
   ; e32_sh_addralign : elf32_word
   ; e32_sh_entsize   : elf32_word
   |>

type elf64_shdr =
  <| e64_sh_name      : elf64_word
   ; e64_sh_type      : elf64_word
   ; e64_sh_addr      : elf64_addr
   ; e64_sh_offset    : elf64_off
   ; e64_sh_size      : elf64_word
   ; e64_sh_link      : elf64_word
   ; e64_sh_info      : elf64_word
   ; e64_sh_addralign : elf64_word
   ; e64_sh_entsize   : elf64_word
   |>

(** Section header table type. *)

type elf32_section_header_table = list elf32_shdr
;;

val elf32_size_correct : elf32_shdr -> elf32_section_header_table -> bool
let elf32_size_correct hdr tbl =
  match hdr.e32_sh_size with
    | 0 -> true
    | m -> m = length tbl
  end
;;

val is_valid_elf32_section_header_table : elf32_section_header_table -> bool
let is_valid_elf32_section_header_table tbl =
  match tbl with
    | []    -> false
    | x::xs ->
        x.e32_sh_name = 0 &&
        x.e32_sh_type = sht_null &&
        x.e32_sh_flags = 0 &&
        x.e32_sh_addr = 0 &&
        x.e32_sh_offset = 0 &&
        x.e32_sh_info = 0 &&
        x.e32_sh_addralign = 0 &&
        x.e32_sh_entsize = 0 &&
        size_correct x tbl &&
        link_correct x
  end
;;

type elf64_section_header_table = list elf64_shdr
;;