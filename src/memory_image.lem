open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Map
open import Set
open import Multimap
open import Num
open import Maybe
open import Assert_extra
open import Show

open import Byte_sequence
open import Elf_file
open import Elf_header
open import Elf_interpreted_segment
open import Elf_interpreted_section
open import Elf_program_header_table
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Elf_relocation

open import Missing_pervasives

(* Now we can define memory images *)

type byte_pattern_element = maybe byte
type byte_pattern = list byte_pattern_element

(* An element might have an address/offset, and it has some contents. *)
type memory_image_element = <| startpos : maybe natural 
                             ; length   : maybe natural
                             ; contents : byte_pattern
                             |>

(* HMM -- ideally I want to fold these into the memory image notion
 * and the startpos thingy. *)
type allocated_symbols_map = Map.map string (natural * natural) (* start, length *)

(* Instead of modelling address calculations (in linker scripts) like so:

type address_expr = natural -> allocated_symbols_map -> natural
                  ( pos     -> environment           -> result address )
                  
   ... we model it as expressions in terms of CursorPosition. HMM.
*) 

type expr_operand = Var of string
                   | CursorPosition          (* only valid in certain expressions... HMM *)
                   | Constant of natural
                   | UnOp of (expr_unary_operation * expr_operand)
                   | BinOp of (expr_binary_operation * expr_operand * expr_operand)
and
expr_unary_operation = Neg of expr_operand
                           | BitwiseInverse of expr_operand
and 
expr_binary_operation = Add of (expr_operand * expr_operand)
                           | Sub of (expr_operand * expr_operand)
                           | BitwiseAnd of (expr_operand * expr_operand)
                           | BitwiseOr of (expr_operand * expr_operand)

type expr_binary_relation = 
    Lt
    | Lte
    | Gt
    | Gte
    | Eq
    | Neq

type expr = 
    False
    | True
    | Not of expr
    | And of (expr * expr)
    | Or of (expr * expr)
    | BinRel of (expr_binary_relation * expr_operand)  (* LH operand is the expr's value *)

(*
val cond_expr : expr -> expr -> expr -> expr
let cond_expr expr1 expr2 expr3 = (Or((And(expr1, expr2)), (And((Not(expr1)), expr3))))
*)

(* Memory image elements all have identities. For convenience
 * we make the identities strings. The string contents are arbitrary,
 * and only their equality is relevant, but choosing friendly names
 * like "ELF header" is good practice.*)
type memory_image = Map.map string memory_image_element
(* An "element" of an ELF image, in the linking phase, is either a section,
 * the ELF header, the section header table or the program header table.
 * 
 * PROBLEM: We'd like to use section names as the identifiers
 * for those elements that are sections.
 * but we can't, because they are not guaranteed to be unique. 
 * 
 * SOLUTION: Names that are unique in the file are used as keys. 
 * If not unique, the sections are treated as anonymous and given
 * gensym'd string ids (FIXME: implement this).
 *)

(* Currently, our elements have unique names, which are strings.
 * We *don't* want to encode any meaning onto these strings.
 * All meaning should be encoded into labelled ranges.
 * We want to be able to look up 
 *
 * - elements
 * - ranges within elements
 * 
 * ... by their *labels* -- or sometimes just *part* of their labels.
 *)

(* ELF file features with which we can label ranges of the memory image. *)
type elf_file_feature = 
    ElfHeader of elf64_header
    | ElfSectionHeaderTable of elf64_section_header_table (* do we want to expand these? *)
    | ElfProgramHeaderTable of elf64_program_header_table
    | ElfSection of (natural * elf64_interpreted_section) (* SHT idx *)
    | ElfSegment of (natural * elf64_interpreted_segment) (* PHT idx *)

type symbol_reference
 = <| ref_symname : string                  (* symbol name *)
    ; ref_syment : elf64_symbol_table_entry (* undefined (referencing) symbol *)
    ; ref_sym_scn : natural                 (* symtab section idx *) 
    ; ref_sym_idx : natural                 (* index into symbol table *)
    |>

let symRefCompare x1 x2 =
        compare (x1.ref_symname, x1.ref_syment, x1.ref_sym_scn, x1.ref_sym_idx)
                (x2.ref_symname, x2.ref_syment, x2.ref_sym_scn, x2.ref_sym_idx)
                
instance (Ord symbol_reference)
    let compare = symRefCompare
    let (<) = fun f1 -> (fun f2 -> (symRefCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (symRefCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (symRefCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (symRefCompare f1 f2) {GT; EQ})
end

type reloc_site = <|
      ref_relent  : elf64_relocation_a 
    ; ref_rel_scn : natural  (* the relocation section idx *)
    ; ref_rel_idx : natural  (* the index of the relocation rec *)
    ; ref_src_scn : natural  (* the section *from which* the reference logically comes *)
|>

let relocSiteCompare x1 x2 =
        compare (x1.ref_relent, x1.ref_rel_idx, x1.ref_src_scn)
                (x2.ref_relent, x2.ref_rel_idx, x2.ref_src_scn)
                
instance (Ord reloc_site)
    let compare = relocSiteCompare
    let (<) = fun f1 -> (fun f2 -> (relocSiteCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (relocSiteCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (relocSiteCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (relocSiteCompare f1 f2) {GT; EQ})
end

type symbol_reference_and_reloc_site = <|
      ref         : symbol_reference
    ; maybe_reloc : maybe reloc_site
    |>

let symRefAndRelocSiteCompare x1 x2 =
        compare (x1.ref, x1.maybe_reloc)
                (x2.ref, x2.maybe_reloc)

instance (Ord symbol_reference_and_reloc_site)
    let compare = symRefAndRelocSiteCompare
    let (<) = fun f1 -> (fun f2 -> (symRefAndRelocSiteCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (symRefAndRelocSiteCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (symRefAndRelocSiteCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (symRefAndRelocSiteCompare f1 f2) {GT; EQ})
end

type symbol_definition
 = <| def_symname : string
    ; def_syment : elf64_symbol_table_entry (* definition's symtab entry *)
    ; def_sym_scn : natural                 (* symtab section index, to disamiguate dynsym *)
    ; def_sym_idx : natural                 (* index of symbol into the symtab *)
    |>

let symDefCompare x1 x2 =
        compare (x1.def_symname, x1.def_syment, x1.def_sym_scn, x1.def_sym_idx)
                (x2.def_symname, x2.def_syment, x2.def_sym_scn, x2.def_sym_idx)

instance (Ord symbol_definition)
    let compare = symDefCompare
    let (<) = fun f1 -> (fun f2 -> (symDefCompare f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> Set.member (symDefCompare f1 f2) {LT; EQ})
    let (>) = fun f1 -> (fun f2 -> (symDefCompare f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> Set.member (symDefCompare f1 f2) {GT; EQ})
end

class (ToNaturalList 'a)
    val toNaturalList : 'a -> list natural
end

(* In order to store tags in a set, we need a total ordering
 * to be defined on them.
 * 
 * But also, in order to look up entries 
 * by tag constructor *alone* (e.g. ImageBase, EntryPoint, etc.)
 * we need a looser version of the same ordering.
 * 
 * So we factor it into a few stages.
 * 
 * - map tag constructors to integers. We'll use this to define the 
 * equivalence classes. Since we want to do queries of the form
 *
 *     FileFeature(ElfSection(_))
 *
 * to get all sections, say, we actually map to a *list* of integers,
 * where each constructor contributes one element to the list.
 * Since lists are lexicographically ordered, we get a total ordering
 * just as good as if we'd used only naturals.
 *)


(* We can also annotate arbitrary ranges of bytes within an element
 * with arbitrary metadata. 
 * 
 * Ideally we want to data-abstract this a bit. But it's hard to do
 * so without baking in ELF-specific and/or (moreover) per-ABI concepts, 
 * like PLTs and GOTs. Ideally we would use something like polymorphic
 * variants here. For now, this has to be the union of all the concepts
 * that we find in the various ABIs we care about. To avoid ELFy things
 * creeping in, we parameterise by 'a, and instantiate the 'a with the
 * relevant ELFy thing when we use it. OH, but then 'a is different for
 * every distinct ELF thing, which is no good. Can we define a mapping
 * from an umbrella "ELF" type to the relevant types in each case? *)
type range_tag 'abifeature = (*  forall 'abifeature . *)
                 ImageBase
               | EntryPoint
               | SymbolDef of symbol_definition
               | SymbolRef of symbol_reference_and_reloc_site
               | FileFeature of elf_file_feature (* file feature other than symdef and reloc *)
               | AbiFeature of 'abifeature

type range = natural * natural (* start, length *)

type element_range = string * range

type annotated_memory_image 'abifeature = <|
      elements         : memory_image 
    ; by_range         : multimap (maybe element_range) (range_tag 'abifeature)
    ; by_tag           : multimap (range_tag 'abifeature) (maybe element_range)
|>

(* Basic ELFy and ABI-y things. *)
(* FIXME: shouldn't really be here, but need to be in some low-lying module, and 
 * keeping out of elf_* for now to avoid duplication into elf64_, elf32_. *)
let elf_section_is_special s f = s.elf64_section_type <> sht_progbits
                     && s.elf64_section_type <> sht_nobits

val noop_reloc : forall 'abifeature. natural -> ((maybe elf64_symbol_table_entry -> natural) * (annotated_memory_image 'abifeature -> maybe natural))
let noop_reloc r = (fun r_type -> 8, fun sym_val -> Nothing)

(* This record collects things that ABIs may or must define. 
 * 
 * Since we want to put all ABIs in a list and select one at run time, 
 * we can't maintain a type-level distinction between ABIs; we have to
 * use elf_memory_image any_abi_feature. To avoid a reference cycle,
 * stay polymorphic in the ABI feature type until we define specific ABIs.
 * In practice we'll use only any_abi_feature, because we need to pull
 * the ABI out of a list at run time.
 *)
type null_abi_feature = unit

type abi 'abifeature = (* forall 'abifeature. *)
   <| is_valid_elf_header : elf64_header -> bool
                        (* doesn't this generalise outrageously? is_valid_elf_file? *)
    (* Do we want "existing", or is it a kind of addend? 
     * We do want it -- modelling both separately is necessary, 
     * because we model relocations bytewise, but some arches
     * do bitfield relocations (think ARM). *)
    ; reloc              : natural -> ((maybe elf64_symbol_table_entry -> natural) * (annotated_memory_image 'abifeature -> maybe natural))
                        (* number  ->  width   * (symaddr -> addend  -> existing-> relocated) *)
    ; section_is_special : elf64_interpreted_section -> annotated_memory_image 'abifeature -> bool
    ; section_is_large   : elf64_interpreted_section -> annotated_memory_image 'abifeature -> bool
    ; maxpagesize        : natural
    ; minpagesize        : natural
    ; commonpagesize     : natural
    |>

val range_contains : (natural * natural) -> (natural * natural) -> bool
let range_contains (r1begin, r1len) (r2begin, r2len) = 
    (* r1 is at least as big as r2 *)
    r2begin >= r1begin && (r2begin + r2len) <= (r1begin + r1len)

val range_overlaps : (natural * natural) -> (natural * natural) -> bool
let range_overlaps (r1begin, r1len) (r2begin, r2len) =
    (r1begin < (r2begin + r2len) && (r1begin + r1len) > r2begin)
     || (r2begin < (r1begin + r1len) && (r2begin + r2len) > r1begin)
    
val is_partition : list (natural * natural) -> list (natural * natural) -> bool
let is_partition rs ranges = 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    let r_is_contained_by_some_range
     = fun r -> foldl (||) false (List.map (fun range -> range_contains range r) ranges)
    in
    List.all (fun r -> r_is_contained_by_some_range r) rs
    &&
    (* 2. elements of the first list do not overlap *)
    List.all (fun r -> List.all (fun r2 -> (r = (* should be "=="? *) r2) || (not (range_overlaps r r2))) rs) rs

val     nat_range : natural -> natural -> list natural
let rec nat_range base len =
    match len with 
        0 -> []
    |   _ -> base :: (nat_range (base + 1) (len - 1))
    end

(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
val expand_sorted_ranges : list (natural * natural) -> natural -> list bool -> list bool
let rec expand_sorted_ranges sorted_ranges min_length accum =
    match sorted_ranges with
        [] -> accum ++ (
            let pad_length = max 0 (min_length - (Missing_pervasives.length accum))
            in
            (* let _ = Missing_pervasives.println (
                "padding ranges cares list with " ^ (show pad_length) ^ 
                " cares (accumulated " ^ (show (Missing_pervasives.length accum)) ^ 
                ", min length " ^ (show min_length) ^ ")")
            in *)
            Missing_pervasives.replicate pad_length true)
     |  (base, len) :: more -> 
            (* pad the accum so that it reaches up to base *)
            let up_to_base = (Missing_pervasives.replicate (base - (Missing_pervasives.length accum)) true)
            in
            let up_to_end_of_range = up_to_base ++ (Missing_pervasives.replicate len false)
            in
            expand_sorted_ranges more min_length (accum ++ up_to_end_of_range)
    end

val expand_unsorted_ranges : list (natural * natural) -> natural -> list bool -> list bool
let rec expand_unsorted_ranges unsorted_ranges min_length accum =
    expand_sorted_ranges (sortBy (fun (base1, len1) -> (fun (base2, len2) -> base1 < base2)) unsorted_ranges) min_length accum

val make_byte_pattern : list byte -> list bool -> list (maybe byte)
let rec make_byte_pattern bytes cares = 
    match bytes with
          [] -> []
        | b :: bs -> match cares with 
                care :: more -> (if not care then Nothing else Just b) :: (make_byte_pattern bs more)
              | _ -> failwith "make_byte_pattern: unequal length"
              end
    end

val relax_byte_pattern : list (maybe byte) -> list bool -> list (maybe byte)
let rec relax_byte_pattern bytes cares = 
    match bytes with
          [] -> []
        | b :: bs -> match cares with 
                care :: more -> (if not care then Nothing else b) :: (relax_byte_pattern bs more)
              | _ -> failwith ("relax_byte_pattern: unequal length (no more cares with " ^ (show (Missing_pervasives.length (b :: bs))) ^ " bytes left)")
              end
    end


val byte_option_matches_byte : maybe byte -> byte -> bool
let byte_option_matches_byte optb b =
    match optb with 
            Nothing -> true 
        |   Just some -> some = b 
    end

val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool
let rec byte_list_matches_pattern pattern bytes = 
    match pattern with 
        [] -> true
        | optbyte :: more -> match bytes with 
                [] -> false
                | abyte :: morebytes -> 
                    byte_option_matches_byte optbyte abyte 
                 && byte_list_matches_pattern more morebytes
            end
    end

val append_to_byte_pattern_at_offset : natural -> list (maybe byte) -> list (maybe byte) -> list (maybe byte)
let append_to_byte_pattern_at_offset offset pat1 pat2 =
    let pad_length = offset - Missing_pervasives.length pat1
    in
    if pad_length < 0 then failwith "can't append at offset already used"
    else pat1 ++ (List.replicate (unsafe_nat_of_natural pad_length) Nothing) ++ pat2

val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural
let rec accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum =
    (* let _ = Missing_pervasives.prints ("At offset " ^ (show offset) ^ "... ")
    in *)
    match pattern with
        [] -> (* let _ = Missing_pervasives.prints ("terminating with hit (empty pattern)\n") in *)
            offset :: accum
        | bpe :: more_bpes -> (* nonempty, so check for nonempty seq *)
            match seq with 
                [] -> (*let _ = Missing_pervasives.prints ("terminating with miss (empty pattern)\n") 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte :: more_bytes -> let matched_this_byte = 
                            byte_option_matches_byte bpe byte
                       in
                       (* let _ = Missing_pervasives.prints ("Byte " ^ (show byte) ^ " matched " ^ (show byte_pattern) ^ "? " ^ (show matched_this_byte) ^ "; ") 
                       in *)
                       let sequence_long_enough = (seq_len >= pattern_len) 
                       in
                       (* let _ = Missing_pervasives.prints ("enough bytes remaining (" ^ (show seq_len) ^ ") to match rest of pattern (" ^ (show pattern_len) ^ ")? " ^ (show sequence_long_enough) ^ "; ") 
                       in *)
                       let matched_here = matched_this_byte && sequence_long_enough &&
                        byte_list_matches_pattern more_bpes more_bytes
                       in
                       (* let _ = Missing_pervasives.prints ("matched pattern anchored here? " ^ (show matched_this_byte) ^ "\n") 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len - 1) 
                           (offset + 1) 
                           (if matched_here then offset :: accum else accum)
            end
    end

val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural
let pattern_possible_starts_in_one_byte_sequence pattern seq offset =
    (* let _ = Missing_pervasives.prints ("Looking for matches of " ^
        (show (List.length pattern)) ^ "-byte pattern in " ^ (show (List.length seq)) ^ "-byte region\n")
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset []

val byte_pattern_of_byte_sequence : byte_sequence -> list (maybe byte)
let byte_pattern_of_byte_sequence seq = match seq with
    Sequence(bs) -> List.map (fun b -> Just b) bs
end

val compute_virtual_address_adjustment : natural -> natural -> natural -> natural
let compute_virtual_address_adjustment max_page_size offset vaddr =
  (vaddr - offset) mod max_page_size
