open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Map
open import Set
open import Multimap
open import Num
open import Maybe
open import Assert_extra

open import Elf_file
open import Elf_header
open import Elf_interpreted_segment
open import Elf_interpreted_section
open import Elf_program_header_table
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint

open import Missing_pervasives

(* Now we can define memory images *)

type byte_pattern = maybe byte

(* An element might have an address/offset, and it has some contents. *)
type memory_image_element = <| startpos : maybe natural 
                             ; length   : maybe natural
                             ; contents : list byte_pattern
                             |>

(* HMM -- ideally I want to fold these into the memory image notion
 * and the startpos thingy. *)
type allocated_symbols_map = Map.map string (natural * natural) (* start, length *)

(* Instead of modelling address calculations (in linker scripts) like so:

type address_expr = natural -> allocated_symbols_map -> natural
                  ( pos     -> environment           -> result address )
                  
   ... we model it as expressions in terms of CursorPosition. HMM.
*) 

type expr_operand = Var of string
                   | CursorPosition          (* only valid in certain expressions... HMM *)
                   | Constant of natural
                   | UnOp of (expr_unary_operation * expr_operand)
                   | BinOp of (expr_binary_operation * expr_operand * expr_operand)
and
expr_unary_operation = Neg of expr_operand
                           | BitwiseInverse of expr_operand
and 
expr_binary_operation = Add of (expr_operand * expr_operand)
                           | Sub of (expr_operand * expr_operand)
                           | BitwiseAnd of (expr_operand * expr_operand)
                           | BitwiseOr of (expr_operand * expr_operand)

type expr_binary_relation = 
    Lt
    | Lte
    | Gt
    | Gte
    | Eq
    | Neq

type expr = 
    False
    | True
    | Not of expr
    | And of (expr * expr)
    | Or of (expr * expr)
    | BinRel of (expr_binary_relation * expr_operand)  (* LH operand is the expr's value *)

(*
val cond_expr : expr -> expr -> expr -> expr
let cond_expr expr1 expr2 expr3 = (Or((And(expr1, expr2)), (And((Not(expr1)), expr3))))
*)

(* Memory image elements all have identities. For convenience
 * we make the identities strings. The string contents are arbitrary,
 * and only their equality is relevant, but choosing friendly names
 * like "ELF header" is good practice.*)
type memory_image = Map.map string memory_image_element
(* An "element" of an ELF image, in the linking phase, is either a section,
 * the ELF header, the section header table or the program header table.
 * 
 * PROBLEM: We'd like to use section names as the identifiers
 * for those elements that are sections.
 * but we can't, because they are not guaranteed to be unique. 
 * 
 * SOLUTION: Names that are unique in the file are used as keys. 
 * If not unique, the sections are treated as anonymous and given
 * gensym'd string ids (FIXME: implement this).
 * 
 * FIXME: am I sure that a multimap is not the right solution?
 * It defeats the concept of unique IDs, but maybe they're not necessary.
 *)

(* Currently, our elements have unique names, which are strings.
 * We *don't* want to encode any meaning onto these strings.
 * All meaning should be encoded into labelled ranges.
 * We want to be able to look up 
 *
 * - elements
 * - ranges within elements
 * 
 * ... by their *labels* -- or sometimes just *part* of their labels.
 *)

(* ELF file features with which we can label ranges of the memory image. *)
type elf_file_feature = 
    ElfHeader of elf64_header
    | ElfSectionHeaderTable of elf64_section_header_table (* do we want to expand these? *)
    | ElfProgramHeaderTable of elf64_program_header_table
    | ElfSection of (natural * elf64_interpreted_section) (* SHT idx *)
    | ElfSegment of (natural * elf64_interpreted_segment) (* PHT idx *)

type symbol_reference
 = <| ref_symname : string                  (* symbol name *)
    ; ref_syment : elf64_symbol_table_entry (* undefined (referencing) symbol *)
    ; ref_sym_scn : natural                 (* symtab section idx *) 
    ; ref_sym_idx : natural                 (* index into symbol table *)
      (* TODO: might also want rel section index, i.e. bind at relocation-record granularity.
       * Currently we bind only at undef-symbol-name-per-input-object granularity. *)
    |>

type symbol_definition
 = <| def_symname : string
    ; def_syment : elf64_symbol_table_entry (* definition's symtab entry *)
    ; def_sym_scn : natural                 (* symtab section index, to disamiguate dynsym *)
    |>

type amd64_abi_feature
type aarch64_le_abi_feature
type any_abi_feature = Amd64AbiFeature of amd64_abi_feature
                     | Aarch64LeAbiFeature of aarch64_le_abi_feature

(* We can also annotate arbitrary ranges of bytes within an element
 * with arbitrary metadata. 
 * 
 * Ideally we want to data-abstract this a bit. But it's hard to do
 * so without baking in ELF-specific and/or (moreover) per-ABI concepts, 
 * like PLTs and GOTs. Ideally we would use something like polymorphic
 * variants here. For now, this has to be the union of all the concepts
 * that we find in the various ABIs we care about. To avoid ELFy things
 * creeping in, we parameterise by 'a, and instantiate the 'a with the
 * relevant ELFy thing when we use it. OH, but then 'a is different for
 * every distinct ELF thing, which is no good. Can we define a mapping
 * from an umbrella "ELF" type to the relevant types in each case? *)
type range_tag =
               | ImageBase
               | EntryPoint
               | SymbolDef of symbol_definition
               | RelocationSite of symbol_reference
               | FileFeature of elf_file_feature (* file feature other than symdef and reloc *)
               | AbiFeature of any_abi_feature

type range = natural * natural (* start, length *)

type element_range = string * range

type annotated_memory_image = <|
      by_name : memory_image 
    ; by_element_range : map element_range (list range_tag)
    ; by_tag           : multimap range_tag (string * range)
|>

let empty_annotated_memory_image = <|
      by_name = Map.empty
    ; by_element_range = Map.empty
    ; by_tag = Set.empty
|>

val tagCompare : range_tag -> range_tag -> Basic_classes.ordering
let tagCompare k1 k2 = 
    match (k1, k2) with
        (ImageBase, ImageBase) -> EQ
        | (EntryPoint, EntryPoint) -> EQ
        | (SymbolDef(_), SymbolDef(_)) -> EQ
        | (RelocationSite(_), RelocationSite(_)) -> EQ
        | (FileFeature(arg1), FileFeature(arg2)) -> setElemCompare arg1 arg2
        | (AbiFeature(arg1), AbiFeature(arg2)) -> setElemCompare arg1 arg2
        (* what compares LT? *)
        | (ImageBase, _) -> LT
        | (EntryPoint, SymbolDef(_)) -> LT
        | (EntryPoint, RelocationSite(_)) -> LT
        | (EntryPoint, FileFeature(_)) -> LT
        | (EntryPoint, AbiFeature(_)) -> LT
        | (SymbolDef(_), RelocationSite(_)) -> LT
        | (SymbolDef(_), FileFeature(_)) -> LT
        | (SymbolDef(_), AbiFeature(_)) -> LT
        | (RelocationSite(_), FileFeature(_)) -> LT
        | (RelocationSite(_), AbiFeature(_)) -> LT
        | (FileFeature(_), AbiFeature(_)) -> LT
        (* else it's GT *)
        | (_, _) -> GT
    end

val tagMatches : range_tag -> range_tag -> bool
let tagMatches k1 k2 = tagCompare k1 k2 = EQ

(* 
instance (SetType range_tag)
    let setElemCompare = tagCompare
end
*)
instance (Ord range_tag)
    let compare = tagCompare
    let (<) = fun tag1 -> (fun tag2 -> (tagCompare tag1 tag2 = LT))
    let (<=) = fun tag1 -> (fun tag2 -> Set.member (tagCompare tag1 tag2) {LT; EQ})
    let (>) = fun tag1 -> (fun tag2 -> (tagCompare tag1 tag2 = GT))
    let (>=) = fun tag1 -> (fun tag2 -> Set.member (tagCompare tag1 tag2) {GT; EQ})
end

val unique_tag_matching : range_tag -> annotated_memory_image -> range_tag
let unique_tag_matching tag img = 
    match Multimap.lookupBy tagCompare tag img.by_tag with
        [] -> failwith "no tag match found"
        | [(tag, elRange)] -> tag
        | _ -> failwith "more than one tag match when asserted unique"
    end
    
val tagged_ranges_matching_tag : range_tag -> annotated_memory_image -> list (range_tag * element_range)
let tagged_ranges_matching_tag tag img = 
    Multimap.lookupBy tagCompare tag img.by_tag
    
val unique_tag_matching_at_range_exact : 
    element_range
    -> range_tag 
    -> annotated_memory_image
    -> range_tag
let unique_tag_matching_at_range_exact r tag img = 
    (* 1. find tags a unique range labelled as ELF section header table. *)
    let (allRangeMatches : list range_tag)
     = match Map.lookup r img.by_element_range with
        Just(results) -> results
        | Nothing -> []
    end
    in
    let (tagAlsoMatches : list range_tag)
     = List.filter (fun x -> tagCompare x tag = EQ) allRangeMatches
    in
    match tagAlsoMatches with
        [] -> failwith "no range/tag match when asserted to exist"
        | [x] -> x
        | _ -> failwith "multiple range/tag match when asserted unique"
    end

val range_contains : (natural * natural) -> (natural * natural) -> bool
let range_contains (r1begin, r1len) (r2begin, r2len) = 
    (* r1 is at least as big as r2 *)
    r2begin >= r1begin && (r2begin + r2len) <= (r1begin + r1len)

val range_overlaps : (natural * natural) -> (natural * natural) -> bool
let range_overlaps (r1begin, r1len) (r2begin, r2len) =
    (r1begin < (r2begin + r2len) && (r1begin + r1len) > r2begin)
     || (r2begin < (r1begin + r1len) && (r2begin + r2len) > r1begin)
    
val is_partition : list (natural * natural) -> list (natural * natural) -> bool
let is_partition rs ranges = 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    let r_is_contained_by_some_range
     = fun r -> foldl (||) false (List.map (fun range -> range_contains range r) ranges)
    in
    List.all (fun r -> r_is_contained_by_some_range r) rs
    &&
    (* 2. elements of the first list do not overlap *)
    List.all (fun r -> List.all (fun r2 -> (r = (* should be "=="? *) r2) || (not (range_overlaps r r2))) rs) rs

val     nat_range : natural -> natural -> list natural
let rec nat_range base len =
    match len with 
        0 -> []
    |   _ -> base :: (nat_range (base + 1) (len - 1))
    end

(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
val expand_ranges : list (natural * natural) -> list bool -> list bool
let rec expand_ranges sorted_ranges accum =
    match sorted_ranges with
        [] -> accum
     |  (base, len) :: more -> 
            (* pad the accum so that it reaches up to base *)
            let up_to_base = (Missing_pervasives.replicate (base - (Missing_pervasives.length accum)) true)
            in
            let up_to_end_of_range = up_to_base ++ (Missing_pervasives.replicate len false)
            in
            expand_ranges more (accum ++ up_to_end_of_range)
    end

val make_byte_pattern : list byte -> list bool -> list (maybe byte)
let rec make_byte_pattern bytes dontcares = 
    match bytes with
          [] -> []
        | b :: bs -> match dontcares with 
                er :: more -> (if er then Just b else Nothing) :: (make_byte_pattern bs more)
              | _ -> failwith "make_byte_pattern: unequal length"
              end
    end

val byte_option_matches_byte : maybe byte -> byte -> bool
let byte_option_matches_byte optb b =
    match optb with 
            Nothing -> true 
        |   Just some -> some = b 
    end

val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool
let rec byte_list_matches_pattern pattern bytes = 
    match pattern with 
        [] -> true
        | optbyte :: more -> match bytes with 
                [] -> false
                | abyte :: morebytes -> 
                    byte_option_matches_byte optbyte abyte 
                 && byte_list_matches_pattern more morebytes
            end
    end

val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural
let rec accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum =
    (* let _ = Missing_pervasives.prints ("At offset " ^ (show offset) ^ "... ")
    in *)
    match pattern with
        [] -> (* let _ = Missing_pervasives.prints ("terminating with hit (empty pattern)\n") in *)
            offset :: accum
        | byte_pattern :: more_byte_patterns -> (* nonempty, so check for nonempty seq *)
            match seq with 
                [] -> (*let _ = Missing_pervasives.prints ("terminating with miss (empty pattern)\n") 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte :: more_bytes -> let matched_this_byte = 
                            byte_option_matches_byte byte_pattern byte
                       in
                       (* let _ = Missing_pervasives.prints ("Byte " ^ (show byte) ^ " matched " ^ (show byte_pattern) ^ "? " ^ (show matched_this_byte) ^ "; ") 
                       in *)
                       let sequence_long_enough = (seq_len >= pattern_len) 
                       in
                       (* let _ = Missing_pervasives.prints ("enough bytes remaining (" ^ (show seq_len) ^ ") to match rest of pattern (" ^ (show pattern_len) ^ ")? " ^ (show sequence_long_enough) ^ "; ") 
                       in *)
                       let matched_here = matched_this_byte && sequence_long_enough &&
                        byte_list_matches_pattern more_byte_patterns more_bytes
                       in
                       (* let _ = Missing_pervasives.prints ("matched pattern anchored here? " ^ (show matched_this_byte) ^ "\n") 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len - 1) 
                           (offset + 1) 
                           (if matched_here then offset :: accum else accum)
            end
    end

val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural
let pattern_possible_starts_in_one_byte_sequence pattern seq offset =
    (* let _ = Missing_pervasives.prints ("Looking for matches of " ^
        (show (List.length pattern)) ^ "-byte pattern in " ^ (show (List.length seq)) ^ "-byte region\n")
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset []
