open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
import Map
import Set
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

type byte_pattern = maybe byte

(* An element might have an address, and it has some contents. *)
type memory_image_element = maybe natural * list byte_pattern

(* Memory image elements all have identities. For convenience
 * we make the identities strings. *)
type memory_image = Map.map string memory_image_element

(* We can also annotate arbitrary ranges of bytes within an element
 * with arbitrary metadata. 
 * 
 * Ideally we want to data-abstract this a bit. But it's hard to do
 * so without baking in ELF-specific and/or (moreover) per-ABI concepts, 
 * like PLTs and GOTs. Ideally we would use something like polymorphic
 * variants here. For now, this has to be the union of all the concepts
 * that we find in the various ABIs we care about. To avoid ELFy things
 * creeping in, we parameterise by 'a, and instantiate the 'a with the
 * relevant ELFy thing when we use it. OH, but then 'a is different for
 * every distinct ELF thing, which is no good. Can we define a mapping
 * from an umbrella "ELF" type to the relevant types in each case? *)
type range_tag = SymbolDef
               | RelocationSite
               | GlobalOffsetTable
               | ProcedureLinkageTable
               | ImageBase (* necessary? *)
               | EntryPoint
               | ProcedureDescriptor (* for ppc *) 
               (* |  ... *)

type range = natural * natural (* start, length *)

type annotation = range * range_tag

type annotated_memory_image = memory_image * Map.map (string * range) (list annotation)


val range_contains : (natural * natural) -> (natural * natural) -> bool
let range_contains (r1begin, r1end) (r2begin, r2end) = 
    (* r1 is at least as big as r2 *)
    r2begin >= r1begin && r2end <= r1end

val range_overlaps : (natural * natural) -> (natural * natural) -> bool
let range_overlaps (r1begin, r1end) (r2begin, r2end) =
    (r1begin < r2end && r1end > r2begin) || (r2begin < r1end && r2end > r1begin)
    
val is_partition : list (natural * natural) -> list (natural * natural) -> bool
let is_partition rs ranges = 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    let r_is_contained_by_some_range
     = fun r -> foldl (||) false (List.map (fun range -> range_contains range r) ranges)
    in
    all (fun r -> r_is_contained_by_some_range r) rs
    &&
    (* 2. elements of the first list do not overlap *)
    all (fun r -> all (fun r2 -> (r = (* should be "=="? *) r2) || (not (range_overlaps r r2))) rs) rs

val     nat_range : natural -> natural -> list natural
let rec nat_range base len =
    match len with 
        0 -> []
    |   _ -> base :: (nat_range (base + 1) (len - 1))
    end

(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
val expand_ranges : list (natural * natural) -> list bool -> list bool
let rec expand_ranges sorted_ranges accum =
    match sorted_ranges with
        [] -> accum
     |  (base, len) :: more -> 
            (* pad the accum so that it reaches up to base *)
            let up_to_base = (Missing_pervasives.replicate (base - (Missing_pervasives.length accum)) true)
            in
            let up_to_end_of_range = up_to_base ++ (Missing_pervasives.replicate len false)
            in
            expand_ranges more (accum ++ up_to_end_of_range)
    end

val make_byte_pattern : list byte -> list bool -> list (maybe byte)
let rec make_byte_pattern bytes dontcares = 
    match bytes with
          [] -> []
        | b :: bs -> match dontcares with 
                er :: more -> (if er then Just b else Nothing) :: (make_byte_pattern bs more)
              | _ -> failwith "make_byte_pattern: unequal length"
              end
    end

val byte_option_matches_byte : maybe byte -> byte -> bool
let byte_option_matches_byte optb b =
    match optb with 
            Nothing -> true 
        |   Just some -> some = b 
    end

val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool
let rec byte_list_matches_pattern pattern bytes = 
    match pattern with 
        [] -> true
        | optbyte :: more -> match bytes with 
                [] -> false
                | abyte :: morebytes -> 
                    byte_option_matches_byte optbyte abyte 
                 && byte_list_matches_pattern more morebytes
            end
    end

val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural
let rec accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum =
    (* let _ = Missing_pervasives.prints ("At offset " ^ (show offset) ^ "... ")
    in *)
    match pattern with
        [] -> (* let _ = Missing_pervasives.prints ("terminating with hit (empty pattern)\n") in *)
            offset :: accum
        | byte_pattern :: more_byte_patterns -> (* nonempty, so check for nonempty seq *)
            match seq with 
                [] -> (*let _ = Missing_pervasives.prints ("terminating with miss (empty pattern)\n") 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte :: more_bytes -> let matched_this_byte = 
                            byte_option_matches_byte byte_pattern byte
                       in
                       (* let _ = Missing_pervasives.prints ("Byte " ^ (show byte) ^ " matched " ^ (show byte_pattern) ^ "? " ^ (show matched_this_byte) ^ "; ") 
                       in *)
                       let sequence_long_enough = (seq_len >= pattern_len) 
                       in
                       (* let _ = Missing_pervasives.prints ("enough bytes remaining (" ^ (show seq_len) ^ ") to match rest of pattern (" ^ (show pattern_len) ^ ")? " ^ (show sequence_long_enough) ^ "; ") 
                       in *)
                       let matched_here = matched_this_byte && sequence_long_enough &&
                        byte_list_matches_pattern more_byte_patterns more_bytes
                       in
                       (* let _ = Missing_pervasives.prints ("matched pattern anchored here? " ^ (show matched_this_byte) ^ "\n") 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len - 1) 
                           (offset + 1) 
                           (if matched_here then offset :: accum else accum)
            end
    end

val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural
let pattern_possible_starts_in_one_byte_sequence pattern seq offset =
    (* let _ = Missing_pervasives.prints ("Looking for matches of " ^
        (show (List.length pattern)) ^ "-byte pattern in " ^ (show (List.length seq)) ^ "-byte region\n")
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset []

