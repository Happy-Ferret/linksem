open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
import Map
import Set
import Set_extra
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_symbol_table
open import Elf_types_native_uint

open import Abis

open import Input_list
open import Linkable_list
import Command_line

open import Memory_image
open import Elf_memory_image
open import Elf_memory_image_of_elf64_file
open import Linker_script

let section_name isec img = match name_of_elf_section isec img with
    Just x -> x
    | Nothing -> ""
end

let all_sections_with_indices img = elf_memory_image_sections_with_indices img

let all_common_symbols img = List.filter (fun def -> 
    natural_of_elf64_half def.def_syment.elf64_st_shndx = shn_common
) (elf_memory_image_defined_symbols img)

val expand_sections : abi any_abi_feature -> Linkable_list.linkable_item -> list Linker_script.input_spec
let expand_sections a item = match item with
    (RelocELF(img), (fname, blob, origin), input_opts) -> 
        (* One item per input *user* section, i.e. not including relocs, strtab, etc. *)
        [InputSection(<| 
            fname = short_string_of_linkable_item item
        ;   img   = img
        ;   shndx = shndx
        ;   secname = section_name isec img
        ;   isec = isec
         |>) | forall ((isec, shndx) MEM all_sections_with_indices img) | not (a.section_is_special isec img)]
        ++
        (* One item per common symbol. FIXME: what about common symbols that have the same name? 
         * We need to explicitly instantiate common symbols somewhere, probably here. 
         * This means dropping any that are unreferenced (does it?) and merging any multiply-defined.
         * Actually, we deal with section merging at the same time as section concatenation, so during
         * linker script processing. For discarding unused common symbols, I *think* that this has already
         * been done by discarding unreferenced inputs.  *)
        let common_symbols = all_common_symbols img
        in
        [Common(fname, img, def) | forall (def MEM common_symbols) | 
            let _ = Missing_pervasives.outln ((padded_and_maybe_newline 20 def.def_symname)
                ^ (let hexstr = "0x" ^ (hex_string_of_natural (natural_of_elf64_xword def.def_syment.elf64_st_size))
                  in
                  padded_and_maybe_newline 20 hexstr
                  )
                ^ 
                fname)
            in
            true
        ]
    | _ -> failwith "non-reloc linkable not supported yet"
end

val link : linker_control_script -> abi any_abi_feature -> list Command_line.link_option -> linkable_list -> elf_memory_image
let link script a options linkables = 
    let initial_included_indices = mapMaybei (fun i -> (fun (obj, inp, (opts : input_options)) -> 
        if opts.item_force_output 
        then Just i
        else Nothing
    )) linkables
    in
    let defmap =  all_definitions_by_name linkables
    in
    let (accumulated_bindings : list ((natural * symbol_reference * linkable_item) * maybe (natural * symbol_definition * linkable_item)))
     = accumulate_bindings a linkables defmap {} initial_included_indices [] 
    in
    (* Keep a map whose keys are referenced objects, and whose values are 
     * *some* (diagnostic purposes only) reference to that linkable. *)
    let referenced_object_indices_and_reasons = List.foldl (fun acc_m -> (fun ((ref_idx, ref_sym, ref_linkable), maybe_def_idx_and_sym_and_linkable) -> 
        match maybe_def_idx_and_sym_and_linkable with
            Nothing -> acc_m
            | Just (def_idx, def_sym, def_linkable) -> 
                (* Make sure the map contains this key. *)
                if Map.lookup def_idx acc_m = Nothing 
                    then Map.insert def_idx (ref_sym, ref_linkable) acc_m
                    else acc_m
        end
    )) (Map.empty : Map.map natural (symbol_reference * linkable_item)) accumulated_bindings
    in
    (* Print something similar to GNU ld's linker map output, about include archive members. *)
    let _ = Missing_pervasives.outln "Archive member included to satisfy reference by file (symbol)\n" in
    let linkables_not_discarded = mapMaybei (fun i -> (fun (obj, inp, opts) -> 
        let referenced_object_map_entry = Map.lookup i referenced_object_indices_and_reasons
        in
        let referenced = (referenced_object_map_entry <> Nothing)
        in
        (* Print our link map thing *)
        let _ = (
            if (not referenced) then () else
                (* Did it come from an archive? *)
                let (name, _, (inp_unit, coordlist)) = inp in
                match coordlist with
                    InArchive(aid, aidx, aname) :: _ ->
                        (* yes, from an archive, so print a line *)
                        let (ref_sym, (ref_obj, (ref_name, ref_blob, ref_origin), ref_opts)) = match referenced_object_map_entry with
                            Just(x, y) -> (x, y)
                            | Nothing -> failwith "impossible: referenced item has no definition"
                        end
                        in
                        let lhs_name = aname ^ "(" ^ name ^ ")"
                        in
                        let lhs_name_len = stringLength lhs_name
                        in
                        let spacing = if lhs_name_len >= 29
                            then ("\n" ^ (makeString 30 #' '))
                            else makeString (30 - lhs_name_len) #' '
                        in
                        Missing_pervasives.outln (
                            lhs_name ^ spacing ^ 
                            (match ref_origin with
                                (_, InArchive(bid, bidx, bname) :: _) -> bname ^ "(" ^ ref_name ^ ")"
                                | _ -> ref_name
                            end)
                            ^ " (" ^ ref_sym.ref_symname ^ ")"
                        )
                    | _ (* not from an archive *) -> ()
                end
        )
        in
        if referenced || opts.item_force_output 
        then Just (obj, inp, opts) 
        else Nothing
    )) linkables
    in
    let _ = Missing_pervasives.outln "Allocating common symbols\nCommon symbol       size              file\n"
    in
    let input_sections = Missing_pervasives.list_concat_map (expand_sections a) linkables_not_discarded
    in
    let output_image = interpret_linker_control_script script a input_sections 
    in
    output_image
