open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
import Map
import Set
import Set_extra
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_symbol_table
open import Elf_types_native_uint

open import Abis

open import Input_list
open import Linkable_list
import Command_line

open import Memory_image
open import Elf_memory_image
open import Elf_memory_image_of_elf64_file
open import Linker_script

let section_name isec img = match name_of_elf_section isec img with
    Just x -> x
    | Nothing -> ""
end

let all_sections_with_indices img = elf_memory_image_sections_with_indices img

let all_common_symbols img = List.filter (fun def -> 
    Elf_symbol_table.get_symbol_type def.def_syment.elf64_st_info = stt_common
) (elf_memory_image_defined_symbols img)

val expand_sections : abi any_abi_feature -> Linkable_list.linkable_item -> list Linker_script.input_spec
let expand_sections a item = match item with
    (RelocELF(img), (fname, blob, origin), input_opts) -> 
        (* One item per input *user* section, i.e. not including relocs, strtab, etc. *)
        [InputSection(<| 
            fname = fname 
        ;   img   = img
        ;   shndx = shndx
        ;   secname = section_name isec img
        ;   isec = isec
         |>) | forall ((isec, shndx) MEM all_sections_with_indices img) | not (a.section_is_special isec img)]
        ++
        (* One item per common symbol *)
        [Common(fname, img, syment) | forall (syment MEM all_common_symbols img) | true]
    | _ -> failwith "non-reloc linkable not supported yet"
end

val build_memory_image : output_section_spec -> elf_memory_image
let build_memory_image os = 
    (* <| *)
        empty_elf_memory_image
    (* |> *)

val link : linker_control_script -> abi any_abi_feature -> list Command_line.link_option -> linkable_list -> elf_memory_image
let link script a options linkables = 
    let initial_included_indices = mapMaybei (fun i -> (fun (obj, inp, (opts : input_options)) -> 
        if opts.item_force_output 
        then Just i
        else Nothing
    )) linkables
    in
    let (accumulated_bindings : list ((natural * symbol_reference) * maybe (natural * symbol_definition)))
     = accumulate_bindings linkables (all_definitions_by_name linkables) {} initial_included_indices [] 
    in
    let referenced_object_indices = Set.fromList (mapMaybe (fun ((ref_idx, ref_sym), maybe_def_idx_and_sym) -> 
        match maybe_def_idx_and_sym with
            Nothing -> Nothing
            | Just (def_idx, def_sym) -> Just def_idx
        end
    ) accumulated_bindings)
    in
    let linkables_not_discarded = mapMaybei (fun i -> (fun (obj, inp, opts) -> 
        if Set.member i referenced_object_indices || opts.item_force_output 
        then let _ = Missing_pervasives.println ("Did not discard: " ^ (show inp))
            in Just (obj, inp, opts) 
        else Nothing
    )) linkables
    in
    let input_sections = Missing_pervasives.list_concat_map (expand_sections a) linkables_not_discarded
    in
    let output_image = interpret_linker_control_script script input_sections 
    in
    output_image (*
    build_memory_image output_sections
    *)
