open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Map
import Set
import Set_extra
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Elf_relocation

open import Abis

open import Input_list
open import Linkable_list
import Command_line

open import Memory_image
open import Memory_image_orderings
open import Elf_memory_image
open import Elf_memory_image_of_elf64_file
open import Linker_script

let all_common_symbols img = List.filter (fun def -> 
    natural_of_elf64_half def.def_syment.elf64_st_shndx = shn_common
) (elf_memory_image_defined_symbols img)

(* Q. On what does the decision about a reloc depend? definitely on
 * 
 *      -- command-line options applying to the referenc*ed* object;
 *           (CHECK: I'm inferring that -Bsymbolic, like -Bstatic, applies to the 
 *                   *referenced* object, not the referring -- need experimental conf.)
 *            ACTUALLY, it seems to be global: if a definition goes in the library,
 *                   bind to it; doesn't matter where it comes from. So
 * 
 *      -- command-line options applying to the output object / whole link (-Bsymbolic);
 * 
 *      -- command-line options applying to the referencing object?
 * 
 *      What decision can we make?  
 *      Given a reloc, it might be 
 *      - not bound (weak symbols) -- THIS MEANS it *is* bound but to the value 0!
 *      - bound to a definition
 *
 *      ... perhaps our distinction is between "firm binding or provisional binding"?
 *                                            "final binding or overridable binding"?
 * 
 *      Can we also hit cases where the binding is final but can't be relocated til load time?
 *      YES, e.g. any final R_*_64_64 reference in a shared library's data segment.
 *      WHAT do we do in these cases? Apply what we can and generate a R_*_RELATIVE?
 *      Yes, that's where R_*_RELATIVE come from, since they don't appear in .o inputs.
 *)
type reloc_decision = Leave
                    | Apply
                    | MakePIC

val def_is_in_reloc : linkable_item -> bool
let def_is_in_reloc def_item = match def_item with
    (RelocELF(_), _, _) -> true
    | (ScriptAST(_), _, _) -> true
    | _ -> false
end

val decide_fate_of_relocs : natural -> abi any_abi_feature -> set Command_line.link_option -> 
    binding_map -> linkable_item -> elf_memory_image -> list (reloc_site * binding * reloc_decision)
let decide_fate_of_relocs linkable_idx a options bindings_by_name item img = 
    (* Our image already models relocation sites. For each relocation *record*,
     * we use our bindings to make a decision about whether to apply it or not.
     * 
     * Q1. How do we get the .rela.dyn made? Synthesise a fake reloc section?
     * Or pass them through to the linker script separately?
     * AHA. Note that the script already has an entry for .rela.dyn.
     * And it matches the ordinary rel sections, e.g. .rela.text and so on.
     * So if "-q" is active, the applied relocs need to be injected back in *after* the script
     * has run.
     * So we need both to materialize some relocs into the script *and* save some for later. 
     * 
     * Can we just use memory image metadata as the "saved for later" case? YES, I think so.
     * What do we do with metadata that is now being materialized?
     * I think we should only remove the metadata when we apply the relocation.
     * Q. When do we do that?
     * A. *After* address assignment has happened, i.e. all sections are allocated.
     *)
    let building_executable = Set.member (Command_line.OutputKind(Command_line.Executable)) options in
    let building_shared_library = Set.member (Command_line.OutputKind(Command_line.SharedLibrary)) options in
    let bind_functions_early = Set.member Command_line.BindFunctionsEarly options in
    let bind_non_functions_early = Set.member Command_line.BindNonFunctionsEarly options in
    let all_relocs = List.filter (fun (tag, maybe_range) -> match tag with SymbolRef(r) -> 
        match r.maybe_reloc with 
            Just reloc -> true
            | Nothing -> false
        end
    end) (tagged_ranges_matching_tag (SymbolRef(null_symbol_reference_and_reloc_site)) img)
    in
    List.map (fun (tag, maybe_range) -> 
        (* decision: do we want to
         *  - apply it?   if so, do we need a consequent relocation (e.g. R_*_RELATIVE) in the output?
         *  - PICify it, but leave it interposable?    
         *  - is "PICified, non-interposable" a thing? I don't think so, because non-interposable bindings are 
                     either intra-object *or* necessarily need load-time relocation to account for load addresses.
                     In fact ELF can't express "non-interposable inter-object bindings" because we can't name
                     specific objects when binding symbols.
         *  - leave it alone, i.e. "relocate at load time"?
         * 
         * Some useful questions: is the binding final? 
         * The GNU linker *never* leaves text relocs alone when generating shared libs; it always PICifies them.
         * It can leave them alone when generating executables, though.
         * This is an approximation; load-time text relocation can make sense for shared libs.
         *     (but it's dangerous because PC32 relocs might overflow)
         *)
        let (binding_is_final : set Command_line.link_option -> binding -> bool)
         = fun options -> (fun ((ref_idx, ref, ref_item), maybe_def) -> 
            match maybe_def with 
                (* Weak bindings to 0 are final (though libcrunch wishes they weren't!). *)
                Nothing -> true
                | Just (def_idx, def, def_item) ->
                    (* Bindings to non-global symbols are final. *)
                    get_symbol_binding def.def_syment.elf64_st_info = stb_local
                    ||
                    (* Bindings to hidden- or protected- or internal-visibility globals 
                     *    are final. *)
                    Set.member (get_symbol_visibility def.def_syment.elf64_st_info) { stv_hidden; stv_protected; stv_internal }
                    ||
                    (* Bindings to global symbols are non-final
                     *    *unless* 
                     *      1. the symbol definition is [going to end up] in the executable
                     *      2. we're -Bsymbolic, outputting a shared object,
                     *           and the symbol definition is [going to end up] within the same shared object
                     *      3. we're -Bsymbolic-functions, outputting a shared object,
                     *           and the symbol definition has STT_FUNC and is [going to end up] within the same shared object
                     *
                     * ... where "going to end up in an X" means "we're building an X and def is in a RelocELF rather than a SharedELF".
                     *)
                    (* 1. *)
                    (building_executable && def_is_in_reloc def_item) ||
                    (* 2 and 3. *)
                    (building_shared_library && def_is_in_reloc def_item && 
                        (  ((get_symbol_type def.def_syment.elf64_st_info) = stt_func  && bind_functions_early)
                        || ((get_symbol_type def.def_syment.elf64_st_info) <> stt_func && bind_non_functions_early)
                        )
                    )
                    (* FIXME: does it matter if the binding is intra-object or inter-object?
                     * We don't get inter-object bindings much to non-{default global}s. How much? *)
            end)
        in
        let (reloc_is_absolute : reloc_site -> bool) = fun rs -> 
            let kind = get_elf64_relocation_a_type rs.ref_relent in 
            let (is_abs, _) = a.reloc kind in
            is_abs
        in
        match tag with
            SymbolRef(r) -> 
                match r.maybe_reloc with 
                      Nothing -> failwith "impossible: non-reloc symbol ref should have been filtered out"
                    | Just reloc ->
                        (* What's our decision for this reloc? leave, apply, MakePIC? 
                         * In fact we return both a decision and a maybe-function to create
                         * the consequent reloc. 
                         * In what circumstances do we leave the reloc? If we're making an executable
                               and the definition is not in a relocatable input file or archive or script.
                               Or if we're making a shared library and the reference is "from data".
                               What does "from data" mean? I think it means it's a PC-relative reloc. 
                               If we compile our code to do movabs $addr, even from a *local* address,
                               it's not PIC because that address needs load-time fixup.
                               So actually it's "is absolute address" again.
                         *)
                        let maybe_found_bs = Map.lookup r.ref.ref_symname bindings_by_name
                        in 
                        let b = match maybe_found_bs with
                            Nothing -> failwith "impossible: list of bindings does not include symbol reference (map empty)"
                                (* FIXME: could this actually be an "undefined symbol" link error perhaps? *)
                            | Just bis_and_bs -> match List.filter (fun (b_idx, ((b_ref_idx, b_ref, b_ref_item), b_maybe_def)) -> 
                                if b_ref_idx = linkable_idx && b_ref = r.ref then 
                                let _ = Missing_pervasives.outln ("saw ref from linkable idx " ^ (show linkable_idx) 
                                    ^ ", ref sym scn " ^ (show r.ref.ref_sym_scn) ^ ", ref sym idx "^ (show r.ref.ref_sym_idx) 
                                    ^ ", item " ^ (show item) ^ "; binding to " ^ (
                                        match b_maybe_def with
                                            Just (def_idx, def, def_item) -> "linkable idx " ^ (show def_idx) ^ 
                                                ", def sym scn " ^ (show def.def_sym_scn) ^ ", def sym idx " ^ 
                                                (show def.def_sym_idx)
                                          | Nothing -> "no definition"
                                        end
                                    )
                                )
                                in true
                                else false) bis_and_bs with
                                      [] -> failwith "impossible: list of bindings does not include symbol reference (filtered list empty)"
                                    | [(bi, b)] -> b
                                    | _ ->  failwith ("impossible: list of bindings binds reference to symbol `"
                                        ^ r.ref.ref_symname ^ "' more than one way (filtered list has >1 element)")
                                 end
                        end
                        in
                        let ((ref_idx, _, ref_item), maybe_def) = b
                        in
                        let defined_in_shared_lib = match maybe_def with
                            Just (def_idx, def, def_item) -> not (def_is_in_reloc def_item)
                            | Nothing -> false (* i.e. the "definition", 0, can be "linked in" *)
                        end
                        in
                        if (building_executable && defined_in_shared_lib)
                        || (building_shared_library && (reloc_is_absolute reloc)) then (reloc, b, Leave)
                        else
                        (* In what circumstances do we apply the reloc? If it's a final binding. *)
                        if binding_is_final options b then (reloc, b, Apply)
                        (* In what circumstances do we MakePIC? If it's a non-absolute relocatable field
                         *     and we're building a shared library. 
                         * 
                         * PIC is a kind of "consequent relocation", so let's think through it. 
                         * A call site that calls <printf>      will usually be non-final (overridable).
                         * Output needs to call   <printf@plt>. BUT the trick is as follows:
                         *        the reloc is swizzled so that it binds to the PLT slot <printf@plt>;
                         *        the PLT slot is locally generated, so no reloc is needed.
                         * So the point is that
                         *        a *non*-applied reloc
                         *        might still need "applying" after a fashion (swizzling).
                         * The initial reloc is removed! Since PLT means removing relocs from code
                         * and reproducing their effect using a PLT.
                         * That's why we need this special MakePIC behaviour.
                         * 
                         * What about data?
                         * Suppose I have a shared library containing a read-only pointer to <environ>.
                         * The binding is final because <environ> is defined in the executable, say.
                         * PIC doesn't handle this case -- we still need load-time relocation.
                         * It's PIC, not PID: data can't be made position-independent.
                         *
                         * So, at least for simple cases of PIC, we don't need consequent relocation if
                         * we don't apply the reloc. We'll be removing the reloc. But we *do* need to create 
                         * extra stuff later (PLT, GOT).
                         *)
                        else if building_shared_library then (reloc, b, MakePIC)
                        (* The above are non-exclusive and non-exhaustive. Often, more than one option is available,
                         * ABIs / practice makes an arbitrary choice. For example, final bindings
                         * within a library could be realised the PIC way, but aren't (it'd create a 
                         * pointless indirection). *)
                        else failwith "didn't know what to do with relocation"
                end
        |   _ -> failwith "impossible: got non-SymbolRef tag"
        end
    ) all_relocs

val strip_metadata_sections : list (reloc_site * binding * reloc_decision) -> abi any_abi_feature -> elf_memory_image -> elf_memory_image
let strip_metadata_sections reloc_decisions a img = 
    let (section_tags, section_ranges) = elf_memory_image_section_ranges img
    in
    let rel_sections = mapMaybe (fun (range_tag, (el_name, el_range)) -> 
        match range_tag with
            FileFeature(ElfSection(idx, isec)) -> 
                if Set.member isec.elf64_section_type { sht_rel; sht_rela }
                then Just (idx, isec, el_name)
                else Nothing
            | _ -> Nothing
        end
    ) (zip section_tags section_ranges)
    in
    let discarded_sections_with_element_name = mapMaybe (fun (range_tag, (el_name, el_range)) -> 
        match range_tag with
            FileFeature(ElfSection(idx, isec)) -> 
                if a.section_is_special isec img (* discard reloc sections, and we'll re-add them *)
                then Just (el_name, range_tag) else Nothing
        end
    ) (zip section_tags section_ranges)
    in
    let discarded_elements_map = List.foldl (fun m -> (fun (el_name, range_tag) -> Map.insert el_name range_tag m)) 
        Map.empty discarded_sections_with_element_name
    in
    let filtered_image = Memory_image.filter_elements (fun (el_name, el) -> not (Map.member el_name discarded_elements_map)) img
    in
    let new_reloc_section_length = fun idx -> (fun isec -> 
        let retained_relocs_from_this_section = [(reloc, b, decision) | forall ((reloc, b, decision) MEM reloc_decisions)
            | (* is it from this section? *)
              reloc.ref_rel_scn = idx
              (* are we retaining it? *)
              && decision = Leave]
        in (length retained_relocs_from_this_section) * isec.elf64_section_entsize
    )
    in
    let (new_reloc_elements, new_reloc_tags_and_ranges) = unzip [
        let new_len = new_reloc_section_length idx isec
        in
        let new_el = <| startpos = Nothing ; length = Just new_len; contents = [] |>
        in 
        let new_isec =    <| elf64_section_name    = isec.elf64_section_name
                           ; elf64_section_type    = isec.elf64_section_type
                           ; elf64_section_flags   = isec.elf64_section_flags
                           ; elf64_section_addr    = 0 (* should be 0 anyway *)
                           ; elf64_section_offset  = 0 (* ignored *)
                           ; elf64_section_size    = new_len
                           ; elf64_section_link    = isec.elf64_section_link
                           ; elf64_section_info    = isec.elf64_section_info
                           ; elf64_section_align   = isec.elf64_section_align
                           ; elf64_section_entsize = isec.elf64_section_entsize
                           ; elf64_section_body    = Byte_sequence.empty (* ignored *)
                           ; elf64_section_name_as_string = isec.elf64_section_name_as_string
                           |> 
        in
        let new_meta = FileFeature(ElfSection(idx, new_isec))
        in
        ((el_name, new_el), (new_meta, Just(el_name, (0, new_len)))) | forall ((idx, isec, el_name) MEM rel_sections) | new_reloc_section_length idx isec > 0 
    ]
    in
    let new_by_tag = Set.bigunion { filtered_image.by_tag; Set.fromList new_reloc_tags_and_ranges }
    in
    <|
        elements = Map.unions [filtered_image.elements; Map.fromList new_reloc_elements]
     ;  by_tag   = new_by_tag
     ;  by_range = by_range_from_by_tag new_by_tag
     |>
    

val expand_sections : abi any_abi_feature -> set Command_line.link_option -> binding_map -> natural -> Linkable_list.linkable_item -> list Linker_script.input_spec
let expand_sections a options bindings_by_name linkable_idx item = match item with
    (RelocELF(img), (fname, blob, origin), input_opts) -> 
        let _ = List.foldl (fun _ -> fun (isec, shndx) ->  
            let _ = errln ("For file " ^ fname ^ " before stripping, saw section idx " ^ (show shndx) ^ 
                " with name " ^ isec.elf64_section_name_as_string ^ ", first 20 bytes: " ^ (show (take 20 (
                    (let maybe_elname = elf_memory_image_element_coextensive_with_section shndx img
                     in
                     match maybe_elname with
                        Nothing -> failwith "impossible: no such section"
                        | Just idstr -> 
                            match Map.lookup idstr img.elements with
                                Just el -> el.contents
                                | Nothing -> failwith "no such element"
                            end
                    end
                    )))))
                in
                ()
            ) () (elf_memory_image_sections_with_indices img)
        in
        let reloc_decisions = decide_fate_of_relocs linkable_idx a options bindings_by_name item img
        in 
        (* Now we have a decision for each reloc: Leave, Apply, MakePIC. Which ones
         * do we materialize? Only the Leave ones, for now. For each relocation that
         * we Leave, we figure out its originating section and create a lookalike
         * in the memory image. We'll need to create .plt and .rela.plt later (FIXME).
         *)
        let stripped_img_with_reloc_sections = strip_metadata_sections reloc_decisions a img
        in
        (* Now we have a whole new image! It differs from the old one in that 
         * - non-special sections have been stripped
         * - the relocs we want to participate in linking have been materialized.
         *)
        (* The "-q" option is tricky. It causes all incoming relocs to be retained, but 
         * they *don't* participate in linking -- notice that the default linker script
         * pulls all .rela.* sections into .rela.dyn, whereas these ones *don't* go in there.
         * So FIXME: to support this, we need a way to re-add them, probably when we 
         * generate meta-output like .symtab etc.. *)
        [
            let short_name = short_string_of_linkable_item item
            in
            let _ = errln ("For file " ^ short_name ^ " after stripping, saw section idx " ^ (show shndx) ^ 
                " with name " ^ isec.elf64_section_name_as_string ^ ", first 20 bytes: " ^ (show (take 20 (
                    (let maybe_elname = elf_memory_image_element_coextensive_with_section shndx stripped_img_with_reloc_sections
                     in
                     match maybe_elname with
                        Nothing -> failwith "impossible: no such section"
                        | Just idstr -> 
                            match Map.lookup idstr stripped_img_with_reloc_sections.elements with
                                Just el -> el.contents
                                | Nothing -> failwith "no such element"
                            end
                    end
                    )))))
            in
        InputSection(<| 
            idx   = linkable_idx
        ;   fname = short_name
        ;   img   = stripped_img_with_reloc_sections
        ;   shndx = shndx
        ;   secname = isec.elf64_section_name_as_string
        ;   isec = isec
         |>) | forall ((isec, shndx) MEM elf_memory_image_sections_with_indices stripped_img_with_reloc_sections) | true (* not (a.section_is_special isec img *)
        ]
        ++ (
        (* One item per common symbol. FIXME: what about common symbols that have the same name? 
         * We need to explicitly instantiate common symbols somewhere, probably here. 
         * This means dropping any that are unreferenced (does it?) and merging any multiply-defined.
         * Actually, we deal with section merging at the same time as section concatenation, so during
         * linker script processing. For discarding unused common symbols, I *think* that this has already
         * been done by discarding unreferenced inputs.  *)
        let common_symbols = all_common_symbols stripped_img_with_reloc_sections
        in
        [Common(linkable_idx, fname, stripped_img_with_reloc_sections, def) | forall (def MEM common_symbols) | 
            let _ = Missing_pervasives.outln ((space_padded_and_maybe_newline 20 def.def_symname)
                ^ (let hexstr = "0x" ^ (hex_string_of_natural (natural_of_elf64_xword def.def_syment.elf64_st_size))
                  in
                  space_padded_and_maybe_newline 20 hexstr
                  )
                ^ 
                fname)
            in
            true
        ]
        )
        
    | _ -> failwith "non-reloc linkable not supported yet"
end

val link : linker_control_script -> abi any_abi_feature -> set Command_line.link_option -> linkable_list -> elf_memory_image
let link script a options linkables = 
    let initial_included_indices = mapMaybei (fun i -> (fun (obj, inp, (opts : input_options)) -> 
        if opts.item_force_output 
        then Just i
        else Nothing
    )) linkables
    in
    let defmap =  all_definitions_by_name linkables
    in
    let (accumulated_bindings : list binding)
     = (* accumulate_bindings_bf a linkables defmap {} initial_included_indices []  *)
          accumulate_bindings_objectwise_df a linkables defmap [] {} initial_included_indices
    in
    (* Keep a map whose keys are referenced objects, and whose values are 
     * *some* (diagnostic purposes only) reference to that linkable. *)
    let referenced_object_indices_and_reasons = List.foldl (fun acc_m -> (fun ((ref_idx, ref_sym, ref_linkable), maybe_def_idx_and_sym_and_linkable) -> 
        match maybe_def_idx_and_sym_and_linkable with
            Nothing -> acc_m
            | Just (def_idx, def_sym, def_linkable) -> 
                (* Make sure the map contains this key. *)
                if Map.lookup def_idx acc_m = Nothing 
                    then Map.insert def_idx (ref_sym, ref_linkable) acc_m
                    else acc_m
        end
    )) (Map.empty : Map.map natural (symbol_reference * linkable_item)) accumulated_bindings
    in
    (* Print something similar to GNU ld's linker map output, about included archive members. *)
    let _ = Missing_pervasives.outln "Archive member included to satisfy reference by file (symbol)\n" in
    let linkables_not_discarded = mapMaybei (fun i -> (fun (obj, inp, opts) -> 
        let referenced_object_map_entry = Map.lookup i referenced_object_indices_and_reasons
        in
        let referenced = (referenced_object_map_entry <> Nothing)
        in
        (* Print our link map thing *)
        let _ = (
            if (not referenced) then () else
                (* Did it come from an archive? *)
                let (name, _, (inp_unit, coordlist)) = inp in
                match coordlist with
                    InArchive(aid, aidx, aname, _) :: _ ->
                        (* yes, from an archive, so print a line *)
                        let (ref_sym, (ref_obj, (ref_name, ref_blob, ref_origin), ref_opts)) = match referenced_object_map_entry with
                            Just(x, y) -> (x, y)
                            | Nothing -> failwith "impossible: referenced item has no definition"
                        end
                        in
                        let lhs_name = aname ^ "(" ^ name ^ ")"
                        in
                        let lhs_name_len = stringLength lhs_name
                        in
                        let spacing = if lhs_name_len >= 29
                            then ("\n" ^ (makeString 30 #' '))
                            else makeString (30 - lhs_name_len) #' '
                        in
                        Missing_pervasives.outln (
                            lhs_name ^ spacing ^ 
                            (match ref_origin with
                                (_, InArchive(bid, bidx, bname, _) :: _) -> bname ^ "(" ^ ref_name ^ ")"
                                | _ -> ref_name
                            end)
                            ^ " (" ^ ref_sym.ref_symname ^ ")"
                        )
                    | _ (* not from an archive *) -> ()
                end
        )
        in
        if referenced || opts.item_force_output 
        then Just (i, (obj, inp, opts))
        else Nothing
    )) linkables
    in
    let _ = Missing_pervasives.outln "\nAllocating common symbols\nCommon symbol       size              file\n"
    in
    (* We have to do a pass over relocations quite early. This is because relocs *do* participate 
     * in linking. For each reloc, we need to decide whether to apply it or not. For those not applied,
     * we include it in a synthesised section that participates in linking. An ABI tap here also 
     * synthesises things like (in the GNU case) the .plt section hanging off the first input object. *)
    let (bindings_by_name : Map.map string (list (natural * binding))) = 
        List.foldl (fun m -> fun (b_idx, ((ref_idx, ref, ref_item), maybe_def)) -> match Map.lookup ref.ref_symname m with
            Nothing                  -> Map.insert ref.ref_symname [ (b_idx, ((ref_idx, ref, ref_item), maybe_def)) ] m
            | Just ((bi, b) :: more) -> Map.insert ref.ref_symname  ((b_idx, ((ref_idx, ref, ref_item), maybe_def)) :: (bi, b) :: more) m
            | _ -> failwith "impossible: found empty list in map lacking empties by construction"
        end) Map.empty (List.mapi (fun i -> fun b -> (naturalFromNat i, b)) accumulated_bindings)
    in
    let input_sections = Missing_pervasives.list_concat_map (fun (idx, linkable) -> expand_sections a options bindings_by_name idx linkable) linkables_not_discarded
    in
    let seen_ordering = fun is1 -> (fun is2 -> (
        let toNaturalList = fun is -> (
            (* We're mapping the item to a list of naturals that determine a 
             * lexicographic order. The list has a fixed depth:
             * 
             * [within-commandline, within-group, within-archive, section-or-symbol]
             * 
             * For .o files on the command line, we use the command line order. This
             * is the first level in the hierarchy.
             *  
             * For .a files with --whole-archive, we want to do the same. Do this
             * by using archive position as the second level of the hierarchy, *if*
             * the item is marked as force_output.
             *
             * For other archives, "order seen" means something different: it's
             * the order in which they were "pulled in" during input enumeration. Another
             * way to say this is that they're ordered by the first binding that was
             * made to them. We map these to numbers starting from the size of the archive,
             * i.e. so that "force_output" makes an element appear sooner. In practice
             * we won't get a mixture of force_output and non- in the same archive,
             * so each archive will use only one of the two orderings.
             * 
             * How do sections order relative to common symbols? Again, in practice it
             * doesn't matter because no input query will get a mixture of the two.
             * For symbols, we start the numbering from the number of sections in the file,
             * so symbols always appear later in the sortd order.
             *)
            let (linkable_idx, section_or_symbol_idx) = match is with
                Common(idx, fname, img, def) -> (idx, 
                    (let (_, l) = (elf_memory_image_section_ranges img) in length l) + def.def_sym_idx)
                | InputSection(isrec) -> (isrec.idx, isrec.shndx)
            end
            in
            match List.index linkables (unsafe_nat_of_natural linkable_idx) with
                Nothing -> failwith "impossible: linker input not in linkables list"
                | Just (obj, (fname, blob, (inp_unit, coords)), options) -> 
                    let (our_cid, our_gid, our_aid, maybe_archive_size) = match coords with
                      InArchive(aid, aidx, _, asize) :: InGroup(gid, gidx) :: [InCommandLine(cid)] -> (cid, gid, aid, Just asize)
                    | InArchive(aid, aidx, _, asize) :: [InCommandLine(cid)]                       -> (cid, 0, aid,   Just asize)
                    | InGroup(gid, gidx) :: [InCommandLine(cid)]                                   -> (cid, gid, 0,   Nothing)
                    | [InCommandLine(cid)]                                                         -> (cid, 0, 0,     Nothing)
                    | _ -> failwith "internal error: impossible coordinates"
                    end
                    in
                    let aid_to_use = if options.item_force_output then our_aid
                    else (* how many elements does the archive have? *)
                        let archive_size = match maybe_archive_size with
                            Nothing -> failwith "impossible: archive with no size"
                            | Just a -> a
                        end
                        in archive_size + 
                        (* search the bindings: we want the index of the first binding
                           that refers to this object.
                         *)
                        match List.findIndex (fun ((b_ref_idx, b_ref, b_ref_item), b_maybe_def) -> match b_maybe_def with
                            Just (b_def_idx, b_def, b_def_item) -> b_def_idx = linkable_idx
                            | _ -> false
                        end) accumulated_bindings with
                            Just n -> naturalFromNat n
                            | Nothing -> failwith "impossible: non-force-output object does not contain any bound-to defs"
                        end
                    in
                    (* do we care about group idx? probably not. *)
                    [our_cid; aid_to_use; section_or_symbol_idx]
            end
        )
        in
        compare (toNaturalList is1) (toNaturalList is2)
    ))
    in
    let get_binding_for_ref = (fun symref -> (fun linkable_idx -> (fun fname -> 
        let name_matches = match Map.lookup symref.ref_symname bindings_by_name with Just x -> x | Nothing -> [] end
        in
        match List.filter (fun (bi, ((r_idx, r, r_item), m_d)) -> r_idx = linkable_idx && r = symref) name_matches with
            [(b_idx, b)] -> (b_idx, b)
            | [] -> failwith "no binding found"
            | _  -> failwith ("ambiguous binding found for symbol `" ^ symref.ref_symname ^ "' in file " ^ fname)
        end
    )))
    in
    let output_image = interpret_linker_control_script script a input_sections seen_ordering get_binding_for_ref
    in
    (* This image has 
     * - addresses assigned 
     * - relocations *not* applied
     * - no entry point
     * - some ABI features not generated? HMM.
           -- don't consider output features, like symtabs, yet;
           -- other ABI features have to be generated before the linker script runs (dyn relocs, GOT, PLT?)
           -- ... so we might be okay for now.
     *)
    let (maybe_entry_point_address : maybe natural) = 
        match Command_line.find_option_matching_tag (Command_line.EntryAddress(0)) options with
            Nothing -> a.guess_entry_point output_image
            | Just(Command_line.EntryAddress(x)) -> Just x
        end
    in
    match maybe_entry_point_address with
        Just addr -> 
            match address_to_element_and_offset addr output_image with
                Just (el_name, el_offset) -> 
                    tag_image (EntryPoint) el_name el_offset 0 output_image
                | Nothing -> 
                    (* HMM. entry point symbol has no address at present. *)
                    failwith ("error: entry point address 0x" ^ (hex_string_of_natural addr) ^ " does not correspond to any element position")
            end
        | Nothing -> 
            let _ = errln "Warning: not tagging entry point in output image"
            in 
            output_image
    end
