open import Basic_classes
open import Bool
open import Function
open import Maybe
open import Num
open import String

open import Byte_sequence
open import Error
open import Missing_pervasives
open import Show

open import Default_printing

open import Endianness
open import String_table

open import Elf_dynamic
open import Elf_file
open import Elf_header
open import Elf_program_header_table
open import Elf_relocation
open import Elf_section_header_table
open import Elf_symbol_table
open import Elf_types_native_uint

open import Gnu_ext_section_to_segment_mapping
open import Gnu_ext_symbol_versioning

val hex_string_of_big_int_no_padding : natural -> string
declare ocaml target_rep function hex_string_of_big_int_no_padding = `Ml_bindings.hex_string_of_big_int_no_padding`
val hex_string_of_big_int_no_padding' : integer -> string
declare ocaml target_rep function hex_string_of_big_int_no_padding' = `Ml_bindings.hex_string_of_big_int_no_padding`
val hex_string_of_big_int_pad2 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad2 = `Ml_bindings.hex_string_of_big_int_pad2`
val hex_string_of_big_int_pad4 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad4 = `Ml_bindings.hex_string_of_big_int_pad4`
val hex_string_of_big_int_pad5 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad5 = `Ml_bindings.hex_string_of_big_int_pad5`
val hex_string_of_big_int_pad6 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad6 = `Ml_bindings.hex_string_of_big_int_pad6`
val hex_string_of_big_int_pad7 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad7 = `Ml_bindings.hex_string_of_big_int_pad7`
val hex_string_of_big_int_pad8 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad8 = `Ml_bindings.hex_string_of_big_int_pad8`
val hex_string_of_big_int_pad16 : natural -> string
declare ocaml target_rep function hex_string_of_big_int_pad16 = `Ml_bindings.hex_string_of_big_int_pad16`

val hex_string_of_nat_pad2 : nat -> string
declare ocaml target_rep function hex_string_of_nat_pad2 = `Ml_bindings.hex_string_of_nat_pad2`

val concatS : list string -> string
let concatS = List.foldr (^) ""

val unsafe_hex_string_of_natural : nat -> natural -> string
let unsafe_hex_string_of_natural pad m =
  if pad = 2 then
    hex_string_of_big_int_pad2 m
  else if pad = 5 then
    hex_string_of_big_int_pad5 m
  else if pad = 4 then
    hex_string_of_big_int_pad4 m
  else if pad = 6 then
    hex_string_of_big_int_pad6 m
  else if pad = 7 then
    hex_string_of_big_int_pad7 m
  else if pad = 8 then
    hex_string_of_big_int_pad8 m
  else if pad = 16 then
    hex_string_of_big_int_pad16 m
  else
    hex_string_of_big_int_no_padding m

val unsafe_hex_string_of_uc_list : list unsigned_char -> string
let rec unsafe_hex_string_of_uc_list xs =
  match xs with
    | []       -> ""
    | x::y::xs ->
      let sx = unsafe_hex_string_of_natural 2 (natural_of_unsigned_char x) in
      let sy = unsafe_hex_string_of_natural 2 (natural_of_unsigned_char y) in
      let sx =
        if String.stringLength sx = 2 then
          sx
        else
          "0" ^ sx
      in
      let sy =
        if String.stringLength sy = 2 then
          sy
        else
          "0" ^ sy
      in
        sx ^ " " ^ sy ^ " " ^ unsafe_hex_string_of_uc_list xs
  end

val harness_string_of_elf32_file_header : elf32_header -> string
let harness_string_of_elf32_file_header hdr =
  unlines [
    "ELF Header:"
  ; "  Magic:" ^ "   "                           ^ unsafe_hex_string_of_uc_list (hdr.elf32_ident)
  ; "  Class:" ^ "                             " ^ string_of_elf_file_class (get_elf32_file_class hdr)
  ; "  Data:" ^ "                              " ^ string_of_elf_data_encoding (get_elf32_data_encoding hdr)
  ; "  Version:" ^ "                           " ^ string_of_elf_version_number (get_elf32_version_number hdr)
  ; "  OS/ABI:" ^ "                            " ^ string_of_elf_osabi_version (const "Architecture defined") (get_elf32_osabi hdr)
  ; "  ABI Version:" ^ "                       " ^ show (get_elf32_abi_version hdr)
  ; "  Type:" ^ "                              " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf32_half hdr.elf32_type)
  ; "  Machine:" ^ "                           " ^ string_of_elf_machine_architecture (natural_of_elf32_half hdr.elf32_machine)
  ; "  Version:" ^ "                           " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_word hdr.elf32_version)
  ; "  Entry point address:" ^ "               " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_addr hdr.elf32_entry)
  ; "  Start of program headers:" ^ "          " ^ show hdr.elf32_phoff ^ " (bytes into file)"
  ; "  Start of section headers:" ^ "          " ^ show hdr.elf32_shoff ^ " (bytes into file)"
  ; "  Flags:" ^ "                             " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_word hdr.elf32_flags)
  ; "  Size of this header:" ^ "               " ^ show hdr.elf32_ehsize ^ " (bytes)"
  ; "  Size of program headers:" ^ "           " ^ show hdr.elf32_phentsize ^ " (bytes)"
  ; "  Number of program headers:" ^ "         " ^ show hdr.elf32_phnum
  ; "  Size of section headers:" ^ "           " ^ show hdr.elf32_shentsize ^ " (bytes)"
  ; "  Number of section headers:" ^ "         " ^ show hdr.elf32_shnum
  ; "  Section header string table index:" ^ " " ^ show hdr.elf32_shstrndx
  ]
  
val harness_string_of_elf64_file_header : elf64_header -> string
let harness_string_of_elf64_file_header hdr =
  unlines [
    "ELF Header:"
  ; "  Magic:" ^ "   "                           ^ unsafe_hex_string_of_uc_list (hdr.elf64_ident)
  ; "  Class:" ^ "                             " ^ string_of_elf_file_class (get_elf64_file_class hdr)
  ; "  Data:" ^ "                              " ^ string_of_elf_data_encoding (get_elf64_data_encoding hdr)
  ; "  Version:" ^ "                           " ^ string_of_elf_version_number (get_elf64_version_number hdr)
  ; "  OS/ABI:" ^ "                            " ^ string_of_elf_osabi_version (const "Architecture defined") (get_elf64_osabi hdr)
  ; "  ABI Version:" ^ "                       " ^ show (get_elf64_abi_version hdr)
  ; "  Type:" ^ "                              " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf64_half hdr.elf64_type)
  ; "  Machine:" ^ "                           " ^ string_of_elf_machine_architecture (natural_of_elf64_half hdr.elf64_machine)
  ; "  Version:" ^ "                           " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_word hdr.elf64_version)
  ; "  Entry point address:" ^ "               " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_addr hdr.elf64_entry)
  ; "  Start of program headers:" ^ "          " ^ show hdr.elf64_phoff ^ " (bytes into file)"
  ; "  Start of section headers:" ^ "          " ^ show hdr.elf64_shoff ^ " (bytes into file)"
  ; "  Flags:" ^ "                             " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_word hdr.elf64_flags)
  ; "  Size of this header:" ^ "               " ^ show hdr.elf64_ehsize ^ " (bytes)"
  ; "  Size of program headers:" ^ "           " ^ show hdr.elf64_phentsize ^ " (bytes)"
  ; "  Number of program headers:" ^ "         " ^ show hdr.elf64_phnum
  ; "  Size of section headers:" ^ "           " ^ show hdr.elf64_shentsize ^ " (bytes)"
  ; "  Number of section headers:" ^ "         " ^ show hdr.elf64_shnum
  ; "  Section header string table index:" ^ " " ^ show hdr.elf64_shstrndx
  ]
  
val harness_string_of_elf32_program_header_table_entry : (natural -> string) -> (natural -> string) -> byte_sequence -> elf32_program_header_table_entry -> string
let harness_string_of_elf32_program_header_table_entry os proc bs0 pent =
  let typ = string_of_segment_type os proc (natural_of_elf32_word pent.elf32_p_type) in
  let typ_s =
    let len = 15 - String.stringLength typ in
      if len <= 0 then
        ""
      else
        concatS (replicate (naturalFromNat len) " ")
  in
  concatS [
    "  "
  ; typ ; typ_s
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf32_off pent.elf32_p_offset)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 8 (natural_of_elf32_addr pent.elf32_p_vaddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 8 (natural_of_elf32_addr pent.elf32_p_paddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 5 (natural_of_elf32_word pent.elf32_p_filesz)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 5 (natural_of_elf32_word pent.elf32_p_memsz)
  ; " "
  ; string_of_elf_segment_permissions (natural_of_elf32_word pent.elf32_p_flags)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_word pent.elf32_p_align)
  ] ^
    if natural_of_elf32_word pent.elf32_p_type = elf_pt_interp then
      match Elf_program_header_table.get_elf32_requested_interpreter pent bs0 with
        | Fail f    -> "\n      [Requesting program interpreter: " ^ f ^ "]"
        | Success s -> "\n      [Requesting program interpreter: " ^ s ^ "]"
      end
    else
      ""
      
val harness_string_of_elf64_program_header_table_entry : (natural -> string) -> (natural -> string) -> byte_sequence -> elf64_program_header_table_entry -> string
let harness_string_of_elf64_program_header_table_entry os proc bs0 pent =
  let typ = string_of_segment_type os proc (natural_of_elf64_word pent.elf64_p_type) in
  let typ_s =
    let len = 15 - String.stringLength typ in
      if len <= 0 then
        ""
      else
        concatS (replicate (naturalFromNat len) " ")
  in
  concatS [
    "  "
  ; typ ; typ_s
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_off pent.elf64_p_offset)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 16 (natural_of_elf64_addr pent.elf64_p_vaddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 16 (natural_of_elf64_addr pent.elf64_p_paddr)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_xword pent.elf64_p_filesz)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_xword pent.elf64_p_memsz)
  ; " "
  ; string_of_elf_segment_permissions (natural_of_elf64_word pent.elf64_p_flags)
  ; " "
  ; "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_xword pent.elf64_p_align)
  ] ^
    if natural_of_elf64_word pent.elf64_p_type = elf_pt_interp then
      match Elf_program_header_table.get_elf64_requested_interpreter pent bs0 with
        | Fail f    -> "\n      [Requesting program interpreter: " ^ f ^ "]"
        | Success s -> "\n      [Requesting program interpreter: " ^ s ^ "]"
      end
    else
      ""
  
val harness_string_of_efl32_pht : (natural -> string) -> (natural -> string) -> elf32_program_header_table -> byte_sequence -> string
let harness_string_of_elf32_pht os proc pht bs0 =
    "  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n" ^
      unlines (List.map (harness_string_of_elf32_program_header_table_entry os proc bs0) pht)

val harness_string_of_efl64_pht : (natural -> string) -> (natural -> string) -> elf64_program_header_table -> byte_sequence -> string
let harness_string_of_elf64_pht os proc pht bs0 =
    "  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n" ^
      unlines (List.map (harness_string_of_elf64_program_header_table_entry os proc bs0) pht)

val harness_string_of_elf32_segment_section_mappings : elf32_header -> elf32_program_header_table -> elf32_section_header_table -> string_table -> string
let harness_string_of_elf32_segment_section_mappings hdr pht sht stbl =
  let map =
    List.mapi (fun i -> fun pent ->
      let mapping =
        match get_elf32_section_to_segment_mapping hdr sht pent elf32_section_in_segment stbl with
          | Fail err   -> ["ERR: " ^ err]
          | Success mp -> intercalate " " mp
        end
      in
      let str =
        let temp = concatS mapping in
          if temp = "" then
            temp
          else
            temp ^ " "
      in
        concatS [
          "   " ^ hex_string_of_nat_pad2 i
        ; "     "
        ; str
        ]
    ) pht
  in
    concatS (intercalate "\n" map)
    
val harness_string_of_elf64_segment_section_mappings : elf64_header -> elf64_program_header_table -> elf64_section_header_table -> string_table -> string
let harness_string_of_elf64_segment_section_mappings hdr pht sht stbl =
  let map =
    List.mapi (fun i -> fun pent ->
      let mapping =
        match get_elf64_section_to_segment_mapping hdr sht pent elf64_section_in_segment stbl with
          | Fail err   -> ["ERR: " ^ err]
          | Success mp -> intercalate " " mp
        end
      in
      let str =
        let temp = concatS mapping in
          if temp = "" then
            temp
          else
            temp ^ " "
      in
        concatS [
          "   " ^ hex_string_of_nat_pad2 i
        ; "     "
        ; str
        ]
    ) pht
  in
    concatS (intercalate "\n" map)
  
val harness_string_of_elf32_program_headers : (natural -> string) -> (natural -> string) -> elf32_header -> elf32_program_header_table -> elf32_section_header_table -> string_table -> byte_sequence -> string
let harness_string_of_elf32_program_headers os proc hdr pht sht stbl bs0 =
  unlines [
    ""
  ; "Elf file type is " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf32_half hdr.elf32_type)
  ; "Entry point " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf32_addr hdr.elf32_entry)
  ; "There are " ^ show (List.length pht) ^ " program headers, starting at offset " ^ show hdr.elf32_phoff
  ; ""
  ; "Program Headers:"
  ; harness_string_of_elf32_pht os proc pht bs0
  ; ""
  ; " Section to Segment mapping:"
  ; "  Segment Sections..."
  ; harness_string_of_elf32_segment_section_mappings hdr pht sht stbl
  ]
  
val harness_string_of_elf64_program_headers : (natural -> string) -> (natural -> string) -> elf64_header -> elf64_program_header_table -> elf64_section_header_table -> string_table -> byte_sequence -> string
let harness_string_of_elf64_program_headers os proc hdr pht sht stbl bs0 =
  unlines [
    ""
  ; "Elf file type is " ^ string_of_elf_file_type default_os_specific_print default_proc_specific_print (natural_of_elf64_half hdr.elf64_type)
  ; "Entry point " ^ "0x" ^ unsafe_hex_string_of_natural 1 (natural_of_elf64_addr hdr.elf64_entry)
  ; "There are " ^ show (List.length pht) ^ " program headers, starting at offset " ^ show hdr.elf64_phoff
  ; ""
  ; "Program Headers:"
  ; harness_string_of_elf64_pht os proc pht bs0
  ; ""
  ; " Section to Segment mapping:"
  ; "  Segment Sections..."
  ; harness_string_of_elf64_segment_section_mappings hdr pht sht stbl
  ]
  
val harness_sht32_flag_legend : string
let harness_sht32_flag_legend =
  "\nKey to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)"
  
val harness_sht64_flag_legend : natural -> string
let harness_sht64_flag_legend mach =
  if mach = elf_ma_x86_64 ||
     mach = elf_ma_l10m ||
     mach = elf_ma_k10m then
    "\nKey to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)"
  else
    "\nKey to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)"
  
val harness_string_of_elf32_sht : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_section_header_table -> string_table -> string
let harness_string_of_elf32_sht os proc usr sht stbl =
  "  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n" ^
  unlines (List.mapi (fun i -> fun sec ->
    let is =
      let temp = show i in
        if stringLength temp = 1 then
          " " ^ temp
        else
          temp
    in
    let str = "  [" ^ is ^ "]" in
    let ((gap : string), name) =
      match String_table.get_string_at (natural_of_elf32_word sec.elf32_sh_name) stbl with
        | Fail err   -> ("", "ERR " ^ err)
        | Success nm ->
          if natural_of_elf32_word sec.elf32_sh_type = sht_null then
            let gap = List.foldr (^) " " (Missing_pervasives.replicate 17 " ") in
            (gap, "")
          else
            let glen = naturalFromNat (17 - String.stringLength nm) in
            let gap = List.foldr (^) " " (Missing_pervasives.replicate glen " ") in
              (gap, nm)
      end
    in
    let str = str ^ " " ^ name ^ gap in
    let typ = string_of_section_type os proc usr (natural_of_elf32_word sec.elf32_sh_type) in
    let str = str ^ typ in
    let (gap, addr) =
      let mx  = naturalFromNat (15 - String.stringLength typ) in
      let gap = List.foldr (^) " " (Missing_pervasives.replicate mx " ") in
        (gap, unsafe_hex_string_of_natural 8 (natural_of_elf32_addr sec.elf32_sh_addr))
    in
    let str = str ^ gap ^ addr in
    let off = unsafe_hex_string_of_natural 6 (natural_of_elf32_off sec.elf32_sh_offset) in
    let str = str ^ " " ^ off in
    let size = unsafe_hex_string_of_natural 6 (natural_of_elf32_word sec.elf32_sh_size) in
    let str = str ^ " " ^ size in
    let es  = unsafe_hex_string_of_natural 2 (natural_of_elf32_word sec.elf32_sh_entsize) in
    let str = str ^ " " ^ es in
    let flg = string_of_section_flags os proc (natural_of_elf32_word sec.elf32_sh_flags) in
    let str = str ^ " " ^ flg in
    let (gap, lnk) =
      let l  = show (natural_of_elf32_word sec.elf32_sh_link) in
      let gp = naturalFromNat (2 - String.stringLength l) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, l)
    in
    let str = str ^ gap ^ lnk in
    let (gap, info) =
      let i  = show (natural_of_elf32_word sec.elf32_sh_info) in
      let gp = naturalFromNat (3 - String.stringLength i) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, i)
    in
    let str = str ^ gap ^ info in
    let (gap, align) =
      let a  = show (natural_of_elf32_word sec.elf32_sh_addralign) in
      let gp = naturalFromNat (2 - String.stringLength a) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, a)
    in
    let str = str ^ gap ^ align in
      str) sht)
    
val harness_string_of_elf64_sht : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_section_header_table -> string_table -> string
let harness_string_of_elf64_sht os proc usr sht stbl =
  "  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n" ^
  unlines (List.mapi (fun i -> fun sec ->
    let is =
      let temp = show i in
        if stringLength temp = 1 then
          " " ^ temp
        else
          temp
    in
    let str = "  [" ^ is ^ "]" in
    let ((gap : string), name) =
      match String_table.get_string_at (natural_of_elf64_word sec.elf64_sh_name) stbl with
        | Fail err   -> ("", "ERR " ^ err)
        | Success nm ->
          if natural_of_elf64_word sec.elf64_sh_type = sht_null then
            let gap = List.foldr (^) " " (Missing_pervasives.replicate 17 " ") in
            (gap, "")
          else
            let glen = naturalFromNat (17 - String.stringLength nm) in
            let gap = List.foldr (^) " " (Missing_pervasives.replicate glen " ") in
              (gap, nm)
      end
    in
    let str = str ^ " " ^ name ^ gap in
    let typ = string_of_section_type os proc usr (natural_of_elf64_word sec.elf64_sh_type) in
    let str = str ^ typ in
    let (gap, addr) =
      let mx  = naturalFromNat (15 - String.stringLength typ) in
      let gap = List.foldr (^) " " (Missing_pervasives.replicate mx " ") in
        (gap, unsafe_hex_string_of_natural 16 (natural_of_elf64_addr sec.elf64_sh_addr))
    in
    let str = str ^ gap ^ addr in
    let off = unsafe_hex_string_of_natural 6 (natural_of_elf64_off sec.elf64_sh_offset) in
    let str = str ^ " " ^ off in
    let size = unsafe_hex_string_of_natural 6 (natural_of_elf64_xword sec.elf64_sh_size) in
    let str = str ^ " " ^ size in
    let es  = unsafe_hex_string_of_natural 2 (natural_of_elf64_xword sec.elf64_sh_entsize) in
    let str = str ^ " " ^ es in
    let flg = string_of_section_flags os proc (natural_of_elf64_xword sec.elf64_sh_flags) in
    let str = str ^ " " ^ flg in
    let (gap, lnk) =
      let l  = show (natural_of_elf64_word sec.elf64_sh_link) in
      let gp = naturalFromNat (2 - String.stringLength l) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, l)
    in
    let str = str ^ gap ^ lnk in
    let (gap, info) =
      let i  = show (natural_of_elf64_word sec.elf64_sh_info) in
      let gp = naturalFromNat (3 - String.stringLength i) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, i)
    in
    let str = str ^ gap ^ info in
    let (gap, align) =
      let a  = show (natural_of_elf64_xword sec.elf64_sh_addralign) in
      let gp = naturalFromNat (2 - String.stringLength a) in
      let gp = List.foldr (^) " " (replicate gp " ") in
        (gp, a)
    in
    let str = str ^ gap ^ align in
      str) sht)
    

val harness_string_of_elf32_section_headers : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf32_header -> elf32_section_header_table -> string_table -> string
let harness_string_of_elf32_section_headers os proc usr hdr sht stbl =
  unlines [
    "There are " ^ show (List.length sht) ^ " section headers, starting at offset 0x" ^ unsafe_hex_string_of_natural 0 (natural_of_elf32_off hdr.elf32_shoff) ^ ":"
  ; ""
  ; "Section Headers:"
  ; harness_string_of_elf32_sht os proc usr sht stbl
  ] ^ harness_sht32_flag_legend
  
val harness_string_of_elf64_section_headers : (natural -> string) -> (natural -> string) -> (natural -> string) -> elf64_header -> elf64_section_header_table -> string_table -> string
let harness_string_of_elf64_section_headers os proc usr hdr sht stbl =
  unlines [
    "There are " ^ show (List.length sht) ^ " section headers, starting at offset 0x" ^ unsafe_hex_string_of_natural 0 (natural_of_elf64_off hdr.elf64_shoff) ^ ":"
  ; ""
  ; "Section Headers:"
  ; harness_string_of_elf64_sht os proc usr sht stbl
  ] ^ harness_sht64_flag_legend (natural_of_elf64_half hdr.elf64_machine)
  
val harness_string_of_elf32_reloc_entry : (natural -> string) -> elf32_symbol_table -> string_table -> elf32_relocation -> string
let harness_string_of_elf32_reloc_entry os symtab stbl rel =
  let off  = natural_of_elf32_addr rel.elf32_r_offset in
  let inf  = natural_of_elf32_word rel.elf32_r_info in
  let typ  = os (elf32_relocation_r_type rel.elf32_r_info) in
  let typs =
    let len = naturalFromNat (22 - String.stringLength typ) in
      concatS (replicate len " ")
  in
  let idx  = elf32_relocation_r_sym rel.elf32_r_info in
    match List.index symtab (unsafe_nat_of_natural idx) with
      | Nothing  -> "harness_string_of_elf32_reloc_entry: Nothing returned"
      | Just sym ->
          let nm = natural_of_elf32_word sym.elf32_st_name in
            if nm = stn_undef then
              concatS [
                unsafe_hex_string_of_natural 8 off
              ; "  "
              ; unsafe_hex_string_of_natural 8 inf
              ; " "
              ; typ
              ; typs
              ]
            else
              let vlu = " " ^ unsafe_hex_string_of_natural 8 (natural_of_elf32_addr sym.elf32_st_value) in
              let nm =
                match String_table.get_string_at nm stbl with
                  | Fail    f -> f
                  | Success n -> n
                end
              in
                concatS [
                  unsafe_hex_string_of_natural 8 off
                ; "  "
                ; unsafe_hex_string_of_natural 8 inf
                ; " "
                ; typ
                ; typs
                ; vlu
                ; "   "
                ; nm
                ]
    end
    
val harness_string_of_elf64_reloc_a_entry : (natural -> string) -> elf64_symbol_table -> string_table -> elf64_relocation_a -> string
let harness_string_of_elf64_reloc_a_entry os symtab stbl rel =
  let off  = natural_of_elf64_addr  rel.elf64_ra_offset in
  let inf  = natural_of_elf64_xword rel.elf64_ra_info in
  let add  = integer_of_elf64_sxword rel.elf64_ra_addend in
  let typ  = os (elf64_relocation_r_type rel.elf64_ra_info) in
  let typs =
    let len = naturalFromNat (22 - String.stringLength typ) in
      concatS (replicate len " ")
  in
  let idx  = elf64_relocation_r_sym rel.elf64_ra_info in
    match List.index symtab (unsafe_nat_of_natural idx) with
      | Nothing  -> "harness_string_of_elf64_reloca_entry: Nothing returned"
      | Just sym ->
          let nm = natural_of_elf64_word sym.elf64_st_name in
            if nm = stn_undef then
              concatS [
                unsafe_hex_string_of_natural 16 off
              ; "  "
              ; unsafe_hex_string_of_natural 16 inf
              ; " "
              ; typ
              ; typs
              ; "                    "
              ; hex_string_of_big_int_no_padding' add
              ]
            else
              let vlu = " " ^ unsafe_hex_string_of_natural 16 (natural_of_elf64_addr sym.elf64_st_value) in
              let nm =
                match String_table.get_string_at nm stbl with
                  | Fail    f -> f
                  | Success n -> n
                end
              in
                concatS [
                  unsafe_hex_string_of_natural 16 off
                ; "  "
                ; unsafe_hex_string_of_natural 16 inf
                ; " "
                ; typ
                ; typs
                ; vlu
                ; " "
                ; nm
                ; " + "
                ; hex_string_of_big_int_no_padding' add
                ]
    end
    
val harness_string_of_elf32_relocs' : endianness -> (natural -> string) -> elf32_file -> elf32_section_header_table -> string_table -> string_table -> byte_sequence -> string
let harness_string_of_elf32_relocs' endian os f1 sht shdr stbl bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf32_off  ent.elf32_sh_offset in
      let siz = natural_of_elf32_word ent.elf32_sh_size in
      let lnk = natural_of_elf32_word ent.elf32_sh_link in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun rels ->
        Elf_relocation.read_elf32_relocation_section' endian rels >>= fun sect ->
        Elf_file.get_elf32_symbol_table_by_index f1 lnk >>= fun symtab ->
        return (sect, ent, symtab)
    ) sht
  >>=
    mapM (fun (rels, ent, symtab) ->
      let nm  = natural_of_elf32_word ent.elf32_sh_name in
      let off = unsafe_hex_string_of_natural 0 (natural_of_elf32_off ent.elf32_sh_offset) in
      let len = show (List.length rels) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Relocation section '" ^ nm ^ "' at offset 0x" ^ off ^ " contains " ^ len ^ " entries:\n" in
      let ttl = " Offset     Info    Type                Sym. Value  Symbol's Name\n" in
      let body = concatS (intercalate "\n" (List.map (harness_string_of_elf32_reloc_entry os symtab stbl) rels)) in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end
    
val harness_string_of_elf64_relocs' : endianness -> (natural -> string) -> elf64_file -> elf64_section_header_table -> string_table -> string_table -> byte_sequence -> string
let harness_string_of_elf64_relocs' endian os f1 sht shdr stbl bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf64_off  ent.elf64_sh_offset in
      let siz = natural_of_elf64_xword ent.elf64_sh_size in
      let lnk = natural_of_elf64_word ent.elf64_sh_link in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun rels ->
        Elf_relocation.read_elf64_relocation_a_section' endian rels >>= fun sect ->
        Elf_file.get_elf64_symbol_table_by_index f1 lnk >>= fun symtab ->
        return (sect, ent, symtab)
    ) sht
  >>=
    mapM (fun (rels, ent, symtab) ->
      let nm  = natural_of_elf64_word ent.elf64_sh_name in
      let off = unsafe_hex_string_of_natural 0 (natural_of_elf64_off ent.elf64_sh_offset) in
      let len = show (List.length rels) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Relocation section '" ^ nm ^ "' at offset 0x" ^ off ^ " contains " ^ len ^ " entries:\n" in
      let ttl = "    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n" in
      let body = concatS (intercalate "\n" (List.map (harness_string_of_elf64_reloc_a_entry os symtab stbl) rels)) in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end
  
val harness_string_of_elf32_relocs : elf32_file -> (natural -> string) -> byte_sequence -> string
let harness_string_of_elf32_relocs f1 os bs0 =
  let hdr       = f1.elf32_file_header in
  let sht       = f1.elf32_file_section_header_table in
  let endian    = get_elf32_header_endianness hdr in
  let rel_secs  = List.filter (fun x ->
    x.elf32_sh_type = elf32_word_of_natural sht_rel) sht in
  if List.length rel_secs = 0 then
    "\nThere are no relocations in this file."
  else
    match get_elf32_file_symbol_string_table f1 with
      | Fail err     -> err
      | Success stbl ->
      match get_elf32_file_section_header_string_table f1 with
        | Fail err     -> err
        | Success shdr -> "\n" ^ harness_string_of_elf32_relocs' endian os f1 rel_secs shdr stbl bs0
      end
    end
    
val harness_string_of_elf64_relocs : elf64_file -> (natural -> string) -> byte_sequence -> string
let harness_string_of_elf64_relocs f1 os bs0 =
  let hdr       = f1.elf64_file_header in
  let sht       = f1.elf64_file_section_header_table in
  let endian    = get_elf64_header_endianness hdr in
  let rel_secs  = List.filter (fun x ->
    x.elf64_sh_type = elf64_word_of_natural sht_rela) sht in
  if List.length rel_secs = 0 then
    "\nThere are no relocations in this file."
  else
    match get_elf64_file_symbol_string_table f1 with
      | Fail err     -> err
      | Success stbl ->
      match get_elf64_file_section_header_string_table f1 with
        | Fail err     -> err
        | Success shdr -> "\n" ^ harness_string_of_elf64_relocs' endian os f1 rel_secs shdr stbl bs0
      end
    end
    
val harness_string_of_elf32_symbol_table_entry : nat -> (natural -> string) -> (natural -> string) -> string_table -> elf32_symbol_table_entry -> string
let harness_string_of_elf32_symbol_table_entry num os proc stbl ent =
  let vlu = unsafe_hex_string_of_natural 8 (natural_of_elf32_addr ent.elf32_st_value) in
  let siz = show (natural_of_elf32_word ent.elf32_st_size) in
  let siz_pad = 
    let pad = 5 - stringLength siz in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let typ = string_of_symbol_type (get_symbol_type ent.elf32_st_info) os proc in
  let bnd = string_of_symbol_binding (get_symbol_binding ent.elf32_st_info) os proc in
  let bnd_pad =
    let pad  = 6 - stringLength typ in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let vis = string_of_symbol_visibility (natural_of_unsigned_char ent.elf32_st_other) in
  let vis_pad =
    let pad  = 6 - stringLength bnd in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let ndx =
    let tmp = natural_of_elf32_half ent.elf32_st_shndx in
      if tmp = shn_undef then
        "UND"
      else if tmp = shn_abs then
        "ABS"
      else
        show tmp
  in
  let ndx_pad =
    let pad = 3 - stringLength ndx in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let nm =
    let idx = natural_of_elf32_word ent.elf32_st_name in
      if idx = 0 then
        ""
      else
        match String_table.get_string_at idx stbl with
          | Fail err -> err
          | Success s -> s
        end
  in
  let num =
    let temp = show num in
    let pad  = 3 - stringLength temp in
      if pad = 0 then
        temp
      else
        let spcs = concatS (replicate (naturalFromNat pad) " ") in
          spcs ^ temp
  in
    concatS [
      "   "
    ; num ^ ":"
    ; " "
    ; vlu
    ; " "
    ; siz_pad; siz
    ; " "
    ; typ
    ; "  "
    ; bnd_pad; bnd
    ; " "
    ; vis_pad; vis
    ; "  "
    ; ndx_pad; ndx
    ; " "
    ; nm
    ]
    
val harness_string_of_elf32_syms' : endianness -> (natural -> string) -> (natural -> string) -> elf32_file -> elf32_section_header_table -> elf32_section_header_table -> string_table -> byte_sequence -> string
let harness_string_of_elf32_syms' endian os proc f1 filtered_sht sht shdr bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf32_off  ent.elf32_sh_offset in
      let siz = natural_of_elf32_word ent.elf32_sh_size in
      let lnk = natural_of_elf32_word ent.elf32_sh_link in
      let typ = natural_of_elf32_word ent.elf32_sh_type in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun syms ->
        Elf_symbol_table.read_elf32_symbol_table endian syms >>= fun sect ->
        Elf_file.get_elf32_string_table_by_index f1 lnk >>= fun strtab ->
        return (sect, ent, strtab, typ)
    ) filtered_sht
  >>=
    mapM (fun (syms, ent, strtab, typ) ->
      let nm  = natural_of_elf32_word ent.elf32_sh_name in
      let len = show (List.length syms) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Symbol table '" ^ nm ^ "' contains " ^ len ^ " entries:\n" in
      let ttl = "   Num:    Value  Size Type    Bind   Vis      Ndx Name\n" in
      let body = concatS (intercalate "\n" (List.mapi (fun n ->
        harness_string_of_elf32_symbol_table_entry n os proc strtab) syms))
      in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end
    
val harness_string_of_elf32_syms : elf32_file -> (natural -> string) -> (natural -> string) -> byte_sequence -> string
let harness_string_of_elf32_syms f1 os proc bs0 =
  let hdr = f1.elf32_file_header in
  let sht = f1.elf32_file_section_header_table in
  let endian = get_elf32_header_endianness hdr in
  let sym_secs = List.filter (fun x ->
    x.elf32_sh_type = elf32_word_of_natural sht_dynsym ||
    x.elf32_sh_type = elf32_word_of_natural sht_symtab) sht
  in
  if List.length sym_secs = 0 then
    "\nThere are no symbols in this file."
  else
    match get_elf32_file_section_header_string_table f1 with
      | Fail err     -> err
      | Success shdr ->
        "\n" ^
        harness_string_of_elf32_syms' endian os proc f1 sym_secs sht shdr bs0
    end
    
val harness_string_of_elf64_symbol_table_entry : nat -> (natural -> string) -> (natural -> string) -> string_table -> elf64_symbol_table_entry -> string
let harness_string_of_elf64_symbol_table_entry num os proc stbl ent =
  let vlu = unsafe_hex_string_of_natural 16 (natural_of_elf64_addr ent.elf64_st_value) in
  let siz = show (natural_of_elf64_xword ent.elf64_st_size) in
  let siz_pad = 
    let pad = 5 - stringLength siz in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let typ = string_of_symbol_type (get_symbol_type ent.elf64_st_info) os proc in
  let bnd = string_of_symbol_binding (get_symbol_binding ent.elf64_st_info) os proc in
  let bnd_pad =
    let pad  = 8 - stringLength typ in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let vis = string_of_symbol_visibility (natural_of_unsigned_char ent.elf64_st_other) in
  let vis_pad =
    let pad  = 6 - stringLength bnd in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let ndx =
    let tmp = natural_of_elf64_half ent.elf64_st_shndx in
      if tmp = shn_undef then
        "UND"
      else if tmp = shn_abs then
        "ABS"
      else
        show tmp
  in
  let ndx_pad =
    let pad = 3 - stringLength ndx in
    if pad = 0 then
      ""
    else
      concatS (replicate (naturalFromNat pad) " ")
  in
  let nm =
    let idx = natural_of_elf64_word ent.elf64_st_name in
      if idx = 0 then
        ""
      else
        match String_table.get_string_at idx stbl with
          | Fail err -> err
          | Success s -> s
        end
  in
  let num =
    let temp = show num in
    let pad  = 3 - stringLength temp in
      if pad = 0 then
        temp
      else
        let spcs = concatS (replicate (naturalFromNat pad) " ") in
          spcs ^ temp
  in
    concatS [
      "   "
    ; num ^ ":"
    ; " "
    ; vlu
    ; " "
    ; siz_pad; siz
    ; " "
    ; typ
    ; bnd_pad; bnd
    ; " "
    ; vis_pad; vis
    ; "  "
    ; ndx_pad; ndx
    ; " "
    ; nm
    ]
    
val harness_string_of_elf64_syms' : endianness -> (natural -> string) -> (natural -> string) -> elf64_file -> elf64_section_header_table -> elf64_section_header_table -> string_table -> byte_sequence -> string
let harness_string_of_elf64_syms' endian os proc f1 filtered_sht sht shdr bs0 =
  let rels =
    mapM (fun ent ->
      let off = natural_of_elf64_off  ent.elf64_sh_offset in
      let siz = natural_of_elf64_xword ent.elf64_sh_size in
      let lnk = natural_of_elf64_word ent.elf64_sh_link in
      let typ = natural_of_elf64_word ent.elf64_sh_type in
        Byte_sequence.offset_and_cut off siz bs0 >>= fun syms ->
        Elf_symbol_table.read_elf64_symbol_table endian syms >>= fun sect ->
        Elf_file.get_elf64_string_table_by_index f1 lnk >>= fun strtab ->
        return (sect, ent, strtab, typ)
    ) filtered_sht
  >>=
    mapM (fun (syms, ent, strtab, typ) ->
      let nm  = natural_of_elf64_word ent.elf64_sh_name in
      let len = show (List.length syms) in
      String_table.get_string_at nm shdr >>= fun nm ->
      let hdr = "Symbol table '" ^ nm ^ "' contains " ^ len ^ " entries:\n" in
      let ttl = "   Num:    Value          Size Type    Bind   Vis      Ndx Name\n" in
      let body = concatS (intercalate "\n" (List.mapi (fun n ->
        harness_string_of_elf64_symbol_table_entry n os proc strtab) syms))
      in
      return (hdr ^ ttl ^ body))
  in
    match rels with
      | Fail err -> err
      | Success s -> concatS (intercalate "\n\n" s)
    end
    
val harness_string_of_elf64_syms : elf64_file -> (natural -> string) -> (natural -> string) -> byte_sequence -> string
let harness_string_of_elf64_syms f1 os proc bs0 =
  let hdr = f1.elf64_file_header in
  let sht = f1.elf64_file_section_header_table in
  let endian = get_elf64_header_endianness hdr in
  let sym_secs = List.filter (fun x ->
    x.elf64_sh_type = elf64_word_of_natural sht_dynsym ||
    x.elf64_sh_type = elf64_word_of_natural sht_symtab) sht
  in
  if List.length sym_secs = 0 then
    "\nThere are no symbols in this file."
  else
    match get_elf64_file_section_header_string_table f1 with
      | Fail err     -> err
      | Success shdr ->
        "\n" ^
        harness_string_of_elf64_syms' endian os proc f1 sym_secs sht shdr bs0
    end
    
val string_of_dyn_value : forall 'addr 'size. dyn_value 'addr 'size ->
  ('addr -> string) -> ('size -> string) -> string
let {ocaml} string_of_dyn_value dyn addr size =
  match dyn with
    | Address a -> addr a
    | Size    s -> size s
    | FName   f -> f
    | Path    p -> p
    | Flags   f -> string_of_dt_flag f
    | Ignored   -> ""
    | Library l -> "Shared library: [" ^ l ^ "]"
    | Numeric n -> show n
    | RelType r -> string_of_rel_type r
    | Null      -> "0x0"
  end

val string_of_elf32_dyn_value : elf32_dyn_value -> string  
let string_of_elf32_dyn_value dyn =
  string_of_dyn_value
    dyn
    (fun a -> "0x" ^ unsafe_hex_string_of_natural 7 (natural_of_elf32_addr a))
    (fun s -> show s ^ " (bytes)")
    
val string_of_elf64_dyn_value : elf64_dyn_value -> string  
let string_of_elf64_dyn_value dyn =
  string_of_dyn_value
    dyn
    (fun a -> "0x" ^ unsafe_hex_string_of_natural 6 (natural_of_elf64_addr a))
    (fun s -> show s ^ " (bytes)")
    
val harness_string_of_elf32_dyn_entry : elf32_dyn -> (natural -> bool) -> (natural -> string) -> string_table -> string
let harness_string_of_elf32_dyn_entry dyn os_additional_tags typ stbl =
  let tag = unsafe_hex_string_of_natural 8 (naturalFromInteger (integer_of_elf32_sword dyn.elf32_dyn_tag)) in
  let typ = "(" ^ typ (naturalFromInteger (integer_of_elf32_sword dyn.elf32_dyn_tag)) ^ ")" in
  let vlu =
    match get_value_of_elf32_dyn dyn os_additional_tags stbl with
      | Fail    f -> f
      | Success v -> string_of_elf32_dyn_value v
    end
  in
  let vlu_pad =
    let pad = 29 - stringLength typ in
    if pad = 0 then
      ""
    else
      let reps = replicate (naturalFromNat pad) " " in
      concatS reps
  in
    concatS [
      " "
    ; "0x" ^ tag
    ; " "
    ; typ
    ; vlu_pad; vlu
    ]
    
val harness_string_of_elf32_dynamic_section' : endianness -> elf32_program_header_table_entry
  -> elf32_section_header_table -> byte_sequence -> (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) -> string
let harness_string_of_elf32_dynamic_section' endian dyn sht bs0 os_additional_ranges os proc os_print =
  let off = natural_of_elf32_off dyn.elf32_p_offset in
  let siz = natural_of_elf32_word dyn.elf32_p_filesz in
  let res =
    Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
    obtain_elf32_dynamic_section_contents endian rel os_additional_ranges os proc >>= fun dyns ->
    get_string_table_of_elf32_dyn_section endian dyns sht bs0 >>= fun stbl ->
    return (List.map (fun x -> harness_string_of_elf32_dyn_entry x os_additional_ranges os_print stbl) dyns)
  in
    match res with
      | Fail    f -> f
      | Success s ->
        let off = unsafe_hex_string_of_natural 6 off in
        let entries = show (List.length s) in
        concatS [
          "\n"
        ; "Dynamic section at offset 0x" ^ off ^ " contains " ^ entries ^ " entries:\n"
        ; "  Tag        Type                         Name/Value\n"
        ; concatS (intercalate "\n" s)
        ]
    end
    
val harness_string_of_elf32_dynamic_section : elf32_file -> byte_sequence ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) -> string
let harness_string_of_elf32_dynamic_section f1 bs0 os_additional_ranges os proc os_print =
  let endian = get_elf32_header_endianness f1.elf32_file_header in
  let pht = f1.elf32_file_program_header_table in
  let sht = f1.elf32_file_section_header_table in
  let dyn =
    List.filter (fun x ->
      x.elf32_p_type = elf32_word_of_natural elf_pt_dynamic
    ) pht
  in
    match dyn with
      | []  -> "\nThere is no dynamic section in this file."
      | [x] -> harness_string_of_elf32_dynamic_section' endian x sht bs0 os_additional_ranges os proc os_print
      | _   -> "Multiple dynamic sections detected."
    end
    
val harness_string_of_elf64_dyn_entry : elf64_dyn -> (natural -> bool) -> (natural -> string) -> string_table -> string
let harness_string_of_elf64_dyn_entry dyn os_additional_ranges typ stbl =
  let tag = unsafe_hex_string_of_natural 16 (naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag)) in
  let typ = "(" ^ typ (naturalFromInteger (integer_of_elf64_sxword dyn.elf64_dyn_tag)) ^ ")" in
  let vlu =
    match get_value_of_elf64_dyn dyn os_additional_ranges stbl with
      | Fail    f -> f
      | Success v -> string_of_elf64_dyn_value v
    end
  in
  let vlu_pad =
    let pad = 21 - stringLength typ in
    if pad = 0 then
      ""
    else
      let reps = replicate (naturalFromNat pad) " " in
      concatS reps
  in
    concatS [
      " "
    ; "0x" ^ tag
    ; " "
    ; typ
    ; vlu_pad; vlu
    ]
    
val harness_string_of_elf64_dynamic_section' : endianness -> elf64_program_header_table_entry
  -> elf64_section_header_table -> byte_sequence -> (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) -> string
let harness_string_of_elf64_dynamic_section' endian dyn sht bs0 os_additional_ranges os proc os_print =
  let off = natural_of_elf64_off dyn.elf64_p_offset in
  let siz = natural_of_elf64_xword dyn.elf64_p_filesz in
  let res =
    Byte_sequence.offset_and_cut off siz bs0 >>= fun rel ->
    obtain_elf64_dynamic_section_contents endian rel os_additional_ranges os proc >>= fun dyns ->
    get_string_table_of_elf64_dyn_section endian dyns sht bs0 >>= fun stbl ->
    return (List.map (fun x -> harness_string_of_elf64_dyn_entry x os_additional_ranges os_print stbl) dyns)
  in
    match res with
      | Fail    f -> f
      | Success s ->
        let off = unsafe_hex_string_of_natural 6 off in
        let entries = show (List.length s) in
        concatS [
          "\n"
        ; "Dynamic section at offset 0x" ^ off ^ " contains " ^ entries ^ " entries:\n"
        ; "  Tag        Type                         Name/Value\n"
        ; concatS (intercalate "\n" s)
        ]
    end
    
val harness_string_of_elf64_dynamic_section : elf64_file -> byte_sequence ->
  (natural -> bool) -> (natural -> error tag_correspondence) ->
    (natural -> error tag_correspondence) -> (natural -> string) -> string
let harness_string_of_elf64_dynamic_section f1 bs0 os_additional_ranges os proc os_print =
  let endian = get_elf64_header_endianness f1.elf64_file_header in
  let pht = f1.elf64_file_program_header_table in
  let sht = f1.elf64_file_section_header_table in
  let dyn =
    List.filter (fun x ->
      x.elf64_p_type = elf64_word_of_natural elf_pt_dynamic
    ) pht
  in
    match dyn with
      | []  -> "\nThere is no dynamic section in this file."
      | [x] -> harness_string_of_elf64_dynamic_section' endian x sht bs0 os_additional_ranges os proc os_print
      | _   -> "Multiple dynamic sections detected."
    end
