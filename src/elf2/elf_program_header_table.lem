open import Basic_classes
open import Bool
open import Function
open import List
open import Maybe
open import Num
open import String

open import Elf_types

open import Bitstring
open import Error
open import Missing_pervasives
open import Show

(** Segment types *)

(** Unused array element.  All other members of the structure are undefined. *)
let elf_pt_null : nat = 0
(** A loadable segment. *)
let elf_pt_load : nat = 1
(** Dynamic linking information. *)
let elf_pt_dynamic : nat = 2
(** Specifies the location and size of a null-terminated path name to be used to
  * invoke an interpreter.
  *)
let elf_pt_interp : nat = 3
(** Specifies location and size of auxiliary information. *)
let elf_pt_note : nat = 4
(** Reserved but with unspecified semantics.  If the file contains a segment of
  * this type then it is to be regarded as non-conformant with the ABI.
  *)
let elf_pt_shlib : nat = 5
(** Specifies the location and size of the program header table. *)
let elf_pt_phdr : nat = 6
(** Specifies the thread local storage (TLS) template.  Need not be supported. *)
let elf_pt_tls : nat = 7
(** Start of reserved indices for operating system specific semantics. *)
let elf_pt_loos : nat = 0 (* XXX: too big for Lem? 1610612736 (* 0x60000000 *) *)
(** End of reserved indices for operating system specific semantics. *)
let elf_pt_hios : nat = 0 (* XXX: too big for Lem? 1879048191 (* 0x6fffffff *) *)
(** Start of reserved indices for processor specific semantics. *)
let elf_pt_loproc : nat = 0 (* XXX: too big for Lem? 1879048192 (* 0x70000000 *) *)
(** End of reserved indices for processor specific semantics. *)
let elf_pt_hiproc : nat = 0 (* XXX: too big for Lem? 2147483647 (* 0x7fffffff *) *)

(** [string_of_elf_segment_type os proc st] produces a string representation of
  * the coding of an ELF segment type [st] using [os] and [proc] to render OS-
  * and processor-specific codings.
  *)
val string_of_elf_segment_type : (nat -> string) -> (nat -> string) -> nat -> string
let string_of_elf_segment_type os proc pt =
	if pt = elf_pt_null then
		"PT_NULL"
	else if pt = elf_pt_load then
		"PT_LOAD"
	else if pt = elf_pt_dynamic then
		"PT_DYNAMIC"
	else if pt = elf_pt_interp then
		"PT_INTERP"
	else if pt = elf_pt_note then
		"PT_NOTE"
	else if pt = elf_pt_shlib then
		"PT_SHLIB"
	else if pt = elf_pt_phdr then
		"PT_PHDR"
	else if pt = elf_pt_tls then
		"PT_TLS"
	else if pt >= elf_pt_loos && pt <= elf_pt_hios then
		os pt
	else if pt >= elf_pt_loproc && pt <= elf_pt_hiproc then
		proc pt
	else
		"Undefined or invalid segment type"

(** Program header table entry type *)

(** Type [elf32_program_header_table_entry] encodes a program header table entry
  * for 32-bit platforms.  Each entry describes a segment in an executable or
  * shared object file.
  *)
type elf32_program_header_table_entry =
  <| p_type  : elf32_word  (** Type of the segment *)
   ; p_offset : elf32_off  (** Offset from beginning of file for segment *)
   ; p_vaddr  : elf32_addr (** Virtual address for segment in memory *)
   ; p_paddr  : elf32_addr (** Physical address for segment *)
   ; p_filesz : elf32_word (** Size of segment in file, in bytes *)
   ; p_memsz  : elf32_word (** Size of segment in memory image, in bytes *)
   ; p_flags  : elf32_word (** Segment flags *)
   ; p_align  : elf32_word (** Segment alignment memory for memory and file *)
   |>
  
(** [string_of_elf32_program_header_table_entry os proc et] produces a string
  * representation of a 32-bit program header table entry using [os] and [proc]
  * to render OS- and processor-specific entries.
  *)
val string_of_elf32_program_header_table_entry : (nat -> string) -> (nat -> string) -> elf32_program_header_table_entry -> string
let string_of_elf32_program_header_table_entry os proc entry =
	unlines [
		"\t" ^ "Segment type: " ^ string_of_elf_segment_type os proc (nat_of_elf32_word entry.p_type)
	; "\t" ^ "Offset: " ^ show entry.p_offset
	; "\t" ^ "Virtual address: " ^ show entry.p_vaddr
	; "\t" ^ "Physical address: " ^ show entry.p_paddr
	; "\t" ^ "Segment size (bytes): " ^ show entry.p_filesz
	; "\t" ^ "Segment size in memory image (bytes): " ^ show entry.p_memsz
	; "\t" ^ "Flags: " ^ show entry.p_flags
  ; "\t" ^ "Alignment: " ^ show entry.p_align
	]

(** [string_of_elf32_program_header_table_entry_default et] produces a string representation
  * of table entry [et] where OS- and processor-specific entries are replaced with
  * default strings.
  *)
val string_of_elf32_program_header_table_entry_default : elf32_program_header_table_entry -> string
let string_of_elf32_program_header_table_entry_default =
	string_of_elf32_program_header_table_entry
    (const "*Default OS specific print*")
      (const "*Default processor specific print*")
	
instance (Show elf32_program_header_table_entry)
	let show = string_of_elf32_program_header_table_entry_default
end

(** [read_elf32_program_header_table_entry bs0] reads an ELF32 program header table
  * entry from bitstring [bs0].  If [bs0] is larger than necessary, the excess
  * is returned from the function, too.
  *)
val read_elf32_program_header_table_entry : bitstring -> error (elf32_program_header_table_entry * bitstring)
let read_elf32_program_header_table_entry bs =
	read_elf32_word bs >>= fun (typ, bs) ->
	read_elf32_off  bs >>= fun (offset, bs) ->
	read_elf32_addr bs >>= fun (vaddr, bs) ->
	read_elf32_addr bs >>= fun (paddr, bs) ->
	read_elf32_word bs >>= fun (filesz, bs) ->
	read_elf32_word bs >>= fun (memsz, bs) ->
	read_elf32_word bs >>= fun (flags, bs) ->
	read_elf32_word bs >>= fun (align, bs) ->
		Success (<| p_type = typ; p_offset = offset;
                p_vaddr = vaddr; p_paddr = paddr;
                p_filesz = filesz; p_memsz = memsz;
                p_flags = flags; p_align = align |>, bs)

(** Program header table type *)

(** Type [elf32_program_header_table] represents a program header table for 32-bit
  * ELF files.  A program header table is an array (implemented as a list, here)
  * of program header table entries.
  *)
type elf32_program_header_table =
  list elf32_program_header_table_entry

class (HasElf32ProgramHeaderTable 'a)
  val get_elf32_program_header_table : 'a -> maybe elf32_program_header_table
end

(** [read_elf32_program_header_table' bs0] reads an ELF32 program header table from
  * bitstring [bs0].  The bitstring [bs0] is assumed to have exactly the correct
  * size for the table.  For internal use, only.  Use [read_elf32_program_header_table]
  * below instead.
  *)
let rec read_elf32_program_header_table' bs0 =
	if length bs0 = 0 then
  	return []
  else
  	read_elf32_program_header_table_entry bs0 >>= fun (entry, bs1) ->
    read_elf32_program_header_table' bs1 >>= fun tail ->
    return (entry::tail)

(** [read_elf32_program_header_table table_size bs0] reads an ELF32 program header
  * table from bitstring [bs0] based on the size (in bytes) passed in via [table_size].
  * This [table_size] argument should be equal to the number of entries in the
  * table multiplied by the fixed entry size.  Bitstring [bs0] may be larger than
  * necessary, in which case the excess is returned.
  *)
val read_elf32_program_header_table : nat -> bitstring -> error (elf32_program_header_table * bitstring)
let read_elf32_program_header_table table_size bs0 =
	let (eat, rest) = partition table_size bs0 in
		read_elf32_program_header_table' eat >>= fun table ->
		return (table, rest)

(** [string_of_elf32_program_header_table os proc tbl] produces a string representation
  * of program header table [tbl] using [os] and [proc] to render OS- and processor-
  * specific entries.
  *)
val string_of_elf32_program_header_table : (nat -> string) -> (nat -> string) -> elf32_program_header_table -> string
let string_of_elf32_program_header_table os proc tbl =
    unlines [
      "Program header table contents:"
    ; unlines (List.map (string_of_elf32_program_header_table_entry os proc) tbl)
    ]
