open import Basic_classes
open import Bool
open import Maybe
open import Num
open import String

open import Elf_file1
open import Elf_header
open import Elf_program_header_table
open import Elf_types

open import Bitstring
open import Error
open import Missing_pervasives
open import Show

(** Type [elf32_executable_file2] represents the lazy unfolding of a 32-bit ELF
  * file where the structure of the header, program header table (mandatory).
  *)
type elf32_executable_file2 =
  <| elf32_executable_file2_header               : elf32_header               (** The ELF header (mandatory) *)
   ; elf32_executable_file2_program_header_table : elf32_program_header_table (** The program header table (mandatory) *)
   ; elf32_executable_file2_body                 : bitstring                  (** Uninterpreted data *)
   |>

val get_elf32_header' : elf32_executable_file2 -> elf32_header
let get_elf32_header' f2 = f2.elf32_executable_file2_header

instance (HasElf32Header elf32_executable_file2)
  let get_elf32_header = get_elf32_header'
end

(* Because of Lem's braindead type classes... *)
val get_elf32_program_header_table' : elf32_executable_file2 -> maybe elf32_program_header_table
let get_elf32_program_header_table' f2 = Just (f2.elf32_executable_file2_program_header_table)

instance (HasElf32ProgramHeaderTable elf32_executable_file2)
  let get_elf32_program_header_table = get_elf32_program_header_table'
end

(** [refine_elf32_file1 f1] refines the [elf31_file1] [f1] adding the
  * mandatory program header table to [f1]'s header.  Fails if [f1]'s header
  * states that no program header table is present, or if there is some other
  * transcription error when reading from [f1]'s body.
  *)
val refine_elf32_file1 : elf32_file1 -> error elf32_executable_file2
let refine_elf32_file1 f1 =
  if not (is_executable_elf32_file1 f1) then
    Fail "refine_elf32_file1: not an executable file type"
  else
    let hdr         = f1.elf32_file1_header in
    let endian      = get_elf32_header_endian hdr in
    let bs1         = f1.elf32_file1_body   in
    let pentries    = nat_of_elf32_half hdr.elf32_phnum     in
    let pentry_size = nat_of_elf32_half hdr.elf32_phentsize * 8 in
    let psize       = pentries * pentry_size in
      if psize = 0 then
        Fail "refine_elf32_file1: program header table not present"
      else
        let poffset     = nat_of_elf32_off hdr.elf32_phoff * 8 in
        let (_, pcut)   = partition poffset bs1 in
        let (pexact, _) = partition psize pcut in
          (* Bitstring irrelevant below as exact size used... *)
          read_elf32_program_header_table psize endian pexact >>= fun (pht, _) ->
            return <| elf32_executable_file2_header = hdr;
              elf32_executable_file2_program_header_table = pht;
              elf32_executable_file2_body = bs1 |>

(** [read_elf32_executable_file2 bs0] creates an [elf32_executable_file2] record
  * directly from the bitstring [bs0].
  *)
val read_elf32_executable_file2 : bitstring -> error elf32_executable_file2
let read_elf32_executable_file2 bs0 =
  read_elf32_file1 bs0 >>= refine_elf32_file1

(** [string_of_elf32_executable_file2 os proc f2] creates a string representation of [f2].
  *)
val string_of_elf32_executable_file2 :
  (nat -> string) -> (nat -> string) ->
    (nat -> string) -> (nat -> string) ->
      elf32_executable_file2 -> string
let string_of_elf32_executable_file2 hdr_os hdr_proc pht_os pht_proc f2 =
  unlines [
    "Type elf32_executable_file2:"
  ; string_of_elf32_header hdr_os hdr_proc f2.elf32_executable_file2_header
  ; string_of_elf32_program_header_table pht_os pht_proc f2.elf32_executable_file2_program_header_table
  ; "Body:"
  ; "\tUninterpreted data of length " ^ show (Bitstring.length f2.elf32_executable_file2_body)
  ]