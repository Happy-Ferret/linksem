open import Basic_classes
open import Bool
open import Num
open import String

open import Elf_types_native_uint

open import Byte_sequence
open import Missing_pervasives
open import Show

type elf32_interpreted_segment =
  <| elf32_segment_body  : byte_sequence        (** Body of the segment *)
   ; elf32_segment_type  : natural              (** Type of the segment *)
   ; elf32_segment_size  : natural              (** Size of the segment in bytes *)
   ; elf32_segment_memsz : natural              (** Size of the segment in memory in bytes *)
   ; elf32_segment_base  : natural              (** Base address of the segment *)
   ; elf32_segment_paddr : natural              (** Physical address of segment *)
   ; elf32_segment_align : natural              (** Alignment of the segment *)
   ; elf32_segment_offset : natural             (** Offset of the segment *)
   ; elf32_segment_flags : (bool * bool * bool) (** READ, WRITE, EXECUTE flags. *)
   |>

type elf64_interpreted_segment =
  <| elf64_segment_body  : byte_sequence        (** Body of the segment *)
   ; elf64_segment_type  : natural              (** Type of the segment *)
   ; elf64_segment_size  : natural              (** Size of the segment in bytes *)
   ; elf64_segment_memsz : natural              (** Size of the segment in memory in bytes *)
   ; elf64_segment_base  : natural              (** Base address of the segment *)
   ; elf64_segment_paddr : natural              (** Physical address of segment *)
   ; elf64_segment_align : natural              (** Alignment of the segment *)
   ; elf64_segment_offset : natural             (** Offset of the segment *)
   ; elf64_segment_flags : (bool * bool * bool) (** READ, WRITE, EXECUTE flags. *)
   |>
   
let compare_elf64_interpreted_segment s1 s2 = 
    compare 
    (s1.elf64_segment_body, [s1.elf64_segment_type  ;
s1.elf64_segment_size  ;
s1.elf64_segment_memsz ;
s1.elf64_segment_base  ;
s1.elf64_segment_paddr ;
s1.elf64_segment_align ;
s1.elf64_segment_offset],  let (f1, f2, f3) = s1.elf64_segment_flags in List.map natural_of_bool [f1; f2; f3])
(s2.elf64_segment_body, [s2.elf64_segment_type  ;
s2.elf64_segment_size  ;
s2.elf64_segment_memsz ;
s2.elf64_segment_base  ;
s2.elf64_segment_paddr ;
s2.elf64_segment_align ;
s2.elf64_segment_offset], let (f1, f2, f3) = s2.elf64_segment_flags in List.map natural_of_bool [f1; f2; f3])

instance (Ord elf64_interpreted_segment)
    let compare = compare_elf64_interpreted_segment
    let (<) = fun f1 -> (fun f2 -> (compare_elf64_interpreted_segment f1 f2 = LT))
    let (<=) = fun f1 -> (fun f2 -> let result = compare_elf64_interpreted_segment f1 f2 in result = LT || result = EQ)
    let (>) = fun f1 -> (fun f2 -> (compare_elf64_interpreted_segment f1 f2 = GT))
    let (>=) = fun f1 -> (fun f2 -> let result = compare_elf64_interpreted_segment f1 f2 in result = GT || result = EQ)
end

type elf32_interpreted_segments = list elf32_interpreted_segment
type elf64_interpreted_segments = list elf64_interpreted_segment

val elf32_interpret_program_header_flags : elf32_word -> (bool * bool * bool)
let elf32_interpret_program_header_flags flags =
  let zero = elf32_word_of_natural 0 in
  let one  = elf32_word_of_natural 1 in
  let two  = elf32_word_of_natural 2 in
  let four = elf32_word_of_natural 4 in
    (not (elf32_word_land flags one = zero),
      not (elf32_word_land flags two = zero),
      not (elf32_word_land flags four = zero))

val elf64_interpret_program_header_flags : elf64_word -> (bool * bool * bool)
let elf64_interpret_program_header_flags flags =
  let zero = elf64_word_of_natural 0 in
  let one  = elf64_word_of_natural 1 in
  let two  = elf64_word_of_natural 2 in
  let four = elf64_word_of_natural 4 in
    (not (elf64_word_land flags one = zero),
      not (elf64_word_land flags two = zero),
      not (elf64_word_land flags four = zero))

val string_of_flags : (bool * bool * bool) -> string
let {ocaml} string_of_flags flags =
  match flags with
    | (read, write, execute) ->
        bracket [show read; show write; show execute]
  end

val string_of_elf32_interpreted_segment : elf32_interpreted_segment -> string
let {ocaml} string_of_elf32_interpreted_segment seg =
  unlines [
    "Body of length: " ^ show (Byte_sequence.length seg.elf32_segment_body)
  ; "Segment type: " ^ show seg.elf32_segment_type
  ; "Segment size: " ^ show seg.elf32_segment_size
  ; "Segment memory size: " ^ show seg.elf32_segment_memsz
  ; "Segment base address: " ^ show seg.elf32_segment_base
  ; "Segment physical address: " ^ show seg.elf32_segment_paddr
  ; "Segment flags: " ^ string_of_flags seg.elf32_segment_flags
  ]

val string_of_elf64_interpreted_segment : elf64_interpreted_segment -> string
let {ocaml} string_of_elf64_interpreted_segment seg =
  unlines [
    "Body of length: " ^ show (Byte_sequence.length seg.elf64_segment_body)
  ; "Segment type: " ^ show seg.elf64_segment_type
  ; "Segment size: " ^ show seg.elf64_segment_size
  ; "Segment memory size: " ^ show seg.elf64_segment_memsz
  ; "Segment base address: " ^ show seg.elf64_segment_base
  ; "Segment physical address: " ^ show seg.elf64_segment_paddr
  ; "Segment flags: " ^ string_of_flags seg.elf64_segment_flags
  ]
