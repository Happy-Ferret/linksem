open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Map
import Set
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_file
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Elf_relocation
open import String_table

open import Memory_image

(* Now that we've got rid of the polymorphism, these things are identical *)
type elf_memory_image = annotated_memory_image

val elfFeatureCompare : elf_file_feature -> elf_file_feature -> Basic_classes.ordering
let elfFeatureCompare k1 k2 = 
    match (k1, k2) with
        (ElfHeader _ , ElfHeader _) -> EQ
        | (ElfSectionHeaderTable(_), ElfSectionHeaderTable(_)) -> EQ
        | (ElfProgramHeaderTable(_), ElfProgramHeaderTable(_)) -> EQ
        | (ElfSection(_, _), ElfSection(_, _)) -> EQ
        | (ElfSegment(_, _), ElfSegment(_, _)) -> EQ
        (* what compares LT? *)
        | (ElfHeader(_), _) -> LT
        | (ElfSectionHeaderTable, ElfProgramHeaderTable(_)) -> LT
        | (ElfSectionHeaderTable, ElfSection(_, _)) -> LT
        | (ElfSectionHeaderTable, ElfSegment(_, _)) -> LT
        | (ElfProgramHeaderTable, ElfSection(_, _)) -> LT
        | (ElfProgramHeaderTable(_), ElfSegment(_, _)) -> LT
        | (ElfSection(_, _), ElfSegment(_, _)) -> LT
        (* else it's GT *)
        | (_, _) -> GT
    end
(*
instance (SetType elf_file_feature)
    let setElemCompare = elfFeatureCompare
end
*)
(* This record collects things that ABIs may or must define. 
 * 
 * Since we want to put all ABIs in a list and select one at run time, 
 * we can't maintain a type-level distinction between ABIs; we have to
 * use elf_memory_image any_abi_feature. In fact I think the whole
 * memory_image polymorphism stuff should just be erased (TODO, FIXME, etc.).
 *)
type abi = (* forall 'abifeature. *)
   <| is_valid_elf_header : elf64_header -> bool
                        (* doesn't this generalise outrageously? is_valid_elf_file? *)
    ; reloc              : natural -> ((maybe elf64_symbol_table_entry -> natural) * (memory_image -> maybe natural))
                        (* number  ->  width   * (symaddr -> addend  -> existing-> relocated) *)
    ; section_is_special : elf64_interpreted_section -> elf_memory_image -> bool
    ; section_is_large   : elf64_interpreted_section -> elf_memory_image -> bool
    ; maxpagesize        : natural
    ; minpagesize        : natural
    ; commonpagesize     : natural
    |>

(* Do we want "existing", or is it a kind of addend? 
 * We do want it -- modelling both separately is necessary, 
 * because we model relocations bytewise, but some arches
 * do bitfield relocations (think ARM). *)

type null_abi_feature = unit

let elf_section_is_special s f = s.elf64_section_type <> sht_progbits
                     && s.elf64_section_type <> sht_nobits

val null_abi : abi
let null_abi = <| is_valid_elf_header = fun x -> List.take 4 x.elf64_ident = [elf_mn_mag0; elf_mn_mag1; elf_mn_mag2; elf_mn_mag3]
                ; reloc = fun r -> (fun _ -> 8, fun _ -> Nothing)
                ; section_is_special = elf_section_is_special
                ; section_is_large = (fun s -> (fun f -> false))
                ; maxpagesize = 2 * 256 * 4096 (* 2MB; bit of a guess, based on gdb and prelink code *)
                ; minpagesize = 1024 (* bit of a guess again *)
                ; commonpagesize = 4096
                |>

(* HMM. For the elf_ident, I don't really want to express it this way.
 * I want something more bidirectional: something that can tell me 
 * not only that a given ident is valid for a given ABI, but also, 
 * to *construct* an ident for a given abstract ELF file satisfying x.
 * This is very much like a lens. 
 * 
 * Similarly for relocs, I might want a way to map back to an allowable
 * *concrete* representation, from some *abstract* description of the 
 * reloc's intent (i.e. a symbol binding: "point this reference at symbol
 * Foo"), given the constraints imposed by the ABI (such as "use only 
 * RELA, not rel". FIXME: figure out how to lensify what we're doing. *) 
 
val compute_virtual_address_adjustment : natural -> natural -> natural -> natural
let compute_virtual_address_adjustment max_page_size offset vaddr =
  (vaddr - offset) mod max_page_size


type elf_range_tag = range_tag

let null_symbol_reference = <|
    ref_symname = ""
    ; ref_syment = elf64_null_symbol_table_entry
    ; ref_sym_scn = 0
    ; ref_sym_idx = 0
|>

let null_elf_relocation_a =
  <| elf64_ra_offset = elf64_addr_of_natural 0  
   ; elf64_ra_info   = elf64_xword_of_natural 0 
   ; elf64_ra_addend = elf64_sxword_of_integer 0
   |>

let null_symbol_reference_and_reloc_site = <|
    ref = null_symbol_reference
    ; ref_relent = null_elf_relocation_a
    ; ref_rel_scn = 0
    ; ref_rel_idx = 0
    ; ref_src_scn = 0
|>
let null_symbol_definition = <|
    def_symname = ""
    ; def_syment = elf64_null_symbol_table_entry
    ; def_sym_scn = 0
    ; def_sym_idx = 0
|>

let null_section_header_table = ElfSectionHeaderTable([])
let null_program_header_table = ElfProgramHeaderTable([])
let null_elf_header = <| 
     elf64_ident    = []
   ; elf64_type     = elf64_half_of_natural 0  
   ; elf64_machine  = elf64_half_of_natural 0  
   ; elf64_version  = elf64_word_of_natural 0  
   ; elf64_entry    = elf64_addr_of_natural 0  
   ; elf64_phoff    = elf64_off_of_natural 0   
   ; elf64_shoff    = elf64_off_of_natural 0   
   ; elf64_flags    = elf64_word_of_natural 0  
   ; elf64_ehsize   = elf64_half_of_natural 0  
   ; elf64_phentsize= elf64_half_of_natural 0  
   ; elf64_phnum    = elf64_half_of_natural 0  
   ; elf64_shentsize= elf64_half_of_natural 0  
   ; elf64_shnum    = elf64_half_of_natural 0  
   ; elf64_shstrndx = elf64_half_of_natural 0  
   |>


val elf_memory_image_header : elf_memory_image -> elf64_header
let elf_memory_image_header img = 
    (* 1. find a unique range labelled as ELF section header table. *)
    match unique_tag_matching (FileFeature(ElfHeader(null_elf_header))) img with
        FileFeature(ElfHeader(x)) -> x
        | _ -> failwith "impossible: no header"
    end

val elf_memory_image_sht : elf_memory_image -> maybe elf64_section_header_table
let elf_memory_image_sht img = 
    match unique_tag_matching (FileFeature(null_section_header_table)) img with
        FileFeature(ElfSectionHeaderTable(x)) -> Just x
        | _ -> Nothing
    end

val elf_memory_image_section_ranges : elf_memory_image -> (list elf_range_tag * list element_range)
let elf_memory_image_section_ranges img = 
    (* find all element ranges labelled as ELF sections *)
    unzip (
        tagged_ranges_matching_tag (FileFeature(ElfSection(0, null_elf64_interpreted_section))) img
    )

val elf_memory_image_section_by_index : natural -> elf_memory_image -> maybe elf64_interpreted_section
let elf_memory_image_section_by_index idx img = 
    (* find all element ranges labelled as ELF sections *)
    let (allSectionTags, allSectionElementRanges) = elf_memory_image_section_ranges img 
    in
    let matches = mapMaybei (fun i -> (fun tag -> match tag with
         FileFeature(ElfSection(idx, s)) -> Just s
        | FileFeature(ElfSection(_, s)) -> Nothing
        | _ -> failwith "impossible"
    end)) allSectionTags
    in
    match matches with
        [] -> Nothing
        | [x] -> Just x
        | _ -> failwith "impossible: more than one ELF section with same index"
    end

val elf_memory_image_element_coextensive_with_section : natural -> elf_memory_image -> maybe string
let elf_memory_image_element_coextensive_with_section idx img = 
    (* find all element ranges labelled as ELF sections *)
    let (allSectionTags, allSectionElementRanges) = elf_memory_image_section_ranges img 
    in
    let matches = mapMaybei (fun i -> (fun (tag, (elName, (rangeStart, rangeLen))) -> match tag with
         FileFeature(ElfSection(idx, s)) -> if rangeStart = 0 && rangeLen = s.elf64_section_size then Just elName else Nothing
        | FileFeature(ElfSection(_, s)) -> Nothing
        | _ -> failwith "impossible"
    end)) (zip allSectionTags allSectionElementRanges)
    in
    match matches with
        [] -> Nothing
        | [x] -> Just x
        | _ -> failwith "impossible: more than one ELF section with same index"
    end


val name_of_elf_interpreted_section : 
    elf64_interpreted_section -> elf64_interpreted_section -> maybe string
let name_of_elf_interpreted_section s shstrtab = 
    match get_string_at s.elf64_section_name (string_table_of_byte_sequence shstrtab.elf64_section_body) with
        Success(x) -> Just x
        | Fail(e) -> Nothing
    end

val elf_memory_image_sections_with_indices : elf_memory_image -> list (elf64_interpreted_section * natural)
let elf_memory_image_sections_with_indices img = 
    (* We have to get all sections and their names,
     * because section names need not be unique. *)
    let ((all_section_tags, all_section_ranges) : (list elf_range_tag * list element_range))
     = elf_memory_image_section_ranges img
    in
    List.map (fun tag -> 
        match tag with
            FileFeature(ElfSection(idx, i)) -> (i, idx)
            | _ -> failwith "impossible: non-section in list of sections"
        end) all_section_tags

val elf_memory_image_sections : elf_memory_image -> list elf64_interpreted_section
let elf_memory_image_sections img = 
    let (secs, _) = unzip (elf_memory_image_sections_with_indices img)
    in secs

val elf_memory_image_sections_with_name : string -> elf_memory_image -> list elf64_interpreted_section
let elf_memory_image_sections_with_name name img = 
    let all_interpreted_sections = elf_memory_image_sections img
    in
    let maybe_shstrtab = elf_memory_image_section_by_index (natural_of_elf64_half ((elf_memory_image_header img).elf64_shstrndx)) img
    in
    let shstrtab = match maybe_shstrtab with 
        Nothing -> failwith "no shtstrtab"
        | Just x -> x
    end
    in
    let all_section_names = List.map (fun i -> 
        let (stringtab : string_table) = string_table_of_byte_sequence (shstrtab.elf64_section_body) in
        match get_string_at i.elf64_section_name stringtab with
            Fail _ -> Nothing
            | Success x -> Just x
        end) all_interpreted_sections
    in
    mapMaybe (fun (n, i) -> if Just(name) = n then Just i else Nothing) (zip all_section_names all_interpreted_sections)
(*
val elf_memory_image_unique_section_with_name : string -> elf_memory_image -> elf64_interpreted_section
let elf_memory_image_unique_section_with_name name img = 
    match Map.lookup name img.image with
        Just el -> match el with
            FileFeature(ElfSection(_, x)) -> x
            | _ -> failwith "impossible: section name does not name a section"
        end
        | 
        | Nothing -> failwith ("no section named '" ^ name ^ "' but asserted unique")
    end
*)

val elf_memory_image_symbol_def_ranges : elf_memory_image -> (list elf_range_tag * list element_range)
let elf_memory_image_symbol_def_ranges img = 
    (* find all element ranges labelled as ELF symbols *)
    unzip (
        tagged_ranges_matching_tag (SymbolDef(null_symbol_definition)) img
    )

val name_of_symbol_def : symbol_definition -> string
let name_of_symbol_def sym = sym.def_symname

val elf_memory_image_defined_symbols : elf_memory_image -> list symbol_definition
let elf_memory_image_defined_symbols img = 
    let ((all_symbol_tags, all_symbol_ranges) : (list elf_range_tag * list element_range))
     = elf_memory_image_section_ranges img
    in
    List.mapMaybe (fun tag -> 
        match tag with
            SymbolDef(ent) -> Just ent
            | _ -> failwith "impossible: non-symbol def in list of symbol defs"
        end) all_symbol_tags

(*
val elf_memory_image_symbols_with_name : string -> elf_memory_image -> list symbol_definition
let elf_memory_image_symbols_with_name name img = 
    let all_interpreted_sections = elf_memory_image_sections img
    in
    let maybe_shstrtab = elf_memory_image_section_by_index (natural_of_elf64_half ((elf_memory_image_header img).elf64_shstrndx)) img
    in
    let shstrtab = match maybe_shstrtab with 
        Nothing -> failwith "no shtstrtab"
        | Just x -> x
    end
    in
    let all_section_names = List.map (fun i -> 
        let (stringtab : string_table) = string_table_of_byte_sequence (shstrtab.elf64_section_body) in
        match get_string_at i.elf64_section_name stringtab with
            Fail _ -> Nothing
            | Success x -> Just x
        end) all_interpreted_sections
    in
    mapMaybe (fun (n, i) -> if Just(name) = n then Just i else Nothing) (zip all_section_names all_interpreted_sections)
*)
(*
val elf_memory_image_unique_symbol_with_name : string -> elf_memory_image -> symbol_def
let elf_memory_image_unique_symbol_with_name name img = 
    match Map.lookup name img.image with
        Just el -> match el with
            FileFeature(ElfSection(_, x)) -> x
            | _ -> failwith "impossible: section name does not name a section"
        end
        | 
        | Nothing -> failwith ("no section named '" ^ name ^ "' but asserted unique")
    end
*)


val name_of_elf_section : elf64_interpreted_section -> elf_memory_image -> maybe string
let name_of_elf_section sec img = 
   let shstrndx = natural_of_elf64_half ((elf_memory_image_header img).elf64_shstrndx)
   in
   match elf_memory_image_section_by_index shstrndx img with
        Nothing -> Nothing
        | Just shstrtab -> name_of_elf_interpreted_section sec shstrtab
  end

val name_of_elf_element : elf_file_feature -> elf_memory_image -> maybe string
let name_of_elf_element feature img = 
    match feature with
        ElfSection(_, sec) -> name_of_elf_section sec img
        | _ -> Nothing (* FIXME *) 
    end
    
(*
val null_abi_lift_memory_image : elf64_file -> elf_memory_image
let null_abi_lift_memory_image ef =
*)

val segment_load_ranges : elf64_interpreted_segments -> list (natural * natural)
let segment_load_ranges es = 
    let get_range : elf64_interpreted_segment -> list (natural * natural) = (
        fun x -> if x.elf64_segment_type = elf_pt_load 
            then [(x.elf64_segment_base, x.elf64_segment_base + x.elf64_segment_memsz)] 
            else []
    )
    in
    foldl (++) [] (List.map get_range es) 

val range_models_section : elf64_interpreted_section -> natural -> natural -> bool
let range_models_section s base len = 
    true

val encode_relocated_bytes : abi -> natural -> natural -> natural -> natural -> (* linkable_item -> linkable_item -> *) (symbol_reference * maybe symbol_definition) ->
    list (maybe byte)
let encode_relocated_bytes   a      r_type     site_addr  addend     existing   (* ref_l            def_l            *) binding
 =  (* We shouldn't need the relocation record from the referring linkable;
     * assume that's been handled by the caller. *)
    (* 0. Ask the ABI about this relocation type id *)
    let (widthfn, applyfn) = a.reloc r_type
    in
    let (ref, maybe_def) = binding
    in
    let maybe_defsym = match maybe_def with
     Nothing -> Nothing
     | Just s -> Just s.def_syment
    end
    in
    (* widthfn is (maybe elf64_symbol_table_entry -> natural)  *)
    (* applyfn is all naturals: (symaddr -> addend  -> existing -> relocated) *)
    Missing_pervasives.replicate (widthfn maybe_defsym) Nothing

val section_as_byte_pattern : abi 
    -> endianness 
    -> elf64_interpreted_section 
    -> elf64_interpreted_sections 
    -> Map.map (natural * natural * natural) (list (symbol_reference * maybe symbol_definition))
    -> list (maybe byte)
let section_as_byte_pattern a endian s all_s all_bindings_by_ref_idx_scn_symind =
    (* Zero-pad a bss section *)
    let body = 
        if s.elf64_section_type = sht_nobits 
        then Byte_sequence.zeros s.elf64_section_size
        else s.elf64_section_body
    in
    let s_bytes = match body with Sequence(bs) -> bs end
    in
    let maybeIndex = Missing_pervasives.find_index (fun el -> el = s) all_s
    in
    let index = match maybeIndex with 
        Just i -> i
        | _ -> failwith "section not in list of sections"
    end
    in
    let relss = [rels | forall (rels MEM all_s) | 
        rels.elf64_section_type = sht_rel && rels.elf64_section_info = index]
    in
    let relss_records = List.concatMap
        (fun rels -> match read_elf64_relocation_section rels.elf64_section_size endian rels.elf64_section_body with
            Fail _ -> failwith "reading rels"
            | Success (recs, rest) -> recs
        end)
        relss
    in
    let relass = [relas | forall (relas MEM all_s) | 
        relas.elf64_section_type = sht_rela && relas.elf64_section_info = index]
    in
    let relass_records = List.concatMap 
        (fun relas -> match read_elf64_relocation_a_section relas.elf64_section_size endian relas.elf64_section_body with
            Fail _ -> failwith "reading relas"
            | Success (recs, rest) -> recs
        end)
        relass
    in
    (* Now we have all the relocation sections; turn them into lists of relocated ranges:
     * (offset, byte-pattern). For relocations we don't understand yet, we relax it to
     * a list of maybe-bytes *)
    let (rel_ranges : list (natural * list (maybe byte)))
     =  let (width_of_relocation : elf64_relocation -> natural) = (fun r -> 
            let (width_fun, f) = a.reloc (elf64_relocation_r_type r.elf64_r_info) 
            in width_fun Nothing) (* FIXME *)
        in List.map (fun r -> 
            (natural_of_elf64_addr r.elf64_r_offset, 
                (* encode_relocated_bytes a (elf64_relocation_r_type r.elf64_r_type) (* site_addr*) r.elf64_r_offset (* addend *) 0 (* existing *) 0 (* ref_l *)  (* def_l *)  (* binding *) *)
                Missing_pervasives.replicate (width_of_relocation r) Nothing
            )) relss_records
    in
    let (rela_ranges : list (natural * list (maybe byte)))
     =  let (width_of_relocation_a : elf64_relocation_a -> natural) = (fun ra -> 
            let (width_fun, f) = a.reloc (elf64_relocation_r_type ra.elf64_ra_info) 
            in width_fun Nothing) (* FIXME *)
         in List.map (fun r -> 
            (natural_of_elf64_addr r.elf64_ra_offset, 
                (* encode_relocated_bytes  a (elf64_relocation_r_type r.elf64_r_type) (* site_addr*) r.elf64_r_offset (* addend *) 0 (* existing *) 0 (* ref_l *)  (* def_l *)  (* binding *) *)
                Missing_pervasives.replicate (width_of_relocation_a r) Nothing
            )) relass_records
    in
    let r_ranges = rel_ranges ++ rela_ranges
    in
    let sorted_r_bases_and_pats = sortBy (fun (base1, pat1) -> (fun (base2, pat2) -> base1 < base2)) r_ranges
    in
    let sorted_r_ranges = List.map (fun (b, pat) -> (b, Missing_pervasives.length pat)) sorted_r_bases_and_pats
    in
    let expanded_r_ranges = expand_sorted_ranges sorted_r_ranges s.elf64_section_size []
    in
    let bp = make_byte_pattern s_bytes expanded_r_ranges
    in
    let _ = Missing_pervasives.prints ("Section name-number " ^ (show s.elf64_section_name) ^ " has byte-pattern of length " ^ (show (Missing_pervasives.length bp)) ^ "\n") in
    bp

val pattern_possible_starts_in_one_load_phdr : string -> list (maybe byte) -> elf64_interpreted_segment -> natural -> list natural
let pattern_possible_starts_in_one_load_phdr phdr_name pattern seg offset =
    (* zero-pad the segment body to memsz *)
    match zero_pad_to_length seg.elf64_segment_memsz seg.elf64_segment_body with 
        Sequence(bytes) ->
            let ret = pattern_possible_starts_in_one_byte_sequence pattern bytes 0
            in  
            let _ = Missing_pervasives.prints 
                ("Pattern of length " ^ (show (Missing_pervasives.length pattern)) 
                ^ " (" ^ (show pattern) ^ ")"
                ^ " matched bytes of phdr " ^ phdr_name
                ^ " in " ^ (show (Missing_pervasives.length ret)) ^ " ways: "
                ^ (if (Missing_pervasives.length ret) < 2000 then (show ret) else "(not shown)") ^ "\n") in
            ret
    end

val pattern_possible_starts_in_load_phdrs : list (maybe byte) -> elf64_file -> list natural
let pattern_possible_starts_in_load_phdrs pattern f =
    (* for each virtual address in a segment, evaluate whether
       it might be a representation of our pattern *)
    (* only PT_LOAD segments are relevant *)
    let load_segs = List.filter (fun seg -> seg.elf64_segment_type = elf_pt_load) f.elf64_file_interpreted_segments
    in
    let _ = Missing_pervasives.prints ("Output file has " ^ (show (Missing_pervasives.length load_segs)) 
        ^ " PT_LOAD segments\n")
    in
    let seg_name = fun seg -> hex_string_of_natural seg.elf64_segment_base
    in
    let get_starts = fun seg -> pattern_possible_starts_in_one_load_phdr (seg_name seg) pattern seg 0
    in 
    let all_segs_starts = List.map get_starts load_segs
    in
    let seg_startlist_pairs = zip load_segs all_segs_starts
    in
    (* let _ = Missing_pervasives.println "Got to blah ss1" in *)
    let seg_start_pairs = [(seg, start) | forall ((seg, starts) MEM seg_startlist_pairs) (start MEM starts) | true ]
    in
    (* let _ = Missing_pervasives.println "Got to blah ss2" in *)
    let vaddr_starts = List.map (fun (seg, start) -> seg.elf64_segment_base + start) seg_start_pairs
    in
    vaddr_starts

val sec_and_start_as_range : elf64_interpreted_section -> natural -> (natural * natural)
let sec_and_start_as_range sec start = 
    (start, sec.elf64_section_size)

(* Here we build the image of a file in file offset space. 
 * To transform to memory space, we
 * 
 * - switch positions to be addresses
 * - switch lengths of nobits etc. to be memory lengths
 * - PROBLEM: an offset might map to >1 virtual address.
 *   So we have to clone it as multiple elements.
 *   Each gets a label identifying the "file feature" it came from
 *   -- i.e. sections, ELF header, SHT and PHT are all file features.
 * - PROBLEM: the memory image might only contain part of an element.
 *   We need to reflect this truncatedness somehow in the label.
 * 
 * Is the offset-space view really useful?
 * SORT OF: want to be able to make an image out of relocatable ELF files
 * that have no address assignments or phdrs yet.
 * AHA. NO. This is not an offset-space view; it's a sectionwise memory view.
 * All allocatable sections become elements with Nothing as their address.
 * The remainder of the ELF file *should* be represented as labels.
 * But, hmm, some stuff like the ELF header and SHT will likely get discarded.
 * 
 * In short, we should work entirely with memory space.
 * Then
 * 
 * - do we want to encode the aliasing of multiple virtual addresses
 *   down to single "features" in offset-space, like multiple mappings
 *   of the ELF header, say?
 *)

val offset_to_vaddr_mappings : elf64_file -> natural -> list (natural * elf64_interpreted_segment)
let offset_to_vaddr_mappings f off = 
    List.mapMaybe (fun ph ->
        if off >= ph.elf64_segment_offset
            && off < ph.elf64_segment_base + ph.elf64_segment_size
        then Just (ph.elf64_segment_base + (off - ph.elf64_segment_offset), ph)
        else Nothing
    ) f.elf64_file_interpreted_segments

val gensym : string -> string
let gensym hint = hint (* FIXME: remember duplicates *)

val extract_symbol : (elf64_symbol_table * string_table * natural) -> natural -> maybe (string * elf64_symbol_table_entry)
let extract_symbol symtab_triple symidx = 
    let (symtab, strtab, scnidx) = symtab_triple
    in
    match index symidx symtab with
        Just ent -> 
            match (get_string_at (natural_of_elf64_word ent.elf64_st_name) strtab) with
                Success str -> Just (str, ent)
                | Fail _ -> Just ("", ent)    (* ELF doesn't distinguish "no string" from "empty string" *)
            end
      | Nothing -> Nothing
    end

val extract_satisfying_symbols : (elf64_symbol_table * string_table * natural) ->
    (elf64_symbol_table_entry -> bool) -> list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *))
let extract_satisfying_symbols symtab_triple pred =
    let (symtab, strtab, scnidx) = symtab_triple
    in
    mapMaybei (fun symidx -> (fun ent ->
        (match (get_string_at (natural_of_elf64_word ent.elf64_st_name) strtab) with
            Success str ->
                (* exclude undefineds *) 
                if (pred ent)
                then Just(str, ent, scnidx, symidx)
                else Nothing
            | Fail _ -> Nothing
        end)
        )) symtab
        
val extract_all_symbols : (elf64_symbol_table * string_table * natural) -> list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *))
let extract_all_symbols symtab_triple = extract_satisfying_symbols symtab_triple (fun _ -> true) 

let definitions_pred = fun ent -> (natural_of_elf64_half ent.elf64_st_shndx) <> stn_undef 
let references_pred = fun ent -> (natural_of_elf64_half ent.elf64_st_shndx) = stn_undef 

val extract_definitions_from_symtab_of_type : natural -> elf64_file -> list symbol_definition
let extract_definitions_from_symtab_of_type t e = 
    match (find_elf64_symtab_by_type t e >>= fun symtab -> (
        let (allsyms : list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *)))
         = extract_satisfying_symbols symtab definitions_pred
        in
        let (extracted : list symbol_definition)
         = mapMaybei (fun i -> (fun (str, ent, scnidx, symidx) -> Just <|
                   def_symname = str
                 ; def_syment = ent
                 ; def_sym_scn = scnidx
                 ; def_sym_idx = symidx
                 |>)) allsyms
        in return extracted
    )) with Fail _ -> [] | Success x -> x end

val extract_references_from_symtab_of_type : natural -> elf64_file -> list symbol_reference
let extract_references_from_symtab_of_type t e = 
    match (find_elf64_symtab_by_type t e >>= fun symtab -> (
    let (allsyms : list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *)))
     = extract_satisfying_symbols symtab references_pred
    in
    let (extracted : list symbol_reference) = 
        mapMaybei (fun symidx -> (fun (str, ent, scnidx, symidx) -> Just <|
                   ref_symname = str
                 ; ref_syment = ent
                 ; ref_sym_scn = scnidx
                 ; ref_sym_idx = symidx
                 |>)) allsyms
    in return extracted
    )) with Fail _ -> [] | Success x -> x end

val extract_all_relocs : elf64_file -> list (natural (* scn *) * natural (* rel idx *) * natural (* rel src scn *) * elf64_relocation_a)
let extract_all_relocs e = 
    let (all_rel_sections : list (natural * elf64_interpreted_section)) = mapMaybei (fun i -> (fun isec -> 
        if isec.elf64_section_type = sht_rel then Just (i, isec) else Nothing
    )) e.elf64_file_interpreted_sections
    in
    let (all_rela_sections : list (natural * elf64_interpreted_section)) = mapMaybei (fun i -> (fun isec -> 
        if isec.elf64_section_type = sht_rela then Just (i, isec) else Nothing
    )) e.elf64_file_interpreted_sections 
    in
    let rel_to_rela = fun rel -> <|
         elf64_ra_offset = rel.elf64_r_offset
       ; elf64_ra_info   = rel.elf64_r_info
       ; elf64_ra_addend = elf64_sxword_of_integer 0
    |>
    in
    let endian = get_elf64_header_endianness e.elf64_file_header
    in
    (* Build per-section lists of rels paired with their originating section id.
     * We also pair each element with its index *in that section*, and then flatten
     * the whole lot using mapConcat. *)
    let (all_rels_list : list (natural * natural * natural * elf64_relocation_a)) = list_reverse_concat_map (fun (scn, isec) -> 
        match read_elf64_relocation_section   isec.elf64_section_size endian isec.elf64_section_body
        with
            Success (relocs, _) -> mapMaybei (fun idx -> (fun rel -> Just (scn, idx,isec.elf64_section_info, rel_to_rela rel))) relocs
            | Fail _ -> []
        end) all_rel_sections
    in 
    let (all_relas_list : list (natural * natural * natural * elf64_relocation_a)) = list_reverse_concat_map (fun (scn, isec) -> 
        match read_elf64_relocation_a_section isec.elf64_section_size endian isec.elf64_section_body
        with
            Success (relocs, _) -> mapMaybei (fun idx -> (fun rela -> Just (scn, idx, isec.elf64_section_info, rela))) relocs
            | Fail _ -> []
        end) all_rela_sections
    in
    all_rels_list ++ all_relas_list

val extract_all_relocs_as_symbol_references : elf64_file -> list symbol_reference_and_reloc_site
let extract_all_relocs_as_symbol_references e
=   let all_relocs = extract_all_relocs e
    in
    let all_symtab_triples_by_scnidx = mapMaybei (fun scnidx -> (fun isec ->
        if isec.elf64_section_type = sht_symtab
        then
            let found = find_elf64_symbols_by_symtab_idx scnidx e
            in
            match found with 
                Fail _ -> Nothing
                | Success triple -> Just (scnidx, triple)
            end
        else Nothing
    )) e.elf64_file_interpreted_sections
    in
    let (all_extracted_symtabs_by_scnidx : (Map.map natural (list (string * elf64_symbol_table_entry * natural (* scnidx *) * natural (* symidx *)))))
     = List.foldl (fun acc -> (fun (scnidx, triple) -> Map.insert scnidx (extract_all_symbols triple) acc)) Map.empty all_symtab_triples_by_scnidx
    in
    let ref_for_relocation_a_in_section_index = fun rel_scn_idx -> (fun rela -> 
        let rela_isec = match index rel_scn_idx e.elf64_file_interpreted_sections with
            Just x -> x
            | Nothing -> failwith "relocation references nonexistent section"
        end
        in
        let symtab_idx = rela_isec.elf64_section_link
        in
        match Map.lookup symtab_idx all_extracted_symtabs_by_scnidx with
            Nothing -> failwith "referenced symtab does not exist"
            | Just quads ->
                let sym_idx = elf64_relocation_r_sym rela.elf64_ra_info
                in
                let maybe_quad = Missing_pervasives.index sym_idx quads
                in
                match maybe_quad with
                    Just(symname, syment, scnidx, symidx) -> <|
                           ref_symname = symname
                         ; ref_syment = syment
                         ; ref_sym_scn = symtab_idx
                         ; ref_sym_idx = sym_idx
                         |>
                    | Nothing -> failwith "referenced symbol does not exist"
                end
        end
    )
    in
    List.map (fun (scn, idx, srcscn, rela) -> <|
          ref = (* NOTE that a reference is not necessarily to an undefined symbol! *) ref_for_relocation_a_in_section_index scn rela
        ; ref_relent =  rela
        ; ref_rel_scn = scn
        ; ref_rel_idx = idx
        ; ref_src_scn = srcscn (* what section does the reference come from? it's the 'info' link of the rel section header *)
        |>) all_relocs

val section_name_is_unique : string -> elf64_file -> bool
let section_name_is_unique name f =
    match mapMaybe (fun sec -> 
        match name_of_elf64_interpreted_section sec f with
            Just name -> Just sec
            | Just _ -> Nothing
            | Nothing -> Nothing
        end) f.elf64_file_interpreted_sections
    with
        [_] -> true
        | _ -> false
    end

val unique_name_for_section_from_index : natural -> elf64_interpreted_section -> elf64_file -> string
let unique_name_for_section_from_index idx s f = 
    let (maybe_secname : maybe string) = name_of_elf64_interpreted_section s f
    in match maybe_secname with
        Just secname -> if section_name_is_unique secname f then secname else gensym secname
        | Nothing -> gensym ("section" ^ (show idx))
    end

val elf_memory_image_of_elf64_file : abi -> elf64_file -> elf_memory_image
let elf_memory_image_of_elf64_file a f = 
    (* Do we have program headers? This decides whether we choose a 
     * sectionwise or segmentwise view. *)
    match f.elf64_file_program_header_table with
        [] ->   let section_names_and_elements = mapMaybei (fun i -> (fun isec -> 
                   Just (unique_name_for_section_from_index i isec f, <|
                        startpos = Nothing
                      ; length = Just isec.elf64_section_size
                      ; contents = byte_pattern_of_byte_sequence isec.elf64_section_body
                    |>)
                )) f.elf64_file_interpreted_sections
                in
                (* -- annotations are reloc sites, symbol defs, ELF sections/segments/headers, PLT/GOT/...  *)
                let (elf_sections : list (element_range * range_tag)) = mapMaybei (fun secidx -> (
                    (fun (isec, (secname, _)) -> 
                        let (r : element_range) = ((secname, (0, isec.elf64_section_size)))
                        in
                        Just (r, FileFeature(ElfSection(secidx, isec)))
                    )))
                    (zip f.elf64_file_interpreted_sections section_names_and_elements)
                in
                let (symbol_defs : list (element_range * range_tag)) = mapMaybe
                    (fun x -> 
                        let section_num = natural_of_elf64_half x.def_syment.elf64_st_shndx
                        in
                        if      section_num = shn_abs    then
                            (* what do we label? FIXME *) Nothing
                        else if section_num = shn_common then (* FIXME *) Nothing
                        else
                            let (section_name, _) = match index section_num section_names_and_elements with
                                Just x -> x
                                | Nothing -> failwith ("symbol " ^ x.def_symname ^ " references nonexistent section")
                            end
                            in
                            Just ((section_name, (natural_of_elf64_addr x.def_syment.elf64_st_value, natural_of_elf64_xword x.def_syment.elf64_st_size)), SymbolDef(x))
                    )
                    (extract_definitions_from_symtab_of_type sht_symtab f)
                in
                let (all_reloc_sites : list (element_range * range_tag)) = List.map 
                    (fun x ->
                        let (section_name, _) = match index (x.ref_src_scn) section_names_and_elements with
                            Just y -> y
                            | Nothing -> failwith "relocs came from nonexistent section"
                        end
                        in
                        let (szfun, applyfn) = a.reloc (elf64_relocation_r_type x.ref_relent.elf64_ra_info)
                        in
                        let sz = szfun Nothing (* FIXME *)
                        in
                        let (offset : elf64_addr) = x.ref_relent.elf64_ra_offset
                        in 
                        ((section_name, (natural_of_elf64_addr offset, sz)), RelocationSite(x))
                    )
                    (extract_all_relocs_as_symbol_references f)
                in
                let elf_header = [(("header", (0, natural_of_elf64_half f.elf64_file_header.elf64_ehsize)), FileFeature(ElfHeader(f.elf64_file_header)))]
                in
                let all_annotations_list =  all_reloc_sites ++ symbol_defs ++ elf_sections ++ elf_header
                in
                let all_annotations = Set.fromList all_annotations_list
                in
                let (apply_content_relocations : string -> byte_pattern -> byte_pattern) = (fun name -> (fun content -> 
                    let this_element_reloc_annotations = List.filter (fun ((n, range), _) -> name = n) all_reloc_sites
                    in
                    let ((this_element_name_and_reloc_ranges : list (string * (natural * natural))), _) = unzip this_element_reloc_annotations
                    in
                    let (this_element_reloc_ranges : list (natural * natural)) = snd (unzip this_element_name_and_reloc_ranges)
                    in
                    let (all_ranges_expanded : list bool) = expand_unsorted_ranges this_element_reloc_ranges (Missing_pervasives.length content) []
                    in
                    relax_byte_pattern content all_ranges_expanded
                ))
                in
                let new_elements_list = List.map (fun (name, element) -> 
                    (* We can now mark the relocation sites in the section contents as "subject to change". *)
                    (
                        name, 
                        <|
                           startpos = element.startpos
                         ; length   = element.length
                         ; contents = apply_content_relocations name element.contents
                         |>
                    )
                  ) section_names_and_elements
                in
                            (*
                            List.foldr (fun acc -> (fun  element.contents this_element_reloc_ranges
                            let (expand_and_relax : list (maybe byte) -> (natural * natural) -> list (maybe byte)) = fun pat -> (fun r -> (
                                relax_byte_pattern pat (expand_ranges r)
                            ))
                            in*)
                 <|
                      elements = Map.fromList new_elements_list
                      (* : memory_image -- the image elements, without annotation, i.e. 
                        a map from string to (startpos, length, contents)
                        -- an element is the ELF header, PHT, SHT, section or segment
                        -- exploit the fact that section names beginning `.' are reserved, and 
                           the reserved ones don't use caps: ".PHT", ".SHT", ".HDR"
                        -- what about ambiguous section names? use ".GENSYM_<...>" perhaps 
                      *)
                    ; by_range = all_annotations
                    ; by_tag = let (fst, snd) = unzip all_annotations_list in Set.fromList (zip snd fst)
                        (*  : multimap (range_tag 'symdef 'reloc 'filefeature 'abifeature) (string * range) 
                         -- annotations by *)
                  |>
      | pht -> let segment_names_and_images = mapMaybei (fun i -> (fun seg -> 
                    Just(gensym (show seg.elf64_segment_base) ^ "_" ^ (show seg.elf64_segment_type), 
                    <|
                        startpos = Just seg.elf64_segment_base
                      ; length = Just seg.elf64_segment_memsz
                      ; contents = [] (* FIXME *)
                     |>)
                )) f.elf64_file_interpreted_segments
                in
                (* let annotations = *)
                 <|
                      elements = Map.fromList segment_names_and_images  (* : memory_image -- the image elements, without annotation, i.e. 
                        a map from string to (startpos, length, contents)
                        -- an element is the ELF header, PHT, SHT, section or segment
                        -- exploit the fact that section names beginning `.' are reserved, and 
                           the reserved ones don't use caps: ".PHT", ".SHT", ".HDR"
                        -- what about ambiguous section names? use ".GENSYM_<...>" perhaps 
                      *)
                    ; by_range = Set.fromList []
                        (* : map element_range (list (range_tag 'symdef 'reloc 'filefeature 'abifeature))
                         -- annotations are reloc sites, symbol defs, ELF sections/segments/headers, PLT/GOT/...  *)
                    ; by_tag = Set.fromList []
                        (*  : multimap (range_tag 'symdef 'reloc 'filefeature 'abifeature) (string * range) 
                         -- annotations by *)
                  |>

    end
