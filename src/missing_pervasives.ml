(*Generated by Lem from missing_pervasives.lem.*)
open Lem_basic_classes
open Lem_bool
open Lem_list
open Lem_maybe
open Lem_num
open Lem_string
open Lem_assert_extra
open Show

(*type byte*)
(*val natural_of_byte : byte -> natural*)

(*val char_of_byte : byte -> char*)

(* Define how to print a byte in hex *)
(*val hex_char_of_nibble : natural -> char*)
let hex_char_of_nibble n = 
  (
  if(Big_int.eq_big_int n (Big_int.big_int_of_int 0)) then '0' else
    (
    if(Big_int.eq_big_int n (Big_int.big_int_of_int 1)) then '1' else
      (
      if(Big_int.eq_big_int n (Big_int.big_int_of_int 2)) then '2' else
        (
        if(Big_int.eq_big_int n (Big_int.big_int_of_int 3)) then '3' else
          (
          if(Big_int.eq_big_int n (Big_int.big_int_of_int 4)) then '4' else
            (
            if(Big_int.eq_big_int n (Big_int.big_int_of_int 5)) then 
            '5' else
              (
              if(Big_int.eq_big_int n (Big_int.big_int_of_int 6)) then 
              '6' else
                (
                if(Big_int.eq_big_int n (Big_int.big_int_of_int 7)) then 
                '7' else
                  (
                  if(Big_int.eq_big_int n (Big_int.big_int_of_int 8)) then
                    '8' else
                    (
                    if(Big_int.eq_big_int n (Big_int.big_int_of_int 9)) then
                      '9' else
                      (
                      if(Big_int.eq_big_int n (Big_int.big_int_of_int 10)) then
                        'a' else
                        (
                        if(Big_int.eq_big_int n (Big_int.big_int_of_int 11)) then
                          'b' else
                          (
                          if(Big_int.eq_big_int n (Big_int.big_int_of_int 12)) then
                            'c' else
                            (
                            if(Big_int.eq_big_int n
                                 (Big_int.big_int_of_int 13)) then 'd' else
                              (
                              if(Big_int.eq_big_int n
                                   (Big_int.big_int_of_int 14)) then 
                              'e' else
                                (
                                if(Big_int.eq_big_int n
                                     (Big_int.big_int_of_int 15)) then 
                                'f' else
                                  failwith "Incomplete Pattern at File \"missing_pervasives.lem\", line 30, character 5 to line 47, character 7"))))))))))))))))

let hex_string_of_byte b =    
 (Xstring.implode [ hex_char_of_nibble ( Big_int.div_big_int(Ml_bindings.natural_of_char b)(Big_int.big_int_of_int 16))
             ; hex_char_of_nibble ( Big_int.mod_big_int(Ml_bindings.natural_of_char b)(Big_int.big_int_of_int 16))])

let instance_Show_Show_Missing_pervasives_byte_dict =({

  show_method = hex_string_of_byte})

(*val natural_of_decimal_digit : char -> maybe natural*)
let natural_of_decimal_digit c =    
 ((match c with
          '0' -> Some(Big_int.big_int_of_int 0)
        | '1' -> Some(Big_int.big_int_of_int 1)
        | '2' -> Some(Big_int.big_int_of_int 2)
        | '3' -> Some(Big_int.big_int_of_int 3)
        | '4' -> Some(Big_int.big_int_of_int 4)
        | '5' -> Some(Big_int.big_int_of_int 5)
        | '6' -> Some(Big_int.big_int_of_int 6)
        | '7' -> Some(Big_int.big_int_of_int 7)
        | '8' -> Some(Big_int.big_int_of_int 8)
        | '9' -> Some(Big_int.big_int_of_int 9)
        | _ -> None
    ))

(*val natural_of_decimal_string_helper : natural -> list char -> natural*)
let rec natural_of_decimal_string_helper acc chars =    
((match chars with 
        [] -> acc
        | c :: cs -> (match natural_of_decimal_digit c with
            Some dig -> natural_of_decimal_string_helper ( Big_int.add_big_int( Big_int.mult_big_int(Big_int.big_int_of_int 10) acc) dig) cs
            | None -> acc
        )
    ))

(*val natural_of_decimal_string : string -> natural*)
let natural_of_decimal_string s =    
 (natural_of_decimal_string_helper(Big_int.big_int_of_int 0) (Xstring.explode s))

(*val natural_of_bool : bool -> natural*)
let natural_of_bool b =  
((match b with
    | true  ->Big_int.big_int_of_int 1
    | false ->Big_int.big_int_of_int 0
  ))

(*val unsafe_nat_of_natural : natural -> nat*)

(*val unsafe_int_of_natural   : natural -> int*)

(*val byte_of_natural : natural -> byte*)

(*type ordering
  = Equal
  | Less
  | Greater*)

(*val natural_ordering : natural -> natural -> ordering*)
(*let natural_ordering left right =
  if (Instance_Basic_classes_Eq_Num_natural.=) left right then
    Equal
  else if (Instance_Basic_classes_Ord_Num_natural.<) left right then
    Less
  else
    Greater*)

(*val sort_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a*)

(** [intercalate sep xs] places [sep] between all elements of [xs]. *)
(*val intercalate : forall 'a. 'a -> list 'a -> list 'a*)
let rec intercalate sep xs =	
((match xs with
		| []    -> []
		| [x]   -> [x]
		| x::xs -> x::(sep::intercalate sep xs)
	))

(** [string_of_list l] produces a string representation of list [l].
  *)
(*val string_of_list : forall 'a. Show 'a => list 'a -> string*)
let string_of_list dict_Show_Show_a l =  
(let result = (intercalate "," (List.map  
  dict_Show_Show_a.show_method l)) in
  let folded = (List.fold_left (^) "" result) in
    "[" ^ (folded ^ "]"))

let instance_Show_Show_list_dict dict_Show_Show_a =({

  show_method = 
  (string_of_list dict_Show_Show_a)})

(** [mapMaybei f xs] maps a function expecting an index (the position in the list
  * [xs] that it is currently viewing) and producing a [maybe] type across a list.
  * Elements that produce [Nothing] under [f] are discarded in the output, whilst
  * those producing [Just e] for some [e] are kept.
  *)
(*val mapMaybei' : forall 'a 'b. (natural -> 'a -> maybe 'b) -> natural -> list 'a -> list 'b*)
let rec mapMaybei' f idx xs =  
((match xs with
  | []    -> []
  | x::xs ->
      (match f idx x with
      | None -> mapMaybei' f ( Big_int.add_big_int(Big_int.big_int_of_int 1) idx) xs
      | Some e  -> e :: mapMaybei' f ( Big_int.add_big_int(Big_int.big_int_of_int 1) idx) xs
      )
  ))

(*val mapMaybei : forall 'a 'b. (natural -> 'a -> maybe 'b) -> list 'a -> list 'b*)
    
let mapMaybei f xs =  
(mapMaybei' f(Big_int.big_int_of_int 0) xs)

(** [unlines xs] concatenates a list of strings [xs], placing each entry
  * on a new line.
  *)
(*val unlines : list string -> string*)
let unlines xs =  
(List.fold_right (^) (intercalate "\n" xs) "")

(** [bracket xs] concatenates a list of strings [xs], separating each entry with a
  * space, and bracketing the resulting string.
  *)
(*val bracket : list string -> string*)
let bracket xs =  
("(" ^ (List.fold_right (^) (intercalate " " xs) "" ^ ")"))

(** [null_char] is the null character. *)
(*val null_char : byte*)

(** [split_string_on_char s c] splits a string [s] into a list of substrings
  * on character [c], otherwise returning the singleton list containing [s]
  * if [c] is not found in [s].
  *)
(*val split_string_on_char : string -> char -> list string*)

(** [println s] prints [s] to stdout, adding a trailing newline. *)
(*val println : string -> unit*)

(** [prints s] prints [s] to stdout, without adding a trailing newline. *)
(*val prints : string -> unit*)

(** [string_of_nat m] produces a string representation of natural number [m]. *)
(*val string_of_nat : nat -> string*)

(** [string_suffix i s] chops [i] characters off [s], returning a new string.
  * Fails if the index is negative, or beyond the end of the string.
  *)
(*val string_suffix : natural -> string -> maybe string*)

(*val index : forall 'a. natural -> list 'a -> maybe 'a*)

(*val find_index_helper : forall 'a. natural -> ('a -> bool) -> list 'a -> maybe natural*)
let rec find_index_helper count p xs =	
((match xs with
		| []    -> None
		| y::ys ->
			if p y then
				Some count
			else
				find_index_helper ( Big_int.add_big_int count(Big_int.big_int_of_int 1)) p ys
	))

(*val find_index : forall 'a. ('a -> bool) -> list 'a -> maybe natural*)
let find_index0 p xs = (find_index_helper(Big_int.big_int_of_int 0) p xs)

(*val length : forall 'a. list 'a -> natural*)

(*val nat_length : forall 'a. list 'a -> nat*)

let length xs = (Big_int.big_int_of_int (List.length xs))

(*val argv : list string*)

(*val replicate : forall 'a. natural -> 'a -> list 'a*)
let rec replicate0 len e = 
  (
  if(Big_int.eq_big_int len (Big_int.big_int_of_int 0)) then ([]) else
    (e ::
       replicate0 ( Nat_num.natural_monus len (Big_int.big_int_of_int 1)) e))
