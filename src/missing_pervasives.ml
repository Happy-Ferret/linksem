(*Generated by Lem from missing_pervasives.lem.*)
open Lem_basic_classes
open Lem_bool
open Lem_list
open Lem_maybe
open Lem_num
open Lem_string
open Lem_assert_extra
open Show
open Lem_sorting

(*val naturalZero : natural*)

(*val id : forall 'a. 'a -> 'a*)
let id0 x = x

(*type byte*)
(*val natural_of_byte : byte -> natural*)

(*val char_of_byte : byte -> char*)

(* Define how to print a byte in hex *)
(*val hex_char_of_nibble : natural -> char*)
let hex_char_of_nibble n = 
  (
  if(Nat_big_num.equal n (Nat_big_num.of_int 0)) then '0' else
    (
    if(Nat_big_num.equal n (Nat_big_num.of_int 1)) then '1' else
      (
      if(Nat_big_num.equal n (Nat_big_num.of_int 2)) then '2' else
        (
        if(Nat_big_num.equal n (Nat_big_num.of_int 3)) then '3' else
          (
          if(Nat_big_num.equal n (Nat_big_num.of_int 4)) then '4' else
            (
            if(Nat_big_num.equal n (Nat_big_num.of_int 5)) then '5' else
              (
              if(Nat_big_num.equal n (Nat_big_num.of_int 6)) then '6' else
                (
                if(Nat_big_num.equal n (Nat_big_num.of_int 7)) then '7' else
                  (
                  if(Nat_big_num.equal n (Nat_big_num.of_int 8)) then 
                  '8' else
                    (
                    if(Nat_big_num.equal n (Nat_big_num.of_int 9)) then 
                    '9' else
                      (
                      if(Nat_big_num.equal n (Nat_big_num.of_int 10)) then
                        'a' else
                        (
                        if(Nat_big_num.equal n (Nat_big_num.of_int 11)) then
                          'b' else
                          (
                          if(Nat_big_num.equal n (Nat_big_num.of_int 12)) then
                            'c' else
                            (
                            if(Nat_big_num.equal n (Nat_big_num.of_int 13)) then
                              'd' else
                              (
                              if(Nat_big_num.equal n (Nat_big_num.of_int 14)) then
                                'e' else
                                (
                                if(Nat_big_num.equal n
                                     (Nat_big_num.of_int 15)) then 'f' else
                                  failwith "Incomplete Pattern at File \"missing_pervasives.lem\", line 38, character 5 to line 55, character 7"))))))))))))))))

let hex_string_of_byte b =    
 (Xstring.implode [ hex_char_of_nibble ( Nat_big_num.div(Nat_big_num.of_int (Char.code b))(Nat_big_num.of_int 16))
             ; hex_char_of_nibble ( Nat_big_num.modulus(Nat_big_num.of_int (Char.code b))(Nat_big_num.of_int 16))])

let instance_Show_Show_Missing_pervasives_byte_dict =({

  show_method = hex_string_of_byte})

(*val natural_of_decimal_digit : char -> maybe natural*)
let natural_of_decimal_digit c =    
 ((match c with
          '0' -> Some(Nat_big_num.of_int 0)
        | '1' -> Some(Nat_big_num.of_int 1)
        | '2' -> Some(Nat_big_num.of_int 2)
        | '3' -> Some(Nat_big_num.of_int 3)
        | '4' -> Some(Nat_big_num.of_int 4)
        | '5' -> Some(Nat_big_num.of_int 5)
        | '6' -> Some(Nat_big_num.of_int 6)
        | '7' -> Some(Nat_big_num.of_int 7)
        | '8' -> Some(Nat_big_num.of_int 8)
        | '9' -> Some(Nat_big_num.of_int 9)
        | _ -> None
    ))

(*val natural_of_decimal_string_helper : natural -> list char -> natural*)
let rec natural_of_decimal_string_helper acc chars =    
((match chars with 
        [] -> acc
        | c :: cs -> (match natural_of_decimal_digit c with
            Some dig -> natural_of_decimal_string_helper ( Nat_big_num.add( Nat_big_num.mul(Nat_big_num.of_int 10) acc) dig) cs
            | None -> acc
        )
    ))

(*val natural_of_decimal_string : string -> natural*)
let natural_of_decimal_string s =    
 (natural_of_decimal_string_helper(Nat_big_num.of_int 0) (Xstring.explode s))

(*val hex_string_of_natural : natural -> string*)
let rec hex_string_of_natural n =    
 (if Nat_big_num.less_equal n(Nat_big_num.of_int 16) then Xstring.implode [hex_char_of_nibble n]
    else (hex_string_of_natural ( Nat_big_num.div n(Nat_big_num.of_int 16))) ^ (Xstring.implode [hex_char_of_nibble ( Nat_big_num.modulus n(Nat_big_num.of_int 16))]))

(*val natural_of_bool : bool -> natural*)
let natural_of_bool b =  
((match b with
    | true  ->Nat_big_num.of_int 1
    | false ->Nat_big_num.of_int 0
  ))

(*val unsafe_nat_of_natural : natural -> nat*)

(*val unsafe_int_of_natural   : natural -> int*)

(*val byte_of_natural : natural -> byte*)

(*type ordering
  = Equal
  | Less
  | Greater*)

(*val natural_ordering : natural -> natural -> ordering*)
(*let natural_ordering left right =
  if (Instance_Basic_classes_Eq_Num_natural.=) left right then
    Equal
  else if (Instance_Basic_classes_Ord_Num_natural.<) left right then
    Less
  else
    Greater*)

(*val sort_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a*)

(** [intercalate sep xs] places [sep] between all elements of [xs]. *)
(*val intercalate : forall 'a. 'a -> list 'a -> list 'a*)
let rec intercalate sep xs =	
((match xs with
		| []    -> []
		| [x]   -> [x]
		| x::xs -> x::(sep::intercalate sep xs)
	))

(** [string_of_list l] produces a string representation of list [l].
  *)
(*val string_of_list : forall 'a. Show 'a => list 'a -> string*)
let string_of_list dict_Show_Show_a l =  
(let result = (intercalate "," (Llist.map  
  dict_Show_Show_a.show_method l)) in
  let folded = (List.fold_left (^) "" result) in
    "[" ^ (folded ^ "]"))

let instance_Show_Show_list_dict dict_Show_Show_a =({

  show_method = 
  (string_of_list dict_Show_Show_a)})

(** [mapMaybei f xs] maps a function expecting an index (the position in the list
  * [xs] that it is currently viewing) and producing a [maybe] type across a list.
  * Elements that produce [Nothing] under [f] are discarded in the output, whilst
  * those producing [Just e] for some [e] are kept.
  *)
(*val mapMaybei' : forall 'a 'b. (natural -> 'a -> maybe 'b) -> natural -> list 'a -> list 'b*)
let rec mapMaybei' f idx xs =  
((match xs with
  | []    -> []
  | x::xs ->
      (match f idx x with
      | None -> mapMaybei' f ( Nat_big_num.add(Nat_big_num.of_int 1) idx) xs
      | Some e  -> e :: mapMaybei' f ( Nat_big_num.add(Nat_big_num.of_int 1) idx) xs
      )
  ))

(*val mapMaybei : forall 'a 'b. (natural -> 'a -> maybe 'b) -> list 'a -> list 'b*)
    
let mapMaybei f xs =  
(mapMaybei' f(Nat_big_num.of_int 0) xs)

(** [partitionii is xs] returns a pair of lists: firstly those elements in [xs] that are
    at indices in [is], and secondly the remaining elements. 
    It preserves the order of elements in xs. *)
(*val partitionii' : forall 'a. natural -> list natural -> list 'a 
    -> list (natural * 'a) (* accumulates the 'in' partition *)
    -> list (natural * 'a) (* accumulates the 'out' partition *)
    -> (list (natural * 'a) * list (natural * 'a))*)
let rec partitionii' (offset : Nat_big_num.num) sorted_is xs reverse_accum reverse_accum_compl =    
( 
    (* offset o means "xs begins at index o, as reckoned by the indices in sorted_is" *)(match sorted_is with
        [] -> (List.rev reverse_accum, List.rev reverse_accum_compl)
        | i :: more_is -> 
            let (length_to_split_off : int) = (Nat_big_num.to_int ( Nat_big_num.sub_nat i offset))
            in
            let (left, right) = (Lem_list.split_at length_to_split_off xs) in
            let left_indices : Nat_big_num.num list = (Lem_list.genlist 
                (fun j -> Nat_big_num.add (Nat_big_num.of_int j) offset)
                (List.length left)) 
            in
            let left_with_indices = (list_combine left_indices left) in
            (* left begins at offset, right begins at offset + i *)
            (match right with 
                [] -> (* We got to the end of the list before the target index. *) 
                    (List.rev reverse_accum, 
                     List.rev_append reverse_accum_compl left_with_indices)
                | x :: more_xs -> 
                    (* x is at index i by definition, so more_xs starts with index i + 1 *)
                    partitionii' (Nat_big_num.add i(Nat_big_num.of_int 1)) more_is more_xs ((i, x) :: reverse_accum) 
                        (List.rev_append left_with_indices reverse_accum_compl)
            )
    ))

(*val filteri : forall 'a. list natural -> list 'a -> list 'a*)
let filteri is xs =    
 (let sorted_is = (List.sort Nat_big_num.compare is) in
    let (accum, accum_compl) = (partitionii'(Nat_big_num.of_int 0) sorted_is xs [] [])
    in 
    let (just_indices, just_items) = (List.split accum)
    in 
    just_items)

(*val filterii : forall 'a. list natural -> list 'a -> list (natural * 'a)*)
let filterii is xs =    
 (let sorted_is = (List.sort Nat_big_num.compare is) in
    let (accum, accum_compl) = (partitionii'(Nat_big_num.of_int 0) sorted_is xs [] [])
    in 
    accum)

(*val partitioni : forall 'a. list natural -> list 'a -> (list 'a * list 'a)*)
let partitioni is xs =    
 (let sorted_is = (List.sort Nat_big_num.compare is) in
    let (accum, accum_compl) = (partitionii'(Nat_big_num.of_int 0) sorted_is xs [] [])
    in
    let (just_indices, just_items) = (List.split accum)
    in
    let (just_indices_compl, just_items_compl) = (List.split accum_compl)
    in
    (just_items, just_items_compl))

(*val partitionii : forall 'a. list natural -> list 'a -> (list (natural * 'a) * list (natural * 'a))*)
let partitionii is xs =    
 (let sorted_is = (List.sort Nat_big_num.compare is) in
    partitionii'(Nat_big_num.of_int 0) sorted_is xs [] [])

(** [unzip3 ls] takes a list of triples and returns a triple of lists. *)
(*val unzip3: forall 'a 'b 'c. list ('a * 'b * 'c) -> (list 'a * list 'b * list 'c)*)
let rec unzip3 l = ((match l with
  | [] -> ([], [], [])
  | (x, y, z) :: xyzs -> let (xs, ys, zs) = (unzip3 xyzs) in ((x :: xs), (y :: ys), (z :: zs))
))

(** [unlines xs] concatenates a list of strings [xs], placing each entry
  * on a new line.
  *)
(*val unlines : list string -> string*)
let unlines xs =  
(List.fold_left (^) "" (intercalate "\n" xs))

(** [bracket xs] concatenates a list of strings [xs], separating each entry with a
  * space, and bracketing the resulting string.
  *)
(*val bracket : list string -> string*)
let bracket xs =  
("(" ^ (List.fold_left (^) "" (intercalate " " xs) ^ ")"))

(** [null_char] is the null character. *)
(*val null_char : byte*)

(** [split_string_on_char s c] splits a string [s] into a list of substrings
  * on character [c], otherwise returning the singleton list containing [s]
  * if [c] is not found in [s].
  *)
(*val split_string_on_char : string -> char -> list string*)

(** [println s] prints [s] to stdout, adding a trailing newline. *)
(*val println : string -> unit*)

(** [prints s] prints [s] to stdout, without adding a trailing newline. *)
(*val prints : string -> unit*)

(** [string_of_nat m] produces a string representation of natural number [m]. *)
(*val string_of_nat : nat -> string*)

(** [string_suffix i s] chops [i] characters off [s], returning a new string.
  * Fails if the index is negative, or beyond the end of the string.
  *)
(*val string_suffix : natural -> string -> maybe string*)

(*val index : forall 'a. natural -> list 'a -> maybe 'a*)

(*val find_index_helper : forall 'a. natural -> ('a -> bool) -> list 'a -> maybe natural*)
let rec find_index_helper count p xs =	
((match xs with
		| []    -> None
		| y::ys ->
			if p y then
				Some count
			else
				find_index_helper ( Nat_big_num.add count(Nat_big_num.of_int 1)) p ys
	))

(*val find_index : forall 'a. ('a -> bool) -> list 'a -> maybe natural*)
let find_index0 p xs = (find_index_helper(Nat_big_num.of_int 0) p xs)

(*val length : forall 'a. list 'a -> natural*)

(*val nat_length : forall 'a. list 'a -> nat*)

let length xs = (Nat_big_num.of_int (List.length xs))

(*val argv : list string*)

(*val replicate : forall 'a. natural -> 'a -> list 'a*)
let rec replicate0 len e = 
  (
  if(Nat_big_num.equal len (Nat_big_num.of_int 0)) then ([]) else
    (e :: replicate0 ( Nat_big_num.sub_nat len (Nat_big_num.of_int 1)) e))

(* We want a tail-recursive append. reverse_append l1 l2 appends l2 to the
 * reverse of l1. So we get [l1-backwards] [l2]. So just reverse l1. *)
(*val list_append : forall 'a. list 'a -> list 'a -> list 'a*)
let list_append l1 l2 =    
(List.rev_append (List.rev l1) l2)

(*val list_concat : forall 'a. list (list 'a) -> list 'a*) 
let list_concat ll = (List.fold_left list_append [] ll)

(*val list_concat_map : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b*)
let list_concat_map f l =    
 (list_concat (Llist.map f l))

(*val list_reverse_concat_map_helper : forall 'a 'b. ('a -> list 'b) -> list 'b -> list 'a -> list 'b*)
let rec list_reverse_concat_map_helper f acc ll =    
 (let lcons = (fun l -> (fun i -> i :: l))
    in
    (match ll with
      | []      -> acc
      | item :: items -> 
            (* item is a thing that maps to a list. it needn't be a list yet *)
            let mapped_list = (f item)
            in 
            (* let _ = Missing_pervasives.println ("Map function gave us a list of " ^ (show (List.length mapped_list)) ^ " items") in *)
            list_reverse_concat_map_helper f (List.fold_left lcons acc (f item)) items
    ))

(*val list_reverse_concat_map : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b*)
let list_reverse_concat_map f ll = (list_reverse_concat_map_helper f [] ll)

(*val list_take_with_accum : forall 'a. nat -> list 'a -> list 'a -> list 'a*)
let rec list_take_with_accum n reverse_acc l =   
(
  (*  let _ = Missing_pervasives.prints ("Taking a byte; have accumulated " ^ (show (List.length acc) ^ " so far\n"))
   in *)(match n with
        0 -> List.rev reverse_acc
      | _ -> (match l with
            [] -> failwith "list_take_with_accum: not enough elements"
            | x :: xs -> list_take_with_accum (Nat_num.nat_monus n( 1)) (x :: reverse_acc) xs
        )
    ))

(*val unsafe_string_take : natural -> string -> string*)
let unsafe_string_take m str =  
(let m = (Nat_big_num.to_int m) in
    Xstring.implode (Lem_list.take m (Xstring.explode str)))
