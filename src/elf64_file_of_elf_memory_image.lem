open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Map
import Set
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_file
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_symbol_table
open import Elf_types_native_uint
open import Elf_relocation
open import String_table

open import Memory_image
open import Memory_image_orderings

open import Elf_memory_image
open import Elf_memory_image_of_elf64_file
open import Abis

(* Things the caller should do first: *)
(* - create segment annotations *)
(* - create .dynamic-equivalent metadata (but not the section) *)
(* - concretise symbolic elements? actually they pass a function to do this. *)

type make_concrete_fn = Memory_image.element -> Memory_image.element

(* Things we do, at the caller's direction:*)
(* - create SHT *)
(* - create symtabs, strtabs, symbol hash tables (the ABI helps us) *)
(* - create shstrtab (if we're creating a SHT) *)
(* - actually create the dynamic section (and its PHDR) *)
(* - create any other PHDRs (the ABI tells us, mostly) and PT_PHDR (the user tells us) *)

val elf64_file_of_elf_memory_image : abi any_abi_feature -> make_concrete_fn -> string -> elf_memory_image -> elf64_file
let elf64_file_of_elf_memory_image a make_concrete fname img = 
    (* Generate an ELF header, (optionally) SHT and (optionally) PHT, 
     * based on metadata in the image.
     * 
     * How do we decide what kind of ELF file to generate?     see whether we have segment annotations?
                        what architecture/osabi to give?       the ABI tells us
                        
     *)
    let (section_tags, section_ranges) = elf_memory_image_section_ranges img
    in
    let section_tags_bare = List.map (fun tag -> 
        match tag with 
            | FileFeature(ElfSection(idx, isec)) -> (idx, isec)
            | _ -> failwith "not section tag"
        end) section_tags
    in
    let basic_shstrtab = List.foldl (fun table -> fun (idx, isec) -> 
        let (_, t) = String_table.insert_string isec.elf64_section_name_as_string table in t
    ) String_table.empty section_tags_bare
    in
    let shstrtab = List.foldl (fun table -> (fun str -> 
        let (_, t) = String_table.insert_string str table in t
    )) basic_shstrtab [".shstrtab"; ".symtab"; ".strtab"]
    in
        (* what do we generate? 
         * .eh_frame? no, *should* come from the script
         * .got, .got.plt? HMM. These should have been created,
         * as ABI features, by the time we get here.
         * .comment -- maybe
         * .shstrtab -- YES
         * .symtab -- YES
         * .strtab -- YES.
         * 
         * Do we generate them as elements in the image, or just
         * use them to write the ELF file? The latter.
         *)
    let (symbol_tags, symbol_ranges) = elf_memory_image_symbol_def_ranges img
    in
    let all_sym_names = List.map (fun tag -> 
        match tag with 
            SymbolDef(sd) -> sd.def_symname
            | _ -> "not symbol tag, in symbol tags"
        end
    ) symbol_tags
    in
    let strtab = List.foldl (fun table -> fun str -> 
        let (_, t) = String_table.insert_string str table in t
    ) basic_shstrtab all_sym_names
    in
    let symtab = 
        (* Get all the symbols *)
        elf64_null_symbol_table_entry :: [
            match tag with 
                SymbolDef(d) -> d.def_syment
                    (* CHECK: can we expect these to be these usable, the way we generated them?  *)
                (* FIXME: do we ever get symbolrefs? *)
                | _ -> failwith "not a symbol tag, in symbol_tags"
            end
            | forall (tag MEM symbol_tags)
            | true
        ]
    in
    let element_section_tag_pairs_sorted_by_address = (* List.stable_sort *) Sorting.sortByOrd
        (fun ((idx1, isec1), (el1, range1)) -> (fun ((idx2, isec2), (el2, range2)) -> (
            compare isec1.elf64_section_addr isec2.elf64_section_addr
        ))) 
    (zip section_tags_bare section_ranges)
    in
    let _ = errln ("Building an ELF file from " ^ (show (length element_section_tag_pairs_sorted_by_address)) ^ " sections")
    in
    let sorted_sections_and_indices = List.map (fun ((idx, isec), (el, range)) -> (idx, isec))
        element_section_tag_pairs_sorted_by_address
    in
    let phoff = 64
    in
    (* PROBLEM: 
     * sections' offset assignments depend on phnum.
     * BUT
     * phnum depends on sections' offset assignments!
     * How do we break this cycle?
     * We can get an upper bound on the number of phdrs, then 
     * fill them in later.
     *)
    let max_phnum = (* length phdrs *) a.max_phnum
    in
    (* How does the GNU BFD output a statically linked executable? 
     * First the ELF header,
     * then program headers,
     * then sections in order of address:
     *      .interp,                 these are all allocatable sections! with addresses!
     * then .note.ABI-tag, 
     * then .note.gnu.build-id,
     * then .gnu.hash,
     * then .dynsym,
     * then .dynstr,
     * then .gnu.version,
     * then .gnu.version_r,
     * then ...
     * 
     * ... and so on ...
     * 
     * then .gnu.debuglink (the only non-allocatable section)
     * then .shstrtab, then SHT. 
     * 
     * So how can we calculate the offset of the SHT?  We have to place
     * all the other sections first. 
     *)
    let filesz = fun el -> fun isec -> 
        (* How can we distinguish progbits from nobits? 
         * A section can be nobits if its representation
         * is all zero or don't-care. But in practice we
         * don't make a section nobits unless its name is .bss. *)
        if (* is_all_zeroes_or_dont_care *) true &&
            isec.elf64_section_name_as_string = ".bss" then 0
            else match el.length with
                Nothing -> failwith "error: concrete section element has no length"
                | Just len -> len
            end
    in
    let (foldfn : (natural * (list natural)) -> ((natural * elf64_interpreted_section) * element_range) -> (natural * (list natural)))
     = (fun (current_off, offs_so_far) -> (fun ((idx, isec), (el_name, el_range)) -> 
        (* where can we place this in the file?
         * it's the next offset that's congruent to the section addr, 
         * modulo the biggest page size. *)
        let el = match Map.lookup el_name img.elements with 
            Just e -> e
            | Nothing -> failwith "nonexistent element"
        end
        in
        let (start_off : natural) =  match el.startpos with
            Just addr -> let this_remainder = current_off mod a.maxpagesize
                in
                let target_remainder = addr mod a.maxpagesize
                in
                current_off + (if target_remainder >= this_remainder then (target_remainder - this_remainder)
                       else (target_remainder + a.maxpagesize + this_remainder))
            | Nothing -> 
                (* It has no assigned address. That's okay if it's not allocatable. 
                 * If it's not allocatable, it has no alignment. *)
                if flag_is_set shf_alloc isec.elf64_section_flags then (failwith "allocatable section with no address")
                else current_off (* FIXME: is alignment important in file-offset-space? *)
        end
        in
        let end_off = start_off + (filesz el isec)
        in 
        (end_off, offs_so_far ++ [start_off])
    ))
    in
    let (last_off, section_file_offsets) = List.foldl foldfn  ((phoff + (max_phnum * 56)), []) element_section_tag_pairs_sorted_by_address
    in
    let last_off = (match index ((length section_file_offsets) - 1) section_file_offsets with
        Just offs -> offs
        | Nothing -> failwith "impossible: not enough section offsets assigned"
    end) + (match (index ((length section_file_offsets) - 1) sorted_sections_and_indices) with
        Just (_, isec) -> isec.elf64_section_size
        | Nothing -> failwith "error: section list too short"
    end)
    in
    let sorted_sections_with_offsets_and_indices = [
          (idx, <| elf64_section_name = x.elf64_section_name
           ; elf64_section_type = x.elf64_section_type
           ; elf64_section_flags = x.elf64_section_flags
           ; elf64_section_addr = x.elf64_section_addr
           ; elf64_section_offset = off
           ; elf64_section_size = x.elf64_section_size
           ; elf64_section_link = x.elf64_section_link
           ; elf64_section_info = x.elf64_section_info
           ; elf64_section_align = x.elf64_section_align
           ; elf64_section_entsize = x.elf64_section_entsize
           ; elf64_section_body = x.elf64_section_body
           ; elf64_section_name_as_string = x.elf64_section_name_as_string
           |>)
        | forall (((idx, x), off) MEM (zip sorted_sections_and_indices section_file_offsets))
        | true]
    in
    let phdrs = a.make_phdrs a elf_ft_exec img sorted_sections_with_offsets_and_indices
    in
    let shstrndx = 1 + length section_tags
    in
    let shoff = align_up_to 64 last_off
    in
    let (entry : natural) = match Multimap.lookupBy Memory_image_orderings.tagEquiv (EntryPoint) img.by_tag with
        [(_, maybe_el_range)] ->
            match maybe_el_range with
                Just (el_name, (start, len)) -> 
                    address_of_range (el_name, (start, len)) img
                | Nothing -> failwith "entry point defined without a range"
            end
       | [] -> failwith "no entry point defined"
       | _ -> failwith "multiple entry points defined"
    end
    in
    let shnum = 1 + length sorted_sections_with_offsets_and_indices
    in
    <| elf64_file_header               = a.make_elf_header elf_ft_exec entry shoff phoff (length phdrs) shnum shstrndx
     ; elf64_file_program_header_table = phdrs
     ; elf64_file_section_header_table = elf64_null_section_header :: (List.mapi (fun i -> fun ((el, isec), off) -> 
          <| elf64_sh_name      = match String_table.find_string isec.elf64_section_name_as_string shstrtab with
                                    Just n -> elf64_word_of_natural n
                                    | Nothing -> failwith "internal error: section name not in shstrtab"
                                end
           ; elf64_sh_type      = elf64_word_of_natural isec.elf64_section_type
           ; elf64_sh_flags     = elf64_xword_of_natural isec.elf64_section_flags
           ; elf64_sh_addr      = elf64_addr_of_natural isec.elf64_section_addr
           ; elf64_sh_offset    = elf64_off_of_natural off
           ; elf64_sh_size      = elf64_xword_of_natural isec.elf64_section_size
           ; elf64_sh_link      = elf64_word_of_natural isec.elf64_section_link
           ; elf64_sh_info      = elf64_word_of_natural isec.elf64_section_info
           ; elf64_sh_addralign = elf64_xword_of_natural isec.elf64_section_align
           ; elf64_sh_entsize   = elf64_xword_of_natural isec.elf64_section_entsize
           |>
     )) (zip section_tags_bare section_file_offsets)
     ; elf64_file_interpreted_segments = [
     
            (* do we need to build this? *)
            
        ]
     ; elf64_file_interpreted_sections = null_elf64_interpreted_section :: (List.mapi (fun i -> (fun ((el, isec), off) -> isec
     )) (zip section_tags_bare section_file_offsets))
     ; elf64_file_bits_and_bobs        = []
     |>
