open import Basic_classes
open import Bool
open import List
open import Maybe
open import Num
open import String
open import Assert_extra
open import Show
open import Sorting

open import {isabelle} `$ISABELLE_HOME/src/HOL/Word/Word`
open import {isabelle} `Elf_Types_Local`

val id : forall 'a. 'a -> 'a
let id x = x

type byte

declare ocaml    target_rep type byte = `char`
declare isabelle target_rep type byte = `8` `word`
val natural_of_byte : byte -> natural

declare ocaml    target_rep function natural_of_byte x = `Nat_big_num.of_int` (`Char.code` x)
declare isabelle target_rep function natural_of_byte = `unat`

val char_of_byte : byte -> char

declare ocaml    target_rep function char_of_byte x = ``x
declare isabelle target_rep function char_of_byte = `Elf_Types_Local.char_of_unsigned_char`

(* Define how to print a byte in hex *)
val hex_char_of_nibble : natural -> char
let hex_char_of_nibble n =
    match n with
            0 -> #'0'
        |   1 -> #'1'
        |   2 -> #'2' 
        |   3 -> #'3' 
        |   4 -> #'4'
        |   5 -> #'5' 
        |   6 -> #'6' 
        |   7 -> #'7' 
        |   8 -> #'8' 
        |   9 -> #'9' 
        |   10 -> #'a'
        |   11 -> #'b' 
        |   12 -> #'c' 
        |   13 -> #'d' 
        |   14 -> #'e' 
        |   15 -> #'f'
    end

let hex_string_of_byte b = 
    toString [ hex_char_of_nibble ((natural_of_byte b) / 16)
             ; hex_char_of_nibble ((natural_of_byte b) mod 16)]

instance (Show byte)
    let show = hex_string_of_byte
end

val natural_of_decimal_digit : char -> maybe natural
let natural_of_decimal_digit c = 
    match c with
          #'0' -> Just 0
        | #'1' -> Just 1
        | #'2' -> Just 2
        | #'3' -> Just 3
        | #'4' -> Just 4
        | #'5' -> Just 5
        | #'6' -> Just 6
        | #'7' -> Just 7
        | #'8' -> Just 8
        | #'9' -> Just 9
        | _ -> Nothing
    end

val natural_of_decimal_string_helper : natural -> list char -> natural
let rec natural_of_decimal_string_helper acc chars =
    match chars with 
        [] -> acc
        | c :: cs -> match natural_of_decimal_digit c with
            Just dig -> natural_of_decimal_string_helper ((10 * acc) + dig) cs
            | Nothing -> acc
        end
    end

val natural_of_decimal_string : string -> natural
let natural_of_decimal_string s = 
    natural_of_decimal_string_helper 0 (toCharList s)

val hex_string_of_natural : natural -> string
let rec hex_string_of_natural n = 
    if n <= 16 then toString [hex_char_of_nibble n]
    else (hex_string_of_natural (n / 16)) ^ (toString [hex_char_of_nibble (n mod 16)])

val natural_of_bool : bool -> natural
let natural_of_bool b =
  match b with
    | true  -> 1
    | false -> 0
  end

val unsafe_nat_of_natural : natural -> nat

declare ocaml    target_rep function unsafe_nat_of_natural = `Nat_big_num.to_int`
declare isabelle target_rep function unsafe_nat_of_natural = `id`

val unsafe_int_of_natural   : natural -> int

declare ocaml    target_rep function unsafe_int_of_natural = `Nat_big_num.to_int`
declare isabelle target_rep function unsafe_int_of_natural = `int`

val byte_of_natural : natural -> byte

declare ocaml    target_rep function byte_of_natural x = `Char.chr` (`Nat_big_num.to_int` x)
declare isabelle target_rep function byte_of_natural = `unat`

type ordering
  = Equal
  | Less
  | Greater

declare ocaml    target_rep type ordering = `int`
declare isabelle target_rep type ordering = `Elf_Types_Local.ordering`

val natural_ordering : natural -> natural -> ordering
let natural_ordering left right =
  if left = right then
    Equal
  else if left < right then
    Less
  else
    Greater

declare ocaml target_rep function natural_ordering = `Nat_big_num.compare`

val sort_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a

declare ocaml    target_rep function sort_by = `List.sort`
declare isabelle target_rep function sort_by = `Elf_Types_Local.merge_sort`

(** [intercalate sep xs] places [sep] between all elements of [xs]. *)
val intercalate : forall 'a. 'a -> list 'a -> list 'a
let rec intercalate sep xs =
	match xs with
		| []    -> []
		| [x]   -> [x]
		| x::xs -> x::sep::intercalate sep xs
	end

(** [string_of_list l] produces a string representation of list [l].
  *)
val string_of_list : forall 'a. Show 'a => list 'a -> string
let {ocaml} string_of_list l =
  let result = intercalate "," (List.map show l) in
  let folded = foldl (^) "" result in
    "[" ^ folded ^ "]"

instance forall 'a. Show 'a => (Show (list 'a))
	let show = string_of_list
end

(** [mapMaybei f xs] maps a function expecting an index (the position in the list
  * [xs] that it is currently viewing) and producing a [maybe] type across a list.
  * Elements that produce [Nothing] under [f] are discarded in the output, whilst
  * those producing [Just e] for some [e] are kept.
  *)
val mapMaybei' : forall 'a 'b. (natural -> 'a -> maybe 'b) -> natural -> list 'a -> list 'b
let rec mapMaybei' f idx xs =
  match xs with
  | []    -> []
  | x::xs ->
      match f idx x with
      | Nothing -> mapMaybei' f (1 + idx) xs
      | Just e  -> e :: mapMaybei' f (1 + idx) xs
      end
  end

val mapMaybei : forall 'a 'b. (natural -> 'a -> maybe 'b) -> list 'a -> list 'b
    
let mapMaybei f xs =
  mapMaybei' f 0 xs

(** [partitionii is xs] returns a pair of lists: firstly those elements in [xs] that are
    at indices in [is], and secondly the remaining elements. 
    It preserves the order of elements in xs. *)
val partitionii' : forall 'a. natural -> list natural -> list 'a 
    -> list (natural * 'a) (* accumulates the 'in' partition *)
    -> list (natural * 'a) (* accumulates the 'out' partition *)
    -> (list (natural * 'a) * list (natural * 'a))
let rec partitionii' (offset : natural) sorted_is xs reverse_accum reverse_accum_compl = 
    (* offset o means "xs begins at index o, as reckoned by the indices in sorted_is" *)
    match sorted_is with
        [] -> (List.reverse reverse_accum, List.reverse reverse_accum_compl)
        | i :: more_is -> 
            let (length_to_split_off : nat) = (natFromNatural (i - offset))
            in
            let (left, right) = List.splitAt length_to_split_off xs in
            let left_indices : list natural = List.genlist 
                (fun j -> (naturalFromNat j) + offset)
                (List.length left) 
            in
            let left_with_indices = zip left_indices left in
            (* left begins at offset, right begins at offset + i *)
            match right with 
                [] -> (* We got to the end of the list before the target index. *) 
                    (List.reverse reverse_accum, 
                     List.reverseAppend reverse_accum_compl left_with_indices)
                | x :: more_xs -> 
                    (* x is at index i by definition, so more_xs starts with index i + 1 *)
                    partitionii' (i+1) more_is more_xs ((i, x) :: reverse_accum) 
                        (List.reverseAppend left_with_indices reverse_accum_compl)
            end
    end

val filteri : forall 'a. list natural -> list 'a -> list 'a
let filteri is xs = 
    let sorted_is = sort is in
    let (accum, accum_compl) = partitionii' 0 sorted_is xs [] []
    in 
    let (just_indices, just_items) = unzip accum
    in 
    just_items

val filterii : forall 'a. list natural -> list 'a -> list (natural * 'a)
let filterii is xs = 
    let sorted_is = Sorting.sort is in
    let (accum, accum_compl) = partitionii' 0 sorted_is xs [] []
    in 
    accum

val partitioni : forall 'a. list natural -> list 'a -> (list 'a * list 'a)
let partitioni is xs = 
    let sorted_is = Sorting.sort is in
    let (accum, accum_compl) = partitionii' 0 sorted_is xs [] []
    in
    let (just_indices, just_items) = unzip accum
    in
    let (just_indices_compl, just_items_compl) = unzip accum_compl
    in
    (just_items, just_items_compl)

val partitionii : forall 'a. list natural -> list 'a -> (list (natural * 'a) * list (natural * 'a))
let partitionii is xs = 
    let sorted_is = Sorting.sort is in
    partitionii' 0 sorted_is xs [] []

(** [unzip3 ls] takes a list of triples and returns a triple of lists. *)
val unzip3: forall 'a 'b 'c. list ('a * 'b * 'c) -> (list 'a * list 'b * list 'c)
let rec unzip3 l = match l with
  | [] -> ([], [], [])
  | (x, y, z) :: xyzs -> let (xs, ys, zs) = unzip3 xyzs in (x :: xs, y :: ys, z :: zs)
end
declare termination_argument unzip3 = automatic

(** [unlines xs] concatenates a list of strings [xs], placing each entry
  * on a new line.
  *)
val unlines : list string -> string
let unlines xs =
  foldl (^) "" (intercalate "\n" xs)

(** [bracket xs] concatenates a list of strings [xs], separating each entry with a
  * space, and bracketing the resulting string.
  *)
val bracket : list string -> string
let bracket xs =
  "(" ^ foldl (^) "" (intercalate " " xs) ^ ")"

(** [null_char] is the null character. *)
val null_char : byte

declare ocaml    target_rep function null_char = `'\000'`
declare isabelle target_rep function null_char = `0` `::` `8` `word`

(** [split_string_on_char s c] splits a string [s] into a list of substrings
  * on character [c], otherwise returning the singleton list containing [s]
  * if [c] is not found in [s].
  *)
val split_string_on_char : string -> char -> list string

declare ocaml target_rep function split_string_on_char = `Ml_bindings.split_string_on_char`
declare isabelle target_rep function split_string_on_char = `Elf_Types_Local.split_string_on_char`

(** [println s] prints [s] to stdout, adding a trailing newline. *)
val println : string -> unit
declare ocaml target_rep function println = `print_endline`

(** [prints s] prints [s] to stdout, without adding a trailing newline. *)
val prints : string -> unit
declare ocaml target_rep function prints = `print_string`

(** [string_of_nat m] produces a string representation of natural number [m]. *)
val string_of_nat : nat -> string
declare ocaml target_rep function string_of_nat = `string_of_int`

(** [string_suffix i s] chops [i] characters off [s], returning a new string.
  * Fails if the index is negative, or beyond the end of the string.
  *)
val string_suffix : natural -> string -> maybe string

declare ocaml target_rep function string_suffix = `Ml_bindings.string_suffix`
declare isabelle target_rep function string_suffix = `Elf_Types_Local.string_suffix`

val index : forall 'a. natural -> list 'a -> maybe 'a

declare ocaml    target_rep function index      = `Ml_bindings.list_index_big_int`
declare isabelle target_rep function index i xs = `Elf_Types_Local.index` xs i

val find_index_helper : forall 'a. natural -> ('a -> bool) -> list 'a -> maybe natural
let rec find_index_helper count p xs =
	match xs with
		| []    -> Nothing
		| y::ys ->
			if p y then
				Just count
			else
				find_index_helper (count + 1) p ys
	end

val find_index : forall 'a. ('a -> bool) -> list 'a -> maybe natural
let find_index p xs = find_index_helper 0 p xs

val length : forall 'a. list 'a -> natural
let ~{ocaml} length xs = List.foldl (fun y _ -> 1 + y) 0 xs

val nat_length : forall 'a. list 'a -> nat
declare ocaml target_rep function nat_length = `List.length`

let {ocaml} length xs = naturalFromNat (nat_length xs)

val argv : list string
declare ocaml target_rep function argv = `Ml_bindings.argv_list`

declare isabelle target_rep function length = `List.length`

val replicate : forall 'a. natural -> 'a -> list 'a
let rec replicate len e =
	match len with
		| 0 -> []
		| m -> e :: replicate (m - 1) e
	end

declare isabelle target_rep function replicate = `List.replicate`

(* We want a tail-recursive append. reverse_append l1 l2 appends l2 to the
 * reverse of l1. So we get [l1-backwards] [l2]. So just reverse l1. *)
val list_append : forall 'a. list 'a -> list 'a -> list 'a
let list_append l1 l2 =
    List.reverseAppend (List.reverse l1) l2

val list_concat : forall 'a. list (list 'a) -> list 'a 
let list_concat ll = foldl list_append [] ll

val list_concat_map : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b
let list_concat_map f l = 
    list_concat (List.map f l)

val list_reverse_concat_map_helper : forall 'a 'b. ('a -> list 'b) -> list 'b -> list 'a -> list 'b
let rec list_reverse_concat_map_helper f acc ll = 
    let lcons = (fun l -> (fun i -> i :: l))
    in
    match ll with
      | []      -> acc
      | item :: items -> 
            (* item is a thing that maps to a list. it needn't be a list yet *)
            let mapped_list = f item
            in 
            (* let _ = Missing_pervasives.println ("Map function gave us a list of " ^ (show (List.length mapped_list)) ^ " items") in *)
            list_reverse_concat_map_helper f (List.foldl lcons acc (f item)) items
    end

val list_reverse_concat_map : forall 'a 'b. ('a -> list 'b) -> list 'a -> list 'b
let list_reverse_concat_map f ll = list_reverse_concat_map_helper f [] ll

val list_take_with_accum : forall 'a. nat -> list 'a -> list 'a -> list 'a
let rec list_take_with_accum n reverse_acc l =
  (*  let _ = Missing_pervasives.prints ("Taking a byte; have accumulated " ^ (show (List.length acc) ^ " so far\n"))
   in *)
   match n with
        0 -> List.reverse reverse_acc
      | _ -> match l with
            [] -> failwith "list_take_with_accum: not enough elements"
            | x :: xs -> list_take_with_accum (n-1) (x :: reverse_acc) xs
        end
    end

val unsafe_string_take : natural -> string -> string
let unsafe_string_take m str =
  let m = unsafe_nat_of_natural m in
    String.toString (List.take m (String.toCharList str))
