open import Basic_classes
open import Bool
open import List
open import Maybe
open import Num
open import String

open import {isabelle} `$ISABELLE_HOME/src/HOL/Word/Word`
open import {isabelle} `Elf_Types_Local`

type byte

declare ocaml    target_rep type byte = `char`
declare isabelle target_rep type byte = `8` `word`

val char_of_byte : byte -> char

declare ocaml    target_rep function char_of_byte = ``
declare isabelle target_rep function char_of_byte = `Elf_Types_Local.char_of_unsigned_char`

val natural_of_bool : bool -> natural
let natural_of_bool b =
  match b with
    | true  -> 1
    | false -> 0
  end

val unsafe_nat_of_natural : natural -> nat

declare ocaml    target_rep function unsafe_nat_of_natural = `Big_int.int_of_big_int`
declare isabelle target_rep function unsafe_nat_of_natural = `id`

val unsafe_int_of_natural   : natural -> int

declare ocaml    target_rep function unsafe_int_of_natural = `Big_int.int_of_big_int`
declare isabelle target_rep function unsafe_int_of_natural = `int`

val byte_of_natural : natural -> byte

declare ocaml    target_rep function byte_of_natural = `Ml_bindings.char_of_bigint`
declare isabelle target_rep function byte_of_natural = `unat`

type ordering
  = Equal
  | Less
  | Greater

declare ocaml    target_rep type ordering = `int`
declare isabelle target_rep type ordering = `Elf_Types_Local.ordering`

val natural_ordering : natural -> natural -> ordering
let natural_ordering left right =
  if left = right then
    Equal
  else if left < right then
    Less
  else
    Greater

declare ocaml target_rep function natural_ordering = `Big_int.compare_big_int`

val sort_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a

declare ocaml    target_rep function sort_by = `List.sort`
declare isabelle target_rep function sort_by = `Elf_Types_Local.merge_sort`

(** [intercalate sep xs] places [sep] between all elements of [xs]. *)
val intercalate : forall 'a. 'a -> list 'a -> list 'a
let rec intercalate sep xs =
	match xs with
		| []    -> []
		| [x]   -> [x]
		| x::xs -> x::sep::intercalate sep xs
	end

(** [mapMaybei f xs] maps a function expecting an index (the position in the list
  * [xs] that it is currently viewing) and producing a [maybe] type across a list.
  * Elements that produce [Nothing] under [f] are discarded in the output, whilst
  * those producing [Just e] for some [e] are kept.
  *)
val mapMaybei' : forall 'a 'b. (natural -> 'a -> maybe 'b) -> natural -> list 'a -> list 'b
let rec mapMaybei' f idx xs =
  match xs with
  | []    -> []
  | x::xs ->
      match f idx x with
      | Nothing -> mapMaybei' f (1 + idx) xs
      | Just e  -> e :: mapMaybei' f (1 + idx) xs
      end
  end

val mapMaybei : forall 'a 'b. (natural -> 'a -> maybe 'b) -> list 'a -> list 'b
    
let mapMaybei f xs =
  mapMaybei' f 0 xs

(** [unlines xs] concatenates a list of strings [xs], placing each entry
  * on a new line.
  *)
val unlines : list string -> string
let unlines xs =
  foldr (^) "" (intercalate "\n" xs)

(** [bracket xs] concatenates a list of strings [xs], separating each entry with a
  * space, and bracketing the resulting string.
  *)
val bracket : list string -> string
let bracket xs =
  "(" ^ foldr (^) "" (intercalate " " xs) ^ ")"

(** [null_char] is the null character. *)
val null_char : byte

declare ocaml    target_rep function null_char = `'\000'`
declare isabelle target_rep function null_char = `0` `::` `8` `word`

(** [split_string_on_char s c] splits a string [s] into a list of substrings
  * on character [c], otherwise returning the singleton list containing [s]
  * if [c] is not found in [s].
  *)
val split_string_on_char : string -> char -> list string

declare ocaml target_rep function split_string_on_char = `Ml_bindings.split_string_on_char`
declare isabelle target_rep function split_string_on_char = `Elf_Types_Local.split_string_on_char`

(** [println s] prints [s] to stdout, adding a trailing newline. *)
val println : string -> unit
declare ocaml target_rep function println = `print_endline`

(** [prints s] prints [s] to stdout, without adding a trailing newline. *)
val prints : string -> unit
declare ocaml target_rep function prints = `print_string`

(** [string_of_nat m] produces a string representation of natural number [m]. *)
val string_of_nat : nat -> string
declare ocaml target_rep function string_of_nat = `string_of_int`

(** [string_suffix i s] chops [i] characters off [s], returning a new string.
  * Fails if the index is negative, or beyond the end of the string.
  *)
val string_suffix : natural -> string -> maybe string

declare ocaml target_rep function string_suffix = `Ml_bindings.string_suffix`
declare isabelle target_rep function string_suffix = `Elf_Types_Local.string_suffix`

val index : forall 'a. natural -> list 'a -> maybe 'a

declare ocaml    target_rep function index      = `Ml_bindings.list_index_big_int`
declare isabelle target_rep function index i xs = `Elf_Types_Local.index` xs i

val find_index_helper : forall 'a. natural -> ('a -> bool) -> list 'a -> maybe natural
let rec find_index_helper count p xs =
	match xs with
		| []    -> Nothing
		| y::ys ->
			if p y then
				Just count
			else
				find_index_helper (count + 1) p ys
	end

val find_index : forall 'a. ('a -> bool) -> list 'a -> maybe natural
let find_index p xs = find_index_helper 0 p xs

val length : forall 'a. list 'a -> natural
let ~{ocaml} length xs = List.foldr (fun _ y -> 1 + y) 0 xs

val nat_length : forall 'a. list 'a -> nat
declare ocaml target_rep function nat_length = `List.length`

let {ocaml} length xs = naturalFromNat (nat_length xs)

declare isabelle target_rep function length = `List.length`

val replicate : forall 'a. natural -> 'a -> list 'a
let rec replicate len e =
	match len with
		| 0 -> []
		| m -> e :: replicate (m - 1) e
	end

declare isabelle target_rep function replicate = `List.replicate`
