open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show

open import Elf_header
open import Elf_file
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_types_native_uint
open import Elf_relocation
open import Endianness

open import Abstract_abi
open import Abi_amd64_elf_header
open import Abi_amd64_serialisation

open import Command_line
open import Input_list

let default_hdr_bdl =
  (default_os_specific_print, default_proc_specific_print)

let default_pht_bdl =
  (default_os_specific_print, default_proc_specific_print)

let default_sht_bdl =
  (default_os_specific_print, default_proc_specific_print, default_user_specific_print)

val segment_load_ranges : elf64_interpreted_segments -> list (natural * natural)
let segment_load_ranges es = 
    let get_range : elf64_interpreted_segment -> list (natural * natural) = (
        fun x -> if x.elf64_segment_type = elf_pt_load 
            then [(x.elf64_segment_base, x.elf64_segment_base + x.elf64_segment_memsz)] 
            else []
    )
    in
    foldl (++) [] (List.map get_range es) 

val range_contains : (natural * natural) -> (natural * natural) -> bool
let range_contains (r1begin, r1end) (r2begin, r2end) = 
    (* r1 is at least as big as r2 *)
    r2begin >= r1begin && r2end <= r1end

val range_overlaps : (natural * natural) -> (natural * natural) -> bool
let range_overlaps (r1begin, r1end) (r2begin, r2end) =
    (r1begin < r2end && r1end > r2begin) || (r2begin < r1end && r2end > r1begin)
    
val is_partition : list (natural * natural) -> list (natural * natural) -> bool
let is_partition rs ranges = 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    let r_is_contained_by_some_range
     = fun r -> foldl (||) false (List.map (fun range -> range_contains range r) ranges)
    in
    all (fun r -> r_is_contained_by_some_range r) rs
    &&
    (* 2. elements of the first list do not overlap *)
    all (fun r -> all (fun r2 -> (r = (* should be "=="? *) r2) || (not (range_overlaps r r2))) rs) rs

val range_models_section : elf64_interpreted_section -> natural -> natural -> bool
let range_models_section s base len = 
    true

val     nat_range : natural -> natural -> list natural
let rec nat_range base len =
    match len with 
        0 -> []
    |   _ -> base :: (nat_range (base + 1) (len - 1))
    end

(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
val expand_ranges : list (natural * natural) -> list bool -> list bool
let rec expand_ranges sorted_ranges accum =
    match sorted_ranges with
        [] -> accum
     |  (base, len) :: more -> 
            (* pad the accum so that it reaches up to base *)
            let up_to_base = (Missing_pervasives.replicate (base - (Missing_pervasives.length accum)) true)
            in
            let up_to_end_of_range = up_to_base ++ (Missing_pervasives.replicate len false)
            in
            expand_ranges more (accum ++ up_to_end_of_range)
    end

val make_byte_pattern : list byte -> list bool -> list (maybe byte)
let rec make_byte_pattern bytes dontcares = 
    match bytes with
          [] -> []
        | b :: bs -> match dontcares with 
                er :: more -> (if er then Just b else Nothing) :: (make_byte_pattern bs more)
              | _ -> failwith "make_byte_pattern: unequal length"
              end
    end

val section_as_byte_pattern : abi -> endianness -> elf64_interpreted_section -> elf64_interpreted_sections -> list (maybe byte)
let section_as_byte_pattern a endian s all_s =
    (* *)
    let maybeIndex = Missing_pervasives.find_index (fun el -> el = s) all_s
    in
    let index = match maybeIndex with 
        Just i -> i
        | _ -> failwith "section not in list of sections"
    end
    in
    let relss = [rels | forall (rels MEM all_s) | 
        rels.elf64_section_type = sht_rel && rels.elf64_section_info = index]
    in
    let relss_records = List.concatMap
        (fun rels -> match read_elf64_relocation_section rels.elf64_section_size endian rels.elf64_section_body with
            Fail _ -> failwith "reading rels"
            | Success (recs, rest) -> recs
        end)
        relss
    in
    let relass = [relas | forall (relas MEM all_s) | 
        relas.elf64_section_type = sht_rela && relas.elf64_section_info = index]
    in
    let relass_records = List.concatMap 
        (fun relas -> match read_elf64_relocation_a_section relas.elf64_section_size endian relas.elf64_section_body with
            Fail _ -> failwith "reading relas"
            | Success (recs, rest) -> recs
        end)
        relass
    in
    (* Now we have all the relocation sections; turn them into lists of relocated ranges. *)
    let rel_ranges : list (natural * natural)
     = let width_of_relocation = fun r -> let (width, f) = a.reloc (elf64_relocation_r_type r.elf64_r_info) in width
     in List.map (fun r -> (natural_of_elf64_addr r.elf64_r_offset, (width_of_relocation r))) relss_records
    in
    let rela_ranges : list (natural * natural)
     = let width_of_relocation_a = fun ra -> let (width, f) = a.reloc (elf64_relocation_r_type ra.elf64_ra_info) in width
     in List.map (fun r -> (natural_of_elf64_addr r.elf64_ra_offset, (width_of_relocation_a r))) relass_records
    in
    let ranges = rel_ranges ++ rela_ranges
    in
    let sorted_ranges = sortBy (fun (base1, len1) -> (fun (base2, len2) -> base1 < base2)) ranges
    in
    let expanded_ranges_short = expand_ranges sorted_ranges []
    in
    let expanded_ranges = append expanded_ranges_short (Missing_pervasives.replicate (s.elf64_section_size - (Missing_pervasives.length expanded_ranges_short)) true)
    in
    let s_bytes = match s.elf64_section_body with Sequence(bs) -> bs end
    in
    let byte_pattern = make_byte_pattern s_bytes expanded_ranges
    in
    let _ = Missing_pervasives.prints ("Section name-number " ^ (show s.elf64_section_name) ^ " has byte-pattern of length " ^ (show (Missing_pervasives.length byte_pattern)) ^ "\n") in
    byte_pattern

val byte_option_matches_byte : maybe byte -> byte -> bool
let byte_option_matches_byte optb b =
    match optb with 
            Nothing -> true 
        |   Just some -> some = b 
    end

val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool
let rec byte_list_matches_pattern pattern bytes = 
    match pattern with 
        [] -> true
        | optbyte :: more -> match bytes with 
                [] -> false
                | abyte :: morebytes -> 
                    byte_option_matches_byte optbyte abyte 
                 && byte_list_matches_pattern more morebytes
            end
    end
    
val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural
let rec accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum =
    let _ = Missing_pervasives.prints ("At offset " ^ (show offset) ^ "... ")
    in
    match pattern with
        [] -> let _ = Missing_pervasives.prints ("terminating with hit (empty pattern)\n") in offset :: accum
        | byte_pattern :: more_byte_patterns -> (* nonempty, so check for nonempty seq *)
            match seq with 
                [] -> let _ = Missing_pervasives.prints ("terminating with miss (empty pattern)\n") 
                    in accum (* ran out of bytes in the sequence, so no match *)
                | byte :: more_bytes -> let matched_this_byte = 
                            byte_option_matches_byte byte_pattern byte
                       in
                       let _ = Missing_pervasives.prints ("Byte " ^ (show byte) ^ " matched " ^ (show byte_pattern) ^ "? " ^ (show matched_this_byte) ^ "; ") 
                       in
                       let sequence_long_enough = (seq_len >= pattern_len) 
                       in
                       let _ = Missing_pervasives.prints ("enough bytes remaining (" ^ (show seq_len) ^ ") to match rest of pattern (" ^ (show pattern_len) ^ ")? " ^ (show sequence_long_enough) ^ "; ") 
                       in
                       let matched_here = matched_this_byte && sequence_long_enough &&
                        byte_list_matches_pattern more_byte_patterns more_bytes
                       in
                       let _ = Missing_pervasives.prints ("matched pattern anchored here? " ^ (show matched_this_byte) ^ "\n") 
                       in
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len - 1) 
                           (offset + 1) 
                           (if matched_here then offset :: accum else accum)
            end
    end

val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural
let pattern_possible_starts_in_one_byte_sequence pattern seq offset =
    let _ = Missing_pervasives.prints ("Looking for matches of " ^
        (show (List.length pattern)) ^ "-byte pattern in " ^ (show (List.length seq)) ^ "-byte region\n")
    in
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset []

val pattern_possible_starts_in_one_load_phdr : list (maybe byte) -> elf64_interpreted_segment -> natural -> list natural
let pattern_possible_starts_in_one_load_phdr pattern seg offset =
    match seg.elf64_segment_body with 
        Sequence(bytes) ->
            let ret = pattern_possible_starts_in_one_byte_sequence pattern bytes 0
            in  
            let _ = Missing_pervasives.prints 
                ("Pattern of length " ^ (show (Missing_pervasives.length pattern)) 
                ^ " (" ^ (show pattern) ^ ")"
                ^ " matched byte sequence " ^ (if List.length bytes < 200000 then (show bytes) else "(very long list)")
                ^ " in " ^ (show (Missing_pervasives.length ret)) ^ " ways: "
                ^ (show ret) ^ "\n") in
            ret
    end

val pattern_possible_starts_in_load_phdrs : list (maybe byte) -> elf64_file -> list natural
let pattern_possible_starts_in_load_phdrs pattern f =
    (* for each virtual address in a segment, evaluate whether
       it might be a representation of our pattern *)
    let get_starts = fun seg -> pattern_possible_starts_in_one_load_phdr pattern seg 0
    in 
    let load_segs = List.filter (fun seg -> seg.elf64_segment_type = elf_pt_load) f.elf64_file_interpreted_segments
    in
    let _ = Missing_pervasives.prints ("Output file has " ^ (show (Missing_pervasives.length load_segs)) 
        ^ " PT_LOAD segments\n")
    in
    (* only PT_LOAD segments are relevant *)
    let all_segs_starts = List.map get_starts load_segs
    in
    let seg_startlist_pairs = zip load_segs all_segs_starts
    in
    let _ = Missing_pervasives.println "Got to blah ss1" in
    let seg_start_pairs = [(seg, start) | forall ((seg, starts) MEM seg_startlist_pairs) (start MEM starts) | true ]
    in
    let _ = Missing_pervasives.println "Got to blah ss2" in
    let vaddr_starts = List.map (fun (seg, start) -> seg.elf64_segment_base + start) seg_start_pairs
    in
    vaddr_starts

val     all_global_assignments_accum
 : list ((elf64_interpreted_section * elf64_file) * list natural)
  -> list (list (elf64_interpreted_section * natural))
  -> list (list (elf64_interpreted_section * natural))
let rec all_global_assignments_accum s_and_ss accum =
    match s_and_ss with
        [] -> accum
    |   ((sec, f), starts) :: more -> 
            let all_assignments_for_sec = 
                [(sec, start) | forall (start MEM starts) | true]
            in
            (* for each global assignment so far, we make 
             * n new ones, as a list then flatten together *)
            let add_assignment
             = fun global_ass -> [(sec, start) :: global_ass | forall ((sec, start) MEM all_assignments_for_sec) | true]
            in
            let new_accum : list (list (elf64_interpreted_section * natural)) = 
                (* map from list to list of lists *)
                List.concatMap add_assignment accum
            in
            all_global_assignments_accum more new_accum
    end
 
val all_allocated_user_sections_in_load_phdrs : abi -> list elf64_file -> elf64_file -> bool
let all_allocated_user_sections_in_load_phdrs a efs out =
    (* There must exist a contiguous partitioning of the segments' memory space 
     * s.t. for each section, exactly one element of the partition models the segment
     * where "models" is defined in terms of file contents and relocation.
     * There *may* be elements of the partition unaccounted by any input section,
     * although the linker should not inject garbage randomly... tighten this down later.
     * 
     * The space of partitionings is very large in the presence of even a bit of 
     * padding. So don't enumerate that directly. Instead, for each section, look
     * for places where that section might start. Then enumerate the non-overlapping
     * assignments of sections to start addresses.
     * 
     * Instead, for each section, get its possible starting (seg, off) positions
     * then check that there exists a partition.
     *)
    let is_alloc : elf64_interpreted_section -> bool
     = (fun x -> (elf64_xword_land 
        (elf64_xword_of_natural x.elf64_section_flags) 
        (elf64_xword_of_natural shf_alloc))
         = (elf64_xword_of_natural shf_alloc))
    in
    let is_user : elf64_interpreted_section -> bool
     = (fun x -> x.elf64_section_type = sht_progbits
     || x.elf64_section_type = sht_nobits)
    in
    let is_alloc_and_user : elf64_interpreted_section -> bool 
     = (fun x -> (is_alloc x) && (is_user x))
    in
    let alloc_section_file_pairs
     = [    (section, f) 
            | forall (f MEM efs) (section MEM f.elf64_file_interpreted_sections)
            | is_alloc_and_user section
    ]
    in
    let _ = Missing_pervasives.println ("Inputs have a total of " ^ 
        (show (Missing_pervasives.length alloc_section_file_pairs)) ^ " allocatable user sections.")
    in
    (* FIXME: check (somewhere) that endianness is consistent across input files and outputs *)
    let endian = get_elf64_header_endianness (out.elf64_file_header)
    in
    (* We get a list with one element per alloc section. 
     * That element is a list of possible start vaddrs for that section. *) 
    let section_possible_seg_starts : list (list natural) = 
        List.map 
            (fun (sec, file) -> pattern_possible_starts_in_load_phdrs (section_as_byte_pattern a endian sec file.elf64_file_interpreted_sections) out) 
                alloc_section_file_pairs
    in
    let _ = Missing_pervasives.println ("Found the following" ^ 
        " content-matching ways to map input sections onto output segments: " ^ 
        (show section_possible_seg_starts))
    in
    let load_ranges = segment_load_ranges out.elf64_file_interpreted_segments
    in
    (* Make a list of all possible global assignments. 
     * A global assignment is a list of (sections, address) pairs
     * To enumerate all of them, 
     * we pick a (section, starts-list) pair from the head of the list, 
     * append all (section, start) pairs in that list to the assignments accumulated for earlier sections,
     * then recurse to accumulate further.
     *)
    let sections_and_possible_starts : list ((elf64_interpreted_section * elf64_file) * list natural)
     = zip alloc_section_file_pairs section_possible_seg_starts
    in
    let all_global_assignments : list (list (elf64_interpreted_section * natural))
     = all_global_assignments_accum sections_and_possible_starts [[]]
    in
    let _ = Missing_pervasives.prints ("Enumerated " ^ 
        (show (Missing_pervasives.length all_global_assignments)) ^ 
        " global assignments of input sections onto output vaddrs:\n")
    in
    let all_global_assignments_as_intervals : list (list (natural * natural)) = 
        List.map
        (fun assignment -> [(base, base + section.elf64_section_size) | forall ((section, base) MEM assignment) | true])
        all_global_assignments
    in
    let valid_assignments = List.filter (fun ass -> is_partition ass load_ranges) all_global_assignments_as_intervals
    in
    let _ = Missing_pervasives.prints ("Of these, " ^ 
        (show (Missing_pervasives.length valid_assignments)) ^ 
        " are valid partitionings\n")
    in
    (Missing_pervasives.length valid_assignments) > 0

val correctly_linked : abi -> input_list -> list link_option -> elf64_file -> bool
let correctly_linked a input_items options eout = 
    (* 0. TODO: well-formedness *) 
    (* 1. all allocatable input sections are in LOADed output segments *)
    let required_input_seqs = List.concatMap
        (fun (item, options) -> match item with 
            Reloc(seq, fname) -> 
                let _ = Missing_pervasives.println ("Adding reloc file " ^ fname) in
                if options.item_force_output then [seq] else 
                    let _ = Missing_pervasives.println 
                        ("Skipping object not required in output " ^ fname) 
                    in []
            | Shared(seq, fname) -> 
                let _ = Missing_pervasives.println ("Skipping shared object " ^ fname) in []
            | Script(seq, fname) -> 
                let _ = Missing_pervasives.println ("Skipping linker script " ^ fname) in []
        end) 
        input_items
    in
    let ef_of_seq = fun s -> match Elf_file.read_elf64_file s with
        Success(e) -> e
        | Fail(_) -> failwith "non-ELF or non-relocatable input file"
    end
    in
    let required_efs = List.map ef_of_seq required_input_seqs 
    in
    if is_elf64_executable_file eout.elf64_file_header 
        && (natural_of_elf64_half eout.elf64_file_header.elf64_phnum) * (natural_of_elf64_half eout.elf64_file_header.elf64_phentsize) > 0
        && List.all (fun x -> (natural_of_elf64_half x.elf64_file_header.elf64_shnum) * (natural_of_elf64_half x.elf64_file_header.elf64_shentsize) > 0) required_efs
        then all_allocated_user_sections_in_load_phdrs a required_efs eout
    else false

(* We need to elaborate the command line to handle objects, archives 
 * and archive groups appropriately. 
 * We could imagine a relation between objects such that 
 * (o1, o2) is in the relation
 * iff definitions in o1 might be used to satisfy references in o2. ("o1 supplies o2")
 * If o1 is a .o, all other .o files are searched.
 * If o1 comes from an archive and is not in a group, it only supplies *preceding* objects (whether from an archive or a .o).
 * If o1 comes from an archive in a group, it supplies preceding objects and any objects from the same group.
 * 
 * That doesn't capture the ordering, though: 
 * for each object, there's an ordered list of other objects 
 * in which to search for the *first* definition. *)

let _ =
  let res =
    let (input_files, options) = command_line ()
    in
    let (input_items, item_options) = unzip (elaborate_input input_files)
    in
    let _ = Missing_pervasives.println ("Got " ^ (show (List.length input_items)) ^ " input items: {"
        ^ (List.foldl (^) "" (List.map (fun item -> (show item) ^ ",") input_items)) ^ "}")
    in
    let output_file_options
     = filter (fun el -> match el with OutputFilename(s) -> true | _ -> false end) options
    in
    let output_file = match output_file_options with
        [] -> failwith "impossible: no output file specified, despite default value of `a.out'"
        | [OutputFilename(s)] -> s
        | _ -> failwith "error: cannot specify multiple output filenames"
    end
    in
    Byte_sequence.acquire output_file >>= fun out ->
    let _ = Missing_pervasives.println ("Successfully opened output file") in
    Elf_file.read_elf64_file out >>= fun eout ->
    let _ = Missing_pervasives.println ("Output file seems to be an ELF file") in
    let guessed_abi = find (fun a -> a.is_valid_elf_ident eout.elf64_file_header.elf64_ident) all_abis
    in
    match guessed_abi with
      Just a -> let v = (correctly_linked a (zip input_items item_options) options eout) in 
        return (show v)
    | Nothing -> Fail("output file does not conform to any known ABI")
    end
  in
    match res with
      | Fail err  -> Missing_pervasives.println ("[!]: " ^ err)
      | Success e -> Missing_pervasives.println e
    end


