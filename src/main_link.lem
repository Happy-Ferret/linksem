open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
import Set
import Set_extra
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_file
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_types_native_uint
open import Elf_relocation
open import String_table

open import Abstract_abi
open import Abi_amd64_elf_header
open import Abi_amd64_serialisation
open import Abis

open import Command_line
open import Input_list
open import Linkable_list

let default_hdr_bdl =
  (default_os_specific_print, default_proc_specific_print)

let default_pht_bdl =
  (default_os_specific_print, default_proc_specific_print)

let default_sht_bdl =
  (default_os_specific_print, default_proc_specific_print, default_user_specific_print)

val segment_load_ranges : elf64_interpreted_segments -> list (natural * natural)
let segment_load_ranges es = 
    let get_range : elf64_interpreted_segment -> list (natural * natural) = (
        fun x -> if x.elf64_segment_type = elf_pt_load 
            then [(x.elf64_segment_base, x.elf64_segment_base + x.elf64_segment_memsz)] 
            else []
    )
    in
    foldl (++) [] (List.map get_range es) 

val range_contains : (natural * natural) -> (natural * natural) -> bool
let range_contains (r1begin, r1end) (r2begin, r2end) = 
    (* r1 is at least as big as r2 *)
    r2begin >= r1begin && r2end <= r1end

val range_overlaps : (natural * natural) -> (natural * natural) -> bool
let range_overlaps (r1begin, r1end) (r2begin, r2end) =
    (r1begin < r2end && r1end > r2begin) || (r2begin < r1end && r2end > r1begin)
    
val is_partition : list (natural * natural) -> list (natural * natural) -> bool
let is_partition rs ranges = 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    let r_is_contained_by_some_range
     = fun r -> foldl (||) false (List.map (fun range -> range_contains range r) ranges)
    in
    all (fun r -> r_is_contained_by_some_range r) rs
    &&
    (* 2. elements of the first list do not overlap *)
    all (fun r -> all (fun r2 -> (r = (* should be "=="? *) r2) || (not (range_overlaps r r2))) rs) rs

val range_models_section : elf64_interpreted_section -> natural -> natural -> bool
let range_models_section s base len = 
    true

val     nat_range : natural -> natural -> list natural
let rec nat_range base len =
    match len with 
        0 -> []
    |   _ -> base :: (nat_range (base + 1) (len - 1))
    end

(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
val expand_ranges : list (natural * natural) -> list bool -> list bool
let rec expand_ranges sorted_ranges accum =
    match sorted_ranges with
        [] -> accum
     |  (base, len) :: more -> 
            (* pad the accum so that it reaches up to base *)
            let up_to_base = (Missing_pervasives.replicate (base - (Missing_pervasives.length accum)) true)
            in
            let up_to_end_of_range = up_to_base ++ (Missing_pervasives.replicate len false)
            in
            expand_ranges more (accum ++ up_to_end_of_range)
    end

val make_byte_pattern : list byte -> list bool -> list (maybe byte)
let rec make_byte_pattern bytes dontcares = 
    match bytes with
          [] -> []
        | b :: bs -> match dontcares with 
                er :: more -> (if er then Just b else Nothing) :: (make_byte_pattern bs more)
              | _ -> failwith "make_byte_pattern: unequal length"
              end
    end

val section_as_byte_pattern : abi -> endianness -> elf64_interpreted_section -> elf64_interpreted_sections -> list (maybe byte)
let section_as_byte_pattern a endian s all_s =
    (* Zero-pad a bss section *)
    let body = 
        if s.elf64_section_type = sht_nobits 
        then Byte_sequence.zeros s.elf64_section_size
        else s.elf64_section_body
    in
    let s_bytes = match body with Sequence(bs) -> bs end
    in
    let maybeIndex = Missing_pervasives.find_index (fun el -> el = s) all_s
    in
    let index = match maybeIndex with 
        Just i -> i
        | _ -> failwith "section not in list of sections"
    end
    in
    let relss = [rels | forall (rels MEM all_s) | 
        rels.elf64_section_type = sht_rel && rels.elf64_section_info = index]
    in
    let relss_records = List.concatMap
        (fun rels -> match read_elf64_relocation_section rels.elf64_section_size endian rels.elf64_section_body with
            Fail _ -> failwith "reading rels"
            | Success (recs, rest) -> recs
        end)
        relss
    in
    let relass = [relas | forall (relas MEM all_s) | 
        relas.elf64_section_type = sht_rela && relas.elf64_section_info = index]
    in
    let relass_records = List.concatMap 
        (fun relas -> match read_elf64_relocation_a_section relas.elf64_section_size endian relas.elf64_section_body with
            Fail _ -> failwith "reading relas"
            | Success (recs, rest) -> recs
        end)
        relass
    in
    (* Now we have all the relocation sections; turn them into lists of relocated ranges. *)
    let rel_ranges : list (natural * natural)
     = let width_of_relocation = fun r -> let (width_fun, f) = a.reloc (elf64_relocation_r_type r.elf64_r_info) in (width_fun Nothing) (* FIXME *)
     in List.map (fun r -> (natural_of_elf64_addr r.elf64_r_offset, (width_of_relocation r))) relss_records
    in
    let rela_ranges : list (natural * natural)
     = let width_of_relocation_a = fun ra -> let (width_fun, f) = a.reloc (elf64_relocation_r_type ra.elf64_ra_info) in (width_fun Nothing) (* FIXME *)
     in List.map (fun r -> (natural_of_elf64_addr r.elf64_ra_offset, (width_of_relocation_a r))) relass_records
    in
    let ranges = rel_ranges ++ rela_ranges
    in
    let sorted_ranges = sortBy (fun (base1, len1) -> (fun (base2, len2) -> base1 < base2)) ranges
    in
    let expanded_ranges_short = expand_ranges sorted_ranges []
    in
    let expanded_ranges = append expanded_ranges_short (Missing_pervasives.replicate (s.elf64_section_size - (Missing_pervasives.length expanded_ranges_short)) true)
    in
    let byte_pattern = make_byte_pattern s_bytes expanded_ranges
    in
    let _ = Missing_pervasives.prints ("Section name-number " ^ (show s.elf64_section_name) ^ " has byte-pattern of length " ^ (show (Missing_pervasives.length byte_pattern)) ^ "\n") in
    byte_pattern

val byte_option_matches_byte : maybe byte -> byte -> bool
let byte_option_matches_byte optb b =
    match optb with 
            Nothing -> true 
        |   Just some -> some = b 
    end

val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool
let rec byte_list_matches_pattern pattern bytes = 
    match pattern with 
        [] -> true
        | optbyte :: more -> match bytes with 
                [] -> false
                | abyte :: morebytes -> 
                    byte_option_matches_byte optbyte abyte 
                 && byte_list_matches_pattern more morebytes
            end
    end
    
val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural
let rec accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum =
    (* let _ = Missing_pervasives.prints ("At offset " ^ (show offset) ^ "... ")
    in *)
    match pattern with
        [] -> (* let _ = Missing_pervasives.prints ("terminating with hit (empty pattern)\n") in *)
            offset :: accum
        | byte_pattern :: more_byte_patterns -> (* nonempty, so check for nonempty seq *)
            match seq with 
                [] -> (*let _ = Missing_pervasives.prints ("terminating with miss (empty pattern)\n") 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte :: more_bytes -> let matched_this_byte = 
                            byte_option_matches_byte byte_pattern byte
                       in
                       (* let _ = Missing_pervasives.prints ("Byte " ^ (show byte) ^ " matched " ^ (show byte_pattern) ^ "? " ^ (show matched_this_byte) ^ "; ") 
                       in *)
                       let sequence_long_enough = (seq_len >= pattern_len) 
                       in
                       (* let _ = Missing_pervasives.prints ("enough bytes remaining (" ^ (show seq_len) ^ ") to match rest of pattern (" ^ (show pattern_len) ^ ")? " ^ (show sequence_long_enough) ^ "; ") 
                       in *)
                       let matched_here = matched_this_byte && sequence_long_enough &&
                        byte_list_matches_pattern more_byte_patterns more_bytes
                       in
                       (* let _ = Missing_pervasives.prints ("matched pattern anchored here? " ^ (show matched_this_byte) ^ "\n") 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len - 1) 
                           (offset + 1) 
                           (if matched_here then offset :: accum else accum)
            end
    end

val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural
let pattern_possible_starts_in_one_byte_sequence pattern seq offset =
    (* let _ = Missing_pervasives.prints ("Looking for matches of " ^
        (show (List.length pattern)) ^ "-byte pattern in " ^ (show (List.length seq)) ^ "-byte region\n")
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset []

val pattern_possible_starts_in_one_load_phdr : string -> list (maybe byte) -> elf64_interpreted_segment -> natural -> list natural
let pattern_possible_starts_in_one_load_phdr phdr_name pattern seg offset =
    (* zero-pad the segment body to memsz *)
    match zero_pad_to_length seg.elf64_segment_memsz seg.elf64_segment_body with 
        Sequence(bytes) ->
            let ret = pattern_possible_starts_in_one_byte_sequence pattern bytes 0
            in  
            let _ = Missing_pervasives.prints 
                ("Pattern of length " ^ (show (Missing_pervasives.length pattern)) 
                ^ " (" ^ (show pattern) ^ ")"
                ^ " matched bytes of phdr " ^ phdr_name
                ^ " in " ^ (show (Missing_pervasives.length ret)) ^ " ways: "
                ^ (if (Missing_pervasives.length ret) < 2000 then (show ret) else "(not shown)") ^ "\n") in
            ret
    end

val pattern_possible_starts_in_load_phdrs : list (maybe byte) -> elf64_file -> list natural
let pattern_possible_starts_in_load_phdrs pattern f =
    (* for each virtual address in a segment, evaluate whether
       it might be a representation of our pattern *)
    (* only PT_LOAD segments are relevant *)
    let load_segs = List.filter (fun seg -> seg.elf64_segment_type = elf_pt_load) f.elf64_file_interpreted_segments
    in
    let _ = Missing_pervasives.prints ("Output file has " ^ (show (Missing_pervasives.length load_segs)) 
        ^ " PT_LOAD segments\n")
    in
    let seg_name = fun seg -> hex_string_of_natural seg.elf64_segment_base
    in
    let get_starts = fun seg -> pattern_possible_starts_in_one_load_phdr (seg_name seg) pattern seg 0
    in 
    let all_segs_starts = List.map get_starts load_segs
    in
    let seg_startlist_pairs = zip load_segs all_segs_starts
    in
    (* let _ = Missing_pervasives.println "Got to blah ss1" in *)
    let seg_start_pairs = [(seg, start) | forall ((seg, starts) MEM seg_startlist_pairs) (start MEM starts) | true ]
    in
    (* let _ = Missing_pervasives.println "Got to blah ss2" in *)
    let vaddr_starts = List.map (fun (seg, start) -> seg.elf64_segment_base + start) seg_start_pairs
    in
    vaddr_starts

val sec_and_start_as_interval : elf64_interpreted_section -> natural -> (natural * natural)
let sec_and_start_as_interval sec start = 
    (start, start + sec.elf64_section_size)

val     all_global_assignments_accum
 : list ((elf64_interpreted_section * elf64_file * string) * list natural)
  -> list (list (elf64_interpreted_section * natural))
  -> list (list (elf64_interpreted_section * natural))
let rec all_global_assignments_accum s_and_ss accum =
    match s_and_ss with
        [] -> accum
    |   ((sec, f, fname), starts) :: more -> 
            let _ = Missing_pervasives.println ("Placing section " ^ 
                (show_else "(no name)" (name_of_elf64_interpreted_section sec f)) ^ " from file " ^ fname 
                ^ " in each of " ^ (show (List.length accum)) ^ " accumulated layouts") in
            let all_assignments_for_sec = 
                [(sec, start) | forall (start MEM starts) | true]
            in
            let _ = Missing_pervasives.println "Blah a1" in
            (* For each global assignment so far, we add the current (section, start)
             * *if* it doesn't overlap with other assignments. *)
            let _ = Missing_pervasives.println "Blah a2" in
            let ways_to_add_this_section_to_a_global_assignment
             = fun global_ass -> [
                    (sec, start)
                     | forall ((sec, start) MEM all_assignments_for_sec)
                     | List.all (fun (other_sec, other_start) -> 
                        (not (range_overlaps (sec_and_start_as_interval sec start) 
                            (sec_and_start_as_interval other_sec other_start)))) global_ass
            ]
            in
            let all_additions_to_existing_global_assignments = 
                List.map ways_to_add_this_section_to_a_global_assignment accum
            in
            let accum_and_additions = zip accum all_additions_to_existing_global_assignments
            in
            (* Compute the new accumulator as a function of the old one. 
             * If, give an global assignment, none of the section starts is okay, 
             * then we will remove that assignment from the accumulator, i.e. prune/backtrack.
             *)
            let new_accum : list (list (elf64_interpreted_section * natural)) = 
                 list_reverse_concat_map 
                    (fun global_ass -> 
                        let ways_to_extend
                         = ways_to_add_this_section_to_a_global_assignment global_ass 
                        in 
                        (* let _ = Missing_pervasives.println ("Found " ^ (show (List.length ways_to_extend))
                            ^ " ways to place this section in one global assignment")
                        in *)
                        [ new_ass :: global_ass | 
                            forall (new_ass MEM ways_to_extend) | true ]
                     )
                accum
            in
            let _ = Missing_pervasives.println "Blah a4" in
            all_global_assignments_accum more new_accum
    end

val all_allocated_user_sections_in_load_phdrs : abi -> list elf64_file -> list string -> elf64_file -> bool
let all_allocated_user_sections_in_load_phdrs a efs names out =
    (* There must exist a contiguous partitioning of the segments' memory space 
     * s.t. for each section, exactly one element of the partition models the segment
     * where "models" is defined in terms of file contents and relocation.
     * There *may* be elements of the partition unaccounted by any input section,
     * although the linker should not inject garbage randomly... tighten this down later.
     * 
     * The space of partitionings is very large in the presence of even a bit of 
     * padding. So don't enumerate that directly. Instead, for each section, look
     * for places where that section might start. Then enumerate the non-overlapping
     * assignments of sections to start addresses.
     * 
     * Instead, for each section, get its possible starting (seg, off) positions
     * then check that there exists a partition.
     *)
    let is_alloc : elf64_interpreted_section -> elf64_file -> bool
     = (fun s -> (fun f -> (elf64_xword_land 
        (elf64_xword_of_natural s.elf64_section_flags) 
        (elf64_xword_of_natural shf_alloc))
         = (elf64_xword_of_natural shf_alloc)))
    in
    let is_user : elf64_interpreted_section -> elf64_file -> bool
     = fun s -> (fun f -> (not (a.section_is_special s f)))
    in
    let is_alloc_and_user : elf64_interpreted_section -> elf64_file -> bool 
     = (fun s -> (fun f -> (is_alloc s f) && (is_user s f)))
    in
    let efs_with_name = zip efs names
    in
    let alloc_section_triples
     = [    (section, f, fname)
            | forall ((f, fname) MEM efs_with_name) (section MEM f.elf64_file_interpreted_sections)
            | is_alloc_and_user section f
    ]
    in
    let _ = Missing_pervasives.println ("Inputs have a total of " ^ 
        (show (Missing_pervasives.length alloc_section_triples)) ^ " allocatable user sections.")
    in
    (* FIXME: check (somewhere) that endianness is consistent across input files and outputs *)
    let endian = get_elf64_header_endianness (out.elf64_file_header)
    in
    (* We get a list with one element per alloc section. 
     * That element is a list of possible start vaddrs for that section. *) 
    let section_possible_seg_starts : list (list natural) = 
        List.map 
            (fun (sec, file, fname) -> 
                let _ = Missing_pervasives.println ("Considering section "
                    ^ (match name_of_elf64_interpreted_section sec file with 
                           Just n -> n
                         | Nothing -> "(unknown)" 
                       end
                       ) ^ " in " ^ fname)
                in
                pattern_possible_starts_in_load_phdrs (section_as_byte_pattern a endian sec file.elf64_file_interpreted_sections) out) 
                alloc_section_triples
    in
    let len = List.length section_possible_seg_starts in
    let _ = Missing_pervasives.println ("Found " ^ (show (List.map List.length section_possible_seg_starts)) ^ 
        " content-matching ways to map input sections onto output segments.")
    in
    let _ = Missing_pervasives.println "Blah 1" in
    let load_ranges = segment_load_ranges out.elf64_file_interpreted_segments
    in
    (* Make a list of all possible global assignments. 
     * A global assignment is a list of (sections, address) pairs
     * To enumerate all of them, 
     * we pick a (section, starts-list) pair from the head of the list, 
     * append all (section, start) pairs in that list to the assignments accumulated for earlier sections,
     * then recurse to accumulate further.
     *)
    let _ = Missing_pervasives.println "Blah 2" in
    let sections_and_possible_starts : list ((elf64_interpreted_section * elf64_file * string) * list natural)
     = zip alloc_section_triples section_possible_seg_starts
    in
    (* Sort the list so that the most constrained sections come first.  Since we 
     * avoid accumulating overlapping mappings, this avoids making the list of 
     * assignments blow up with "blocking" placements that just cause wasted
     * effort when trying to place later sections. *)
    let _ = Missing_pervasives.println "Blah 3" in
    let sorted_sections_and_possible_starts = Sorting.sortBy 
        (fun ((sec1, ef1, fname1), starts1) -> (fun ((sec2, ef2, fname2), starts2) -> 
            (List.length starts1) < (List.length starts2)))
        sections_and_possible_starts
    in
    let _ = Missing_pervasives.println ("After sorting: " ^ (show (List.map (fun (s, starts) -> List.length starts) sorted_sections_and_possible_starts)))
    in
    let all_global_assignments : list (list (elf64_interpreted_section * natural))
     = all_global_assignments_accum sorted_sections_and_possible_starts [[]]
    in
    let _ = Missing_pervasives.println "Blah 4" in
    let _ = Missing_pervasives.prints ("Enumerated " ^ 
        (show (Missing_pervasives.length all_global_assignments)) ^ 
        " global assignments of input sections onto output vaddrs:\n")
    in
    let _ = Missing_pervasives.println "Blah 5" in
    let all_global_assignments_as_intervals : list (list (natural * natural)) = 
        List.map
        (fun assignment -> [(sec_and_start_as_interval section base) | forall ((section, base) MEM assignment) | true])
        all_global_assignments
    in
    let valid_assignments = List.filter (fun ass -> is_partition ass load_ranges) all_global_assignments_as_intervals
    in
    let _ = Missing_pervasives.println "Blah 6" in
    let _ = Missing_pervasives.prints ("Of these, " ^ 
        (show (Missing_pervasives.length valid_assignments)) ^ 
        " are valid partitionings\n")
    in
    (Missing_pervasives.length valid_assignments) > 0

val correctly_linked : abi -> linkable_list -> list string -> list link_option -> elf64_file -> bool
let correctly_linked a linkables names options eout = 
    let initial_included_indices = mapMaybei (fun i -> (fun item -> 
        let (obj, input_item, options) = item 
        in 
        if options.item_force_output 
        then Just i
        else Nothing
    )) linkables 
    in
    let _ = Missing_pervasives.println ("Initial included linkables are "
        ^ (show (mapMaybe (List.index linkables) (List.map natFromNatural initial_included_indices))))
    in
    let (all_bindings : list (symbol_reference * maybe symbol_definition))
     = accumulate_bindings linkables (all_definitions_by_name linkables) {} initial_included_indices [] 
    in
    (* get the set of all inputs to which some binding was formed *)
    let required_definitions = mapMaybei (fun i -> (fun (ref, maybe_def) -> maybe_def)) all_bindings
    in
    let required_indices = { def.def_idx | forall (def MEM required_definitions) | true }
    in
    let required_indices_list = Set_extra.toList required_indices
    in
    let required_linkables_list = List.mapMaybe (fun idx -> List.index linkables (natFromNatural idx)) required_indices_list
    in
    let elf_phdrs_size = fun ef -> (natural_of_elf64_half ef.elf64_file_header.elf64_phnum) 
            * (natural_of_elf64_half ef.elf64_file_header.elf64_phentsize)
    in 
    let elf_shdrs_size = fun ef -> (natural_of_elf64_half ef.elf64_file_header.elf64_shnum) * (natural_of_elf64_half ef.elf64_file_header.elf64_shentsize)
    in 
    let elf_of_linkable = fun l -> match l with
        (RelocELF(ef), _, _) -> ef
        | _ -> failwith "unsupported linkable"
    end
    in
    is_elf64_executable_file eout.elf64_file_header 
     && elf_phdrs_size eout > 0
     && List.all (fun l -> (elf_shdrs_size (elf_of_linkable l)) > 0) required_linkables_list
     && all_allocated_user_sections_in_load_phdrs a 
        (List.map elf_of_linkable required_linkables_list) 
        names eout

(* We need to elaborate the command line to handle objects, archives 
 * and archive groups appropriately. 
 * We could imagine a relation between objects such that 
 * (o1, o2) is in the relation
 * iff definitions in o1 might be used to satisfy references in o2. ("o1 supplies o2")
 * If o1 is a .o, all other .o files are searched.
 * If o1 comes from an archive and is not in a group, it only supplies *preceding* objects (whether from an archive or a .o).
 * If o1 comes from an archive in a group, it supplies preceding objects and any objects from the same group.
 * 
 * That doesn't capture the ordering, though: 
 * for each object, there's an ordered list of other objects 
 * in which to search for the *first* definition. *)

let _ =
  let res =
    let (input_units, link_options) = command_line ()
    in
    let items_and_options = elaborate_input input_units
    in
    let (input_items, item_options) = unzip items_and_options
    in
    let _ = Missing_pervasives.println ("Got " ^ (show (List.length input_items)) ^ " input items: {"
        ^ (List.foldl (^) "" (List.map (fun item -> (show item) ^ ",") input_items)) ^ "}")
    in
    let output_file_options
     = filter (fun el -> match el with OutputFilename(s) -> true | _ -> false end) link_options
    in
    let output_file = match output_file_options with
        [] -> failwith "impossible: no output file specified, despite default value of `a.out'"
        | [OutputFilename(s)] -> s
        | _ -> failwith "error: cannot specify multiple output filenames"
    end
    in
    Byte_sequence.acquire output_file >>= fun out ->
    let _ = Missing_pervasives.println ("Successfully opened output file") in
    Elf_file.read_elf64_file out >>= fun eout ->
    let _ = Missing_pervasives.println ("Output file seems to be an ELF file") in
    let guessed_abi = find (fun a -> a.is_valid_elf_header eout.elf64_file_header) all_abis
    in
    let make_linkable = fun (it, opts) -> linkable_item_of_input_item_and_options it opts
    in
    let linkable_items_and_options = List.map make_linkable items_and_options
    in
    let names = List.map show input_items
    in
    match guessed_abi with
      Just a -> let v = (correctly_linked a linkable_items_and_options names link_options eout) in 
        return (show v)
    | Nothing -> Fail("output file does not conform to any known ABI")
    end
  in
    match res with
      | Fail err  -> Missing_pervasives.println ("[!]: " ^ err)
      | Success e -> Missing_pervasives.println e
    end


