open import Basic_classes
open import Function
open import String
open import Tuple
open import Bool
open import List
open import Sorting
import Map
import Set
import Set_extra
open import Num
open import Maybe
open import Assert_extra

open import Byte_sequence
open import Default_printing
open import Error
open import Missing_pervasives
open import Show
open import Endianness

open import Elf_header
open import Elf_file
open import Elf_interpreted_section
open import Elf_interpreted_segment
open import Elf_section_header_table
open import Elf_program_header_table
open import Elf_types_native_uint
open import Elf_relocation
open import String_table

open import Abi_amd64_elf_header
open import Abi_amd64_serialisation
open import Abis

open import Command_line
open import Input_list
open import Linkable_list

open import Memory_image
open import Elf_memory_image

open import Linker_script
open import Link

val images_equal_modulo_alignment : elf_memory_image -> elf_memory_image -> bool
let images_equal_modulo_alignment img1 img2 =
    img1.by_tag = img2.by_tag (* FIXME: the "modulo alignment" part *)

val correctly_linked : abi any_abi_feature -> linkable_list -> list string -> list link_option -> elf64_file -> bool
let correctly_linked a linkables names options eout = 
    let output_image = elf_memory_image_of_elf64_file a "(output file)" eout
    in
    let script = default_linker_control_script a 
        (* user_text_segment_start *) (match Command_line.find_option_matching_tag (TextSegmentStart(0)) options with Just(TextSegmentStart(addr)) -> Just addr | _ -> Nothing end)
        (* user_data_segment_start *) Nothing
        (* user_rodata_segment_start *) (match Command_line.find_option_matching_tag (RodataSegmentStart(0)) options with Just(RodataSegmentStart(addr)) -> Just addr | _ -> Nothing end)
        (* elf_headers_size *) (* HACK: take these from the output file. *)
            (
                (natural_of_elf64_half eout.elf64_file_header.elf64_ehsize) + 
                ((natural_of_elf64_half eout.elf64_file_header.elf64_phnum) 
                * (natural_of_elf64_half eout.elf64_file_header.elf64_phentsize))
            )
    in
    let linked_image = link script a options linkables
    in
    images_equal_modulo_alignment output_image linked_image

(* We need to elaborate the command line to handle objects, archives 
 * and archive groups appropriately. 
 * We could imagine a relation between objects such that 
 * (o1, o2) is in the relation
 * iff definitions in o1 might be used to satisfy references in o2. ("o1 supplies o2")
 * If o1 is a .o, all other .o files are searched.
 * If o1 comes from an archive and is not in a group, it only supplies *preceding* objects (whether from an archive or a .o).
 * If o1 comes from an archive in a group, it supplies preceding objects and any objects from the same group.
 * 
 * That doesn't capture the ordering, though: 
 * for each object, there's an ordered list of other objects 
 * in which to search for the *first* definition. *)

let _ =
  let res =
    let (input_units, link_options) = command_line ()
    in
    let items_and_options = elaborate_input input_units
    in
    let (input_items, item_options) = unzip items_and_options
    in
    let _ = Missing_pervasives.println ("Got " ^ (show (List.length input_items)) ^ " input items: {"
        ^ (List.foldl (^) "" (List.map (fun item -> (show item) ^ ",") input_items)) ^ "}")
    in
    let output_file_options
     = filter (fun el -> match el with OutputFilename(s) -> true | _ -> false end) link_options
    in
    let output_file = match output_file_options with
        [] -> failwith "impossible: no output file specified, despite default value of `a.out'"
        | [OutputFilename(s)] -> s
        | _ -> failwith "error: cannot specify multiple output filenames"
    end
    in
    Byte_sequence.acquire output_file >>= fun out ->
    let _ = Missing_pervasives.println ("Successfully opened output file") in
    Elf_file.read_elf64_file out >>= fun eout ->
    let _ = Missing_pervasives.println ("Output file seems to be an ELF file") in
    let guessed_abi = find (fun a -> a.is_valid_elf_header eout.elf64_file_header) all_abis
    in
    let a = match guessed_abi with
      Just a -> a
      | Nothing -> failwith "output file does not conform to any known ABI"
    end
    in
    let make_linkable = fun (it, opts) -> linkable_item_of_input_item_and_options a it opts
    in
    let linkable_items_and_options = List.map make_linkable items_and_options
    in
    let names = List.map show input_items
    in 
    let v = correctly_linked a linkable_items_and_options names link_options eout
    in return (show v)
  in
    match res with
      | Fail err  -> Missing_pervasives.println ("[!]: " ^ err)
      | Success e -> Missing_pervasives.println e
    end


