\documentclass[preprint, natbib, 10pt]{sigplanconf-pldi15}

\usepackage{amsmath}
\usepackage[british]{babel}
\usepackage[colorlinks]{hyperref}
\usepackage{microtype}

\title{A realistic semantics for ELF linking and loading, with applications}
\authorinfo{Stephen Kell \and Dominic P. Mulligan \and Peter Sewell}
           {Computer Laboratory, University of Cambridge}
           {firstname.lastname@cl.cam.ac.uk}

\bibliography{plainnat}

\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\section{Introduction}
\label{sect.introduction}

\subsection{Contributions}
\label{subsect.contributions}

\begin{itemize}
\item
Lem model of ELF derived from the SCO specification and \texttt{readelf} and \texttt{Linux} sources where the former is ambiguous or misleading
\item
Exact binary preservation of Lem parsing and blitting of ELF files demonstrated by automated \texttt{diff}ing against \texttt{hexdump}, a trusted external oracle
\item
Accurate extraction of the contents of: file headers, section headers, program headers, ABI-specific relocation information, static and dynamic symbol tables, and the contents of the \texttt{.dynamic} section, verified using automated \texttt{diff}ing against \texttt{readelf}, a trusted external oracle
\item
Partial specification of ABI-specific addenda to the core ELF specification for \texttt{AARCH64}, \texttt{AMD64}, \texttt{Power64} and \texttt{x86} platforms.
\item
Partial specification of \texttt{GNU} extensions to the ELF specification as partially documented in the Linux Standard Base.
Many facets of the \texttt{GNU} extensions are only partially documented in the LSB and therefore the specification was reconstructed based on inspection of the \texttt{readelf} and \texttt{Linux} source code, as well as observation of ELF binaries in `the wild'.
\item
An executable specification of static linking of ELF binaries, built atop our formal ELF model.
Capturing even simple link-jobs requires the additional specification of linker script and the linker command line.
Our specification is modeled as a predicate between input object files, command line and linker script arguments, and output statically linked binaries.
\item
Validation of our specification of static linking by demonstrating it correctly witnesses the static linking of the \texttt{Linux} and \texttt{Mirage} kernels.
\end{itemize}

\subsection{Lem, our specification tool}
\label{subsect.lem.our.specification.tool}

\subsection{Map of paper}
\label{subsect.map.of.paper}

\section{A formal ELF model}
\label{sect.formal.elf.model}

\subsection{Validation}
\label{subsect.elf.validation}

\section{Linking semantics}
\label{sect.linking.semantics}

\subsection{Validation}
\label{subsect.linking.validation}

\section{Conclusions and further work}
\label{sect.conclusions.and.further.work}

\subsection{Related work}
\label{subsect.related.work}

\subsection{Further work}
\label{subsect.further.work}

\bibliography{elf-model-etc}

\end{document}



















\begin{document}

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2005} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{A realistic semantics for ELF linking and loading, with applications}
% \subtitle{Subtitle Text, if any}

\authorinfo{Stephen Kell \and Dominic Mulligan \and Peter Sewell}
           {Computer Laboratory, University of Cambridge}
           {firstname.lastname@cl.cam.ac.uk}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

% \category{CR-number}{subcategory}{third-level}

% \terms
% term1, term2
% 
% \keywords
% keyword1, keyword2

\section{Introduction}

Precise semantics for source languages and instruction sets
have enabled not only verified compilation
but also more rigorous approaches to 
microprocessor design, compiler testing
and the implementation of critical low-level algorithms.
(FIXME: references for these?)

Missing from this picture, however, 
is the infrastructure for \emph{linking} and \emph{loading} real programs. 
This has a vital influence on the meaning of the programs 
that actually execute.
But linkers and loaders remain poorly understood by most programmers,
poorly specified by their implementers, 
and ad-hoc in many aspects of their design and behaviour.


MENTION: mainstream versus CompCert / specialised

MENTION: linker-speak -- systems software, and (a little) application software
   -- maybe Drepper's "shared libraries" document as an example of what's gone wrong!

MENTION: relationship to verified compilation

This paper presents
the first realistic formal model 
of ELF linking and loading, 
empirically validated against several real implementations.
We also set the model in context
by discussing several (FIXME: ?) use cases.

Contributions:

\begin{itemize}

\item We review the roles played by linking and loading 
in mainstream software systems.
We show that, contrary to the approach of much prior work, linking is not simply a mechanism 
for implementing separate compilation. Rather, software's semantics depend crucially
on the influence of the linker, which implements features not expressible 
in any source language.

\item We present the first realistic formal model of ELF linking, including 
not only the ELF file format and linking operation but also 
the semantically important aspects of the linker command line and linker scripts.
Our model captures archives, symbol visibility and \ldots{} FIXME (list more features here).

\item We evaluate the model's completeness with respect to real linkers 
in a large-scale cross-validation experiment
(gold, ld.bfd, lld? ARM linker?)

\item We evaluate the model's capacity to detect ``bad'' links 
using a selection of linker-level malware (FIXME: this means the weird machines stuff)

\item We illustrate the model's application to verified compilation
HOW if we care only about loading?
AHA, statically-linked to memory image
This entails additionally modelling a simple loader.
WHAT does the CakeML compiler care about here?

% \item we describe tools for different classes of 

% \item model (compile-time) linking
% -- dynamic linking too?    
%        maybe a minimalist version, i.e. "no fancy features" and a simple checkload tool
% -- (cross-)validation using gold, ld.bfd, lld
% 
% \item model loading (CakeML, ELF auxv)
%  -- dynamic loading too?

%\item model ABIs enough to label/check ABI-correct compositions w.r.t. what?
%       -- struct layouts and calling conventions are probably separate/future work

% dependecy & deployment?
%   i.e. ARM person's build-upgrade "unwanted/unexpected .so dependency" problem
%      "build for a particular deployment environment

\end{itemize}

% Some "question-format" stuff
% 
% \item what is required 
% in order to extend the theorems offered
% by verified compilation infrastructure
% so that they state properties of the actual code that executes?
% (answers: linking, system calls)
% 
% \item how do authors of \emph{non-verified} toolchains
% work with incomplete or ambiguous specifications
% relating to linking and loading, 
% and what can be done to reduce the level of linking- or ABI-related bugs 
% (of which we show examples in \S FIXME)?
% 
% \item what sort of \emph{intent} do system- or application-level programmers
% encode using linker features
% as opposed to language features?
% Can we specify those intentions more abstractly, 

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

\bibliographystyle{plainnat}

\bibliography{elf-model-etc}

\end{document}

