\section{The ELF formalisation}
\label{sect.elf.formalisation}

% dpm: scavenge material from here for Section 2
%\subsection{What is an ELF file?}
%\label{subsect.what.is.an.elf.file}

%The Executable and Linkable (ELF) file format~\cite{elf-sco-model} is a format for storing programs or their fragments on-disk, created as a result of compiling and linking.
%A flexible format not tied specifically to any one machine architecture, ELF is now the \emph{de facto} standard format for executable and linkable files on Linux, various flavours of BSD, and embedded devices ranging from mobile phones to games consoles.

%Unlike older formats ELF merges the file format of executable and linkable files together into a unified format.
%As a result, any given ELF file may provide one of two views: the \emph{executable view}, wherein the file is broken up into \emph{segments} indexed by a program header table, or the linkable view, wherein the file is broken up into \emph{sections} indexed by a section header table.
%The locations of the program and section header tables within the file are stored in a file header at the beginning of the file.
%Segments are loaded by the operating system in order to create an executable process image, whilst sections are merged and otherwise manipulated by a linker to create new segments or sections.

%A skeleton outline of the ELF file format is provided in the System V ABI~\cite{elf-sco-model}, and using this specification enough structure is defined to properly parse-and-blit ELF files to and from disk.
%However, to interpret the contents of a file more detail is needed, and therefore architecture-specific supplements to the core specification are provided for each microprocessor family.
%In some cases, these supplementary documents may provide extra section and segment types, extra flags, or other bits of structure to an ELF file specific to that platform.
%For example, the AARCH64 ABI supplement adds the \texttt{AARCH64\_BUILD\_ATTRIBUTES} section type, describing sections that contain unspecified compiler build attributes.
%In other cases, these supplementary documents may override the core-ELF specification.
%For example, the AARCH64 supplement overrides the interpretation of the ELF header field \texttt{e\_entry}, ostensibly the entry point for the program, but overridden to point to a location in the body of the file containing the entry point on AARCH64 platforms.
%In yet other cases, the core-ELF specification remains entirely silent on the contents and functioning of certain structural components of an ELF file.
%One key example of this is the interpretation of relocation records, which are tied to specific instruction encodings and therefore wholly ABI-specific, varying markedly from one ABI to another, and their semantics are therefore entirely delegated to the architecture-specific supplement for the platform in question.

%In addition operating systems may augment the format with their own extensions, specifying additional flags, section and segment types, and other structural elements.
%For example, many Linux ELF binaries contain \texttt{GNU} extensions.
%These augment the standard ELF file format, as for example, with the presence of a segment of type \texttt{PT\_GNU\_EH\_FRAME} containing exception handling information, or a section of type \texttt{STT\_GNU\_VERSION} containing versioning information.
%Some of these extensions are collated in a document called the \emph{Linux Standard Base} (`LSB')~\cite{linux-standard-base}.
%Many more, however, are either documented only informally in mailing list messages, or not documented at all.

%To capture enough of the structure of ELF files executed `in the wild', the core specification along with microprocessor-specific and operating-specific supplementary material must all be formally specified.
%We note here, however, that in practice there is no clean separation of the latter two sets of supplementary material.
%For example, the AMD64 ABI explicitly makes reference to function-symbols of type \texttt{STT\_GNU\_IFUNC}, a \texttt{GNU}-specific extension, for example (see Section 4.2 of~\cite{amd64-abi}).

% dpm: not needed now due to Lem being briefly introduced in the introduction
%\subsection{The Lem language}
%\label{subsect.rigorous.lem.specification}

%We use the Lem specification language~\cite{mulligan-lem-2014} to specify our model of the ELF file format and linking.
%Lem provides a lightweight language of (polymorphic) definitions, types and pure functions that can be seen both as mathematical definitions and pure functional programs.
%Lem typechecks definitions and then, subject to constraint, export them to executable OCaml code, proof assistant theories for HOL4~\cite{slind-brief-2008}, Isabelle/HOL~\cite{wenzel-isabelle-2008} and Coq~\cite{bertot-short-2008}, or typeset HTML and LaTeX.

%The Lem type system and libraries include bounded and unbounded integers and naturals, tuples, records, function types, sets, dictionaries, and user-defined types with top-level polymorphism.
%The expression language combines pure functional programming features (functions, pattern matching, and so on) with simple higher-order logic, including bounded quantification and set comprehensions.

\subsection{A Lem model of ELF}
\label{subsect.lem.model.of.elf}

Our ELF model provides types describing the concrete structure of an ELF file on disk along with more abstract types for ease of manipulation of a file's contents.
Functions for parsing and blitting files to lists of bytes and for interpreting the structural elements of a file are provided.
For example, functions are provided for the decoding of the section header string table, or producing a containment mapping of sections in segments.
Platform-specific logic is kept separate from the main body of the formalisation via the use of higher-order functions, with ABI- or \texttt{GNU}-specific logic handled by function arguments.
The formalisation consists of 9~500 lines of commented Lem code for core ELF, with approximately 2~000 lines for the \texttt{GNU} extensions and 4~000 lines for the AARCH64, AMD64, IA32 and Power64 platform ABIs.

The formal ELF model is currently in use in the \texttt{ppcmem2} tool~\cite{gray-integrated-2015}, a tool for exploring weak-memory behaviour on Power64, and is used to extract an executable process image from binaries, along with the initial values of global variabes, to generate and initial machine state for the emulator.

\subsection{Validation}
\label{subsect.elf.validation}

When formalising any widely-used file format we are faced with a choice: do we formalise the format as the specification \emph{seems} to be written, or do we formalise the format as implementors have interpreted that specification?
In our formalisation we chose the latter, as then our model is compatible with existing mainstream systems.
Then, in order to ensure that our model is a faithful implementation of ELF as it is commonly understood, we validated the model against a wide-range of ELF executable and linkable binaries on multiple machine architectures.
Validation was conducted using two widely-deployed and mature \texttt{GNU} tools---\texttt{hexdump} and \texttt{readelf}---as trusted oracles.

To test the parsing and decoding of the core structure of the ELF model, a \texttt{readelf}-like program was written atop the model.
Using an automated \texttt{diff} tool, the output of the real \texttt{readelf} was compared with the output of our clone.
This process tested the parsing and decoding of the file-header, section header table, program header table, dynamic section, relocation sections, and symbol tables, in addition to the various string tables contained within an ELF file, necessary to properly pretty-print the contents of the aforementioned structural elements.

In addition, a `roundtripping' property of the parsing and blitting functions was verified.
This ensured that parsing an existing ELF binary into our Lem types and then immediately blitting these types to binary data preserved byte-for-byte compatibility with the original binary file, a property which ensures that parsing and blitting are behaving as they should.
There is a slight complication here in that an ELF file may contain gaps between its structural elements which contain meaningless binary data.
This `dead' data must be explicitly tracked during parsing, and placed back in the correct position in a file when blitting, to ensure that the byte-for-byte compatibility condition holds.
We validated this property using an automated \texttt{diff} tool comparing the output of a lightweight shim written atop the ELF model against the output of \texttt{hexdump}.

Both properties mentioned above were validated on the AARCH64, AMD64, IA32 and Power64 architectures.
For the latter three architectures we validated against the contents of \texttt{usr/bin} and \texttt{usr/lib} on typical Linux distributions.
For the AARCH64 we validated our model against the contents of \texttt{system/bin} and \texttt{system/lib} of an LG Android~5.1.1 mobile phone.
On AARCH64, AMD64, IA32 and Power64 we tested against 576, 1650, 3222, and 1606 binaries, respectively---7054 in total.

Validating the model against binaries found `in the wild' on real machines revealed many sources of incompleteness in the various specification documents that describe ELF files.
For example, constructions relating to the ELF prelinker, such as the dynamic section type \texttt{DT\_GNU\_PRELINKED} are found in a large number of deployed ELF binaries.
However, these are not mentioned in any specification document, being mentioned only in passing in mailing list messages (see e.g.~\cite{jelinek-prelinker-2001}), and prior to validation were unknown to us.

\subsection{Theorem prover output}
\label{subsect.theorem.prover.output}

As mentioned, one of our aims in formalising the ELF format and the specifics of various platform ABIs is to create a validated set of definitions for software verification purposes.
The production of executable binaries from, and incorporation of realistic linking mechanisms into, verified compilers is a natural next step for those aiming to improve the trustworthiness of the compilation process.
Currently, both the CompCert and CakeML verified compilers depend on the platform hostchain for the final production of an executable binary.
Incorporating a trusted linker into their compilation process, and producing executable binaries directly, would remove this dependency on the platform hostchain.

Further, just as the CompCert project has acted as a nexus for work in the area of verified compilation, we see potential for our work to serve an analogous purpose in the area of verified linking.
For example, link-time optimisations were first implemented in the 4.5 release of the GCC compiler, and in recent years the implementation, expansion and improvement of these optimisations has been a significant area of activity for the GCC compiler team.
However, to date, no link-time optimisations have been formally proven correct in the context of verified compiler projects.
In part, this can be explained by the lack of a formal model of realistic linking to be able to even state and prove correct these types of optimisation.

To remedy this situation we have extracted Isabelle/HOL theory files from our Lem source model, corresponding to around 33,500 lines of commented Isabelle source.
Approximately 1,500 lines of handwritten termination proofs for recursive functions, and various lemmas needed for the completion of the termination lemmas, are also supplied, demonstrating at least in principle that our definitions can be used for effective proof in theorem provers.
HOL4 and Coq extractions of the the Lem source model will also be made available.
