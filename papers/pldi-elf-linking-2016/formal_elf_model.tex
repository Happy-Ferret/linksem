\section{The ELF formalisation}
\label{sect.elf.formalisation}

\subsection{What is an ELF file?}
\label{subsect.what.is.an.elf.file}

\dm{move into section 2 when ready}

The Executable and Linkable (ELF) file format~\cite{elf-sco-model} is a format for storing programs or their fragments on-disk, created as a result of compiling and linking.
A flexible format not tied specifically to any one machine architecture, ELF is now the \emph{de facto} standard format for executable and linkable files on Linux, various flavours of BSD, and embedded devices ranging from mobile phones to games consoles.

Unlike older formats ELF merges the file format of executable and linkable files together into a unified format.
As a result, any given ELF file may provide one of two views: the \emph{executable view}, wherein the file is broken up into \emph{segments} indexed by a program header table, or the linkable view, wherein the file is broken up into \emph{sections} indexed by a section header table.
The locations of the program and section header tables within the file are stored in a file header at the beginning of the file.
Segments are loaded by the operating system in order to create an executable process image, whilst sections are merged and otherwise manipulated by a linker to create new segments or sections.

A skeleton outline of the ELF file format is provided in the System V ABI~\cite{elf-sco-model}, and using this specification enough structure is defined to properly parse-and-blit ELF files to and from disk.
However, to interpret the contents of a file more detail is needed, and therefore architecture-specific supplements to the core specification are provided for each microprocessor family.
In some cases, these supplementary documents may provide extra section and segment types, extra flags, or other bits of structure to an ELF file specific to that platform.
For example, the AARCH64 ABI supplement adds the \texttt{AARCH64\_BUILD\_ATTRIBUTES} section type, describing sections that contain unspecified compiler build attributes.
In other cases, these supplementary documents may override the core-ELF specification.
For example, the AARCH64 supplement overrides the interpretation of the ELF header field \texttt{e\_entry}, ostensibly the entry point for the program, but overridden to point to a location in the body of the file containing the entry point on AARCH64 platforms.
In yet other cases, the core-ELF specification remains entirely silent on the contents and functioning of certain structural components of an ELF file.
One key example of this is the interpretation of relocation records, which are tied to specific instruction encodings and therefore wholly ABI-specific, varying markedly from one ABI to another, and their semantics are therefore entirely delegated to the architecture-specific supplement for the platform in question.

In addition operating systems may augment the format with their own extensions, specifying additional flags, section and segment types, and other structural elements.
For example, many Linux ELF binaries contain \texttt{GNU} extensions.
These augment the standard ELF file format, as for example, with the presence of a segment of type \texttt{PT\_GNU\_EH\_FRAME} containing exception handling information, or a section of type \texttt{STT\_GNU\_VERSION} containing versioning information.
Some of these extensions are collated in a document called the \emph{Linux Standard Base} (`LSB')~\cite{linux-standard-base}.
Many more, however, are either documented only informally in mailing list messages, or not documented at all.

To capture enough of the structure of ELF files executed `in the wild', the core specification along with microprocessor-specific and operating-specific supplementary material must all be formally specified.
We note here, however, that in practice there is no clean separation of the latter two sets of supplementary material.
For example, the AMD64 ABI explicitly makes reference to function-symbols of type \texttt{STT\_GNU\_IFUNC}, a \texttt{GNU}-specific extension, for example (see Section 4.2 of~\cite{amd64-abi}).

\subsection{The Lem language}
\label{subsect.rigorous.lem.specification}

We use the Lem specification language~\cite{mulligan-lem-2014} to specify our model of the ELF file format and linking.
Lem provides a lightweight language of (polymorphic) definitions, types and pure functions that can be seen both as mathematical definitions and pure functional programs.
Lem typechecks definitions and then, subject to constraint, export them to executable OCaml code, proof assistant theories for HOL4~\cite{slind-brief-2008}, Isabelle/HOL~\cite{wenzel-isabelle-2008} and Coq~\cite{bertot-short-2008}, or typeset HTML and LaTeX.

The Lem type system and libraries include bounded and unbounded integers and naturals, tuples, records, function types, sets, dictionaries, and user-defined types with top-level polymorphism.
The expression language combines pure functional programming features (functions, pattern matching, and so on) with simple higher-order logic, including bounded quantification and set comprehensions.

\subsection{A Lem model of ELF}
\label{subsect.lem.model.of.elf}

Our Lem ELF model provides types corresponding to the structure of an ELF file on disk with functions for parsing and blitting these structural elements to-and-from lists of bytes.
In addition, more abstract, derived types are defined which make working with, and manipulating the contents of an ELF file easier.

Atop this base model, functions are provided for extracting useful information from the Lem types, for example, the extraction of a containment mapping from sections to segments from an ELF file.
\texttt{GNU}-specific and platform ABI-specific formalisation is kept separate from the main body of the formalisation.
When functions working on generic ELF files require \texttt{GNU}- or ABI-specific functionality, the function is made higher-order with a function argument handling the ABI or \texttt{GNU}-specific logic.

The formalisation of the core ELF specification consists of around 9,500 lines of commented Lem code.
Around an additional 2000 lines of Lem code formalise \texttt{GNU} extensions, whilst another 4,000 lines of Lem formalise various aspects of the AARCH64, AMD64, IA32 and Power64 platform ABIs.

The formal ELF model is currently in use in the \texttt{ppcmem2} tool~\cite{gray-integrated-2015}, a tool for exploring the architectural envelope of weak-memory behaviour on the Power64 platform.
Statically-compiled ELF binaries are parsed and decoded using an OCaml extraction of the Lem model.
An executable process image is then extracted from the binary, along with the initial values of global variables appearing in the program, and is used to generate an initial machine state for the \texttt{ppcmem2} emulator.
We note that the creation of an executable process image requires ABI-specific logic (in e.g. identifying the entry point of the program).

\subsection{Validation}
\label{subsect.elf.validation}

We have validated our ELF model using \texttt{readelf} and \texttt{hexdump} as trusted external oracles.
These programs are freely available open source tools.

Our model was validated in two ways.
In one validation pass, we verified a `roundtripping' property of parsing and subsequently blitting an ELF file from-and-to a binary file.
The property was verified by comparing the output of a lightweight tool written atop the formal ELF model (also written in Lem) against the output of \texttt{hexdump}, comparing using a \texttt{diff} tool.
In the second validation pass, we verified the transcription of the ELF header, program- and section-header tables, dynamic section, relocation sections and symbol tables was correct.
These were verified by comparing the output of a tool that emulated a subset of \texttt{readelf}'s functionality against the output of \texttt{readelf} itself, again using an automated \texttt{diff} tool.

For AMD64, IA32 and Power64 microprocessors validation was carried out on the contents of \texttt{usr/lib}, \texttt{usr/lib64} and \texttt{usr/bin} on typical Linux desktop computers.
For AARCH64, ELF binaries were extracted from an Android phone and validated against \texttt{readelf} in the same manner.

Validating the model against binaries found `in the wild' on real machines revealed many sources of incompleteness in the various specification documents that describe ELF files.
For example, constructions relating to the ELF prelinker, such as the dynamic section type \texttt{DT\_GNU\_PRELINKED}, and which are found in a large number of deployed ELF binaries, are not mentioned in any specification document and mentioned only in passing in mailing list messages (see e.g.~\cite{jelinek-prelinker-2001}).

\subsection{Theorem prover output}
\label{subsect.theorem.prover.output}

As mentioned, one of our aims in formalising the ELF format and the specifics of various platform ABIs is to create a validated set of definitions for software verification purposes.
The production of executable binaries from, and incorporation of realistic linking mechanisms into, verified compilers is a natural next step for those aiming to improve the trustworthiness of the compilation process.
Currently, both the CompCert and CakeML verified compilers depend on the platform hostchain for the final production of an executable binary.
Incorporating a trusted linker into their compilation process, and producing executable binaries directly, would remove this dependency on the platform hostchain.

Further, just as the CompCert project has acted as a nexus for work in the area of verified compilation, we see potential for our work to serve an analogous purpose in the area of verified linking.
For example, link-time optimisations were first implemented in the 4.5 release of the GCC compiler, and in recent years the implementation, expansion and improvement of these optimisations has been a significant area of activity for the GCC compiler team.
However, to date, no link-time optimisations have been formally proven correct in the context of verified compiler projects.
In part, this can be explained by the lack of a formal model of realistic linking to be able to even state and prove correct these types of optimisation.

To remedy this situation we have extracted Isabelle/HOL theory files from our Lem source model, corresponding to around 33,500 lines of commented Isabelle source.
Approximately 1,500 lines of handwritten termination proofs for recursive functions, and various lemmas needed for the completion of the termination lemmas, are also supplied, demonstrating at least in principle that our definitions can be used for effective proof in theorem provers.
HOL4 and Coq extractions of the the Lem source model are also planned.
