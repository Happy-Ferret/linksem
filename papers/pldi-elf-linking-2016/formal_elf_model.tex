\section{The model: ELF}
\label{sect.elf.formalisation}

% dpm: scavenge material from here for Section 2
%\subsection{What is an ELF file?}
%\label{subsect.what.is.an.elf.file}

%The Executable and Linkable (ELF) file format~\cite{elf-sco-model} is a format for storing programs or their fragments on-disk, created as a result of compiling and linking.
%A flexible format not tied specifically to any one machine architecture, ELF is now the \emph{de facto} standard format for executable and linkable files on Linux, various flavours of BSD, and embedded devices ranging from mobile phones to games consoles.

%Unlike older formats ELF merges the file format of executable and linkable files together into a unified format.
%As a result, any given ELF file may provide one of two views: the \emph{executable view}, wherein the file is broken up into \emph{segments} indexed by a program header table, or the linkable view, wherein the file is broken up into \emph{sections} indexed by a section header table.
%The locations of the program and section header tables within the file are stored in a file header at the beginning of the file.
%Segments are loaded by the operating system in order to create an executable process image, whilst sections are merged and otherwise manipulated by a linker to create new segments or sections.

%A skeleton outline of the ELF file format is provided in the System V ABI~\cite{elf-sco-model}, and using this specification enough structure is defined to properly parse-and-blit ELF files to and from disk.
%However, to interpret the contents of a file more detail is needed, and therefore architecture-specific supplements to the core specification are provided for each microprocessor family.
%In some cases, these supplementary documents may provide extra section and segment types, extra flags, or other bits of structure to an ELF file specific to that platform.
%For example, the AARCH64 ABI supplement adds the \texttt{AARCH64\_BUILD\_ATTRIBUTES} section type, describing sections that contain unspecified compiler build attributes.
%In other cases, these supplementary documents may override the core-ELF specification.
%For example, the AARCH64 supplement overrides the interpretation of the ELF header field \texttt{e\_entry}, ostensibly the entry point for the program, but overridden to point to a location in the body of the file containing the entry point on AARCH64 platforms.
%In yet other cases, the core-ELF specification remains entirely silent on the contents and functioning of certain structural components of an ELF file.
%One key example of this is the interpretation of relocation records, which are tied to specific instruction encodings and therefore wholly ABI-specific, varying markedly from one ABI to another, and their semantics are therefore entirely delegated to the architecture-specific supplement for the platform in question.

%In addition operating systems may augment the format with their own extensions, specifying additional flags, section and segment types, and other structural elements.
%For example, many Linux ELF binaries contain \texttt{GNU} extensions.
%These augment the standard ELF file format, as for example, with the presence of a segment of type \texttt{PT\_GNU\_EH\_FRAME} containing exception handling information, or a section of type \texttt{STT\_GNU\_VERSION} containing versioning information.
%Some of these extensions are collated in a document called the \emph{Linux Standard Base} (`LSB')~\cite{linux-standard-base}.
%Many more, however, are either documented only informally in mailing list messages, or not documented at all.

%To capture enough of the structure of ELF files executed `in the wild', the core specification along with microprocessor-specific and operating-specific supplementary material must all be formally specified.
%We note here, however, that in practice there is no clean separation of the latter two sets of supplementary material.
%For example, the AMD64 ABI explicitly makes reference to function-symbols of type \texttt{STT\_GNU\_IFUNC}, a \texttt{GNU}-specific extension, for example (see Section 4.2 of~\cite{amd64-abi}).

% dpm: not needed now due to Lem being briefly introduced in the introduction
%\subsection{The Lem language}
%\label{subsect.rigorous.lem.specification}

%We use the Lem specification language~\cite{mulligan-lem-2014} to specify our model of the ELF file format and linking.
%Lem provides a lightweight language of (polymorphic) definitions, types and pure functions that can be seen both as mathematical definitions and pure functional programs.
%Lem typechecks definitions and then, subject to constraint, export them to executable OCaml code, proof assistant theories for HOL4~\cite{slind-brief-2008}, Isabelle/HOL~\cite{wenzel-isabelle-2008} and Coq~\cite{bertot-short-2008}, or typeset HTML and LaTeX.

%The Lem type system and libraries include bounded and unbounded integers and naturals, tuples, records, function types, sets, dictionaries, and user-defined types with top-level polymorphism.
%The expression language combines pure functional programming features (functions, pattern matching, and so on) with simple higher-order logic, including bounded quantification and set comprehensions.

Our ELF model provides types describing the concrete structure of an ELF file on disk along with more abstract types for ease of manipulation of a file's contents.
Functions for parsing and blitting files to lists of bytes and for interpreting the structural elements of a file are provided.
For example, functions are provided for the decoding of the section header string table, or producing a containment mapping of sections in segments.
Platform-specific logic is kept separate from the main body of the formalisation via the use of higher-order functions, with ABI- or \texttt{GNU}-specific logic handled by function arguments.
The formalisation consists of 9~500 lines of commented Lem code for core ELF, with approximately 2~000 lines for the \texttt{GNU} extensions and 4~000 lines for the AARCH64, AMD64, IA32 and Power64 platform ABIs.

The formal ELF model is currently in use in the \texttt{ppcmem2} tool~\cite{gray-integrated-2015}, a tool for exploring weak-memory behaviour on Power64, and is used to extract an executable process image from binaries, along with the initial values of global variabes, to generate and initial machine state for the emulator.

\subsection{Validation}
\label{subsect.elf.validation}

We validated our model against a wide-range of ELF executable and linkable binaries on multiple machine architectures.
Validation was conducted using two widely-deployed and mature \texttt{GNU} tools---\texttt{hexdump} and \texttt{readelf}---as trusted oracles against a set of validation binaries.
On AARCH64, AMD64, IA32 and Power64 we tested against 576, 1650, 3222, and 1606 binaries, respectively---7054 in total, obtained from \texttt{/usr/bin} and \texttt{/usr/lib} on typical Linux distributions for the latter three platforms, and the contents of \texttt{/system/bin} and \texttt{/system/lib} of an Android~5.1.1 smartphone for ARM.

Using our model we wrote a tool that emulated a subset of \texttt{readelf}'s functionality.
Using an automated \texttt{diff} tool, the output of the real \texttt{readelf} was compared with the output of our tool on the validation binaries, testing the parsing and decoding of the file-header, section header table, program header table, dynamic section, relocation sections, and symbol and string tables.

Using \texttt{hexdump}, a `roundtripping' property of the parsing and blitting functions was also validated, ensuring that parsing and then immediately blitting a binary preserved byte-for-byte compatibility with the original file.
This requires the tracking of `dead' data in between the structural elements of a file to ensure that the byte-for-byte condition holds.

Validating the model against binaries found `in the wild' on real machines revealed many sources of incompleteness in the various source specification documents.
For example, constructions relating to the ELF prelinker, such as the dynamic section type \texttt{DT\_GNU\_PRELINKED} are found in a large number of deployed ELF binaries, yet are not mentioned in any specification document, being mentioned only in passing in mailing list messages (see e.g.~\cite{jelinek-prelinker-2001}), and prior to validation were unknown to us.

One of our aims with this work is to create a comprehensive, validated set of definitions suitable for software verification purposes, serving as a foundation for further work in the area.
Toward this end we have extracted Isabelle/HOL theory files from our Lem source model, and provided hand-written termination proofs for recursive functions and various other lemmas.
HOL4 and Coq theories are in preparation.
The extraction to Isabelle/HOL and subsequent proofs revealed some bugs in the model that were not revealed by validation.

%\subsection{Theorem prover output}
%\label{subsect.theorem.prover.output}

%, corresponding to around 33~500 lines of commented Isabelle source.
%Approximately 1~500 lines of handwritten termination proofs for recursive functions, and various lemmas needed for the completion of the termination lemmas, are also supplied.
%With these we have demonstrated that, at least in principle, our definitions can be used for effective proof in theorem provers, though as is always the case these definitions may require modification when used for more significant proofs.
%HOL4 and Coq extractions of the the Lem source model will also be made available.
