\section{Formalising linking}

Building on this formalision of ELF, we can now formalise the operation of a linker,
including the relevant features of linker-speak.
We focus on static linking of executables for the moment.

\subsection{Overview}

Our formalisation takes the form of an executable specification that 
is both a linker and a link checker.

It is designed around the abstraction of \emph{memory images} and associated \emph{annotation} metadata.
Linking is expressed as a transformation of memory images.
Each input ELF file is represented abstractly as a partial memory image, consisting of 
collection of elements, mostly mirroring ELF sections.
Byte ranges within elements are labelled with metadata \emph{tags}, 
mostly mirroring ELF metadata such as symbols, relocations, and section properties.
At the end of the linking process, a single memory image is assembled,
which is transformed back into an ELF file.
%, with its elements
%forming the content and its metadata tags used to generate the symbol table, section headers
%and so on.

The link checker is invoked the same way as the emulated linker, supporting the same command-line options,
but with an output file (named with \textsf{-o}) that already exists.
The checker builds an output memory image---effectively performing its own link---checks consistency with the image
embodied by the actual output file.
(FIXME: also do post-load check: start the program up in a ptrace'd state 
and compare each word of the image?)
Currently the consistency check is a very tight equivalence, down to address assignments and bytewise content
(modulo any bytes marked as ``don't-care'' in the image, such as padding).
This is not inappropriate, since the very simplest link jobs are entirely deterministic.
We discuss which linker features introduce looseness in \S\ref{sec:looseness}.
The comparison also abstracts away from issues of how the output file was rendered into ELF: 
it compares only the embodied memory imag. 
Details such as the ordering of ELF symbols or section headers are not significant.

The notion of memory images generalises to \emph{symbolic} memory images, in which 
each memory image element's address and content may be expressed in terms of 
symbolic variables and unordered concatenations of fragments, rather than precise addresses
and bytes.
This approach potentially allows a family of possible links to proceed at once,
and accommodating the looseness inherent in checking for ``any valid link''.
Currently, however, only a relatively concrete representation of section contents has been specified, 
so the linker must operate concretely for any non-trivial link job.
To accommodate concrete variation among linkers, loose behaviour is factored into 
a family of ``personality functions'', allowing different linkers' choices to be 
captured independently of the core logic. 
At present, only the GNU linker personality is substantially developed.

%a reference implementation optimised for readability
%\and portability

% EXAMPLES of the liftable-out portions of the spec 
% e.g.\ detailing symbol binding.
% 
% a test oracle.
% 
% a basis for reasoning? WHAT can we argue here?
% 

% To allow per-linker divergences, 
% the linker is factored to invoke 
% linker ``personality functions'' corresponding to 
% the loosenesses identified earlier (\S\ref{sec:looseness})
% 
% \begin{itemize}
% 
% \item seen ordering
% 
% \item placing orphans
% 
% \item simplifying relocations
% 
% \item concretising padding etc.
% 
% \item concretising support features (order etc.)
% 
% \item ELF headers, program headers etc.
% 
% \end{itemize}

\input{hello}

\input{looseness}
