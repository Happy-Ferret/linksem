
\subsection{Looseness}
\label{sec:looseness}

%The basic operation of a linker is to concatenate inputs 
%into a new, combined output. 
%This sounds deterministic, and indeed, 
% For a given link job, why isn't the output memory image fully determined?
Linking is deterministic in simple cases.
For example, a link job controlled by a well-defined linker script
and whose input consists only of simple freestanding object files
will produce a deterministic memory image---unless it contains common symbols, 
orphan sections, section groups, mergeable sections, 
if the linker is required to insert padding
or generate non-trivial support structures.
In practice, nearly all link jobs have one or other of these properties.
Here we briefly consider

\paragraph{Output ordering}
When concatenating a collection of \textsf{.text} sections, say, 
the sections must generally be ordered by the order of the originating objects on the command line.
However, objects archive members are ordered in ``the order in which they are seen during the link'', 
an order determined by the linker's algorithm for traversing the dependency graph.
%For efficiency, 
%and to implement the rules for binding to archive members as a side-effect, 
This is typically neither a depth- nor breadth-first traversal of references,
but a traversal of \emph{definitions} in linker command-line order
combined with limited back-tracking 
(re-scanning from the start of the current archive whenever a new archive
member is included).
Alternative implementations are possible, so archive members may appear in different orders.
%this ordering may only be specified loosely.
The same ordering nondeterminism applies to common symbols.

\paragraph{Padding lengths and values}
When padding sections to satisfy alignment constraints, 
both the amount and the contents are not fully determined.
Superfluous padding is arguably not a bug, although not desirable; 
we filed a bug on the \textsf{gold} linker\footnote{%GNU binutils bug 18979
removed for blind review} inserting 
too much padding 
% superfluous padding, e.g.\ starting at a 16-byte-aligned address
% and adding a whole 16 bytes of padding
% before the next section of 16-byte alignment.
% It is unclear whether this is a bug; 
% we believe so (and have filed GNU binutils bug 18979 (FIXME: remove for blind review)).
Also, it is not specified what byte values a linker may use
to pad a section: in practice, they use zeroes for data and 
nop-sequences for code.
Nop-sequences have the advantage that control can flow between abutting sections
even in the presence of padding. 
Abutment is sometimes exploited: the GNU C library's initialization and finalization logic 
is split between \textsf{crti.o} and \textsf{crtn.o},
and control flows across the section boundary.
Padding such abutments with non-nop sequences would generate a bad link.
% (Fragmenting a single instruction across section boundaries
% is also conceivable, and would be broken by any kind of padding, 
% although we have never seen it.)
For an \textit{n}-byte pad, 
many choices of instruction may be available, 
depending on the instruction set.
%lengths of available nop instructions.

% Alignment constraints may be imposed 
% in two ways: when input sections are appended to an output section, 
% each with its own alignment; 
% and when one output section is ended and another begins.
% Both cause padding bytes to be inserted. 
% In the former case, the linker chooses the greatest alignment of all input sections
% that make up the output section.
% In the latter case, the linker inserts padding before beginning a fresh output section.
% In general, superfluous padding is not an error, but 
% is wasteful.
% Our specification outlaws this waste, 
% by taking the view that the minimum amount be the only allowable amount.
% Unfortunately, 

\paragraph{Relocation, instruction selection and merging}
As covered in \S\ref{sec:hello}, 
linkers are free to optimise certain relocations, sometimes replacing instructions.
They are also free to merge mergeable sections, or not.

% \paragraph{Section padding contents}

% However, sequences containing multi-byte instructions may affect program semantics
% on ISAs with variable-length instruction encodings, 
% if the program can be caused to jump into the middle of the sequence,
% in which case they are no longer a nop.
% It is important that any such sequence \emph{starting at any byte}
% has either fall-through or trap semantics
% according to the host ISA.

\paragraph{Segment padding}
At boundaries between segments (a.k.a.\ memory mappings), 
the linker's address assignment algorithm 
faces trade-offs about disk space (zeroes in the output file)
and memory (wasted space in mapped pages).
The GNU linker script language's 
\textsf{ALIGN\_DATA\_SEGMENT} feature 
inserts an amount of padding calculated to optimise this trade-off.
Our specification revealed an inconsistency between the GNU linker's 
manual and behaviour, filed as a bug\footnote{%Binutils bug 19203
removed for blind review} and promptly fixed.

% \paragraph{Common symbol placement}
% Linker scripts control all common symbols at once.
% % Some ABIs also define ``large common''.
% The order in which  of individual common symbols
% is not provided.
% Link order is the obvious choice, but cannot be assumed: FIXME do we really see this (I think so)?

\paragraph{``Link once'' or section group selection}
Sections that are members of section groups (\S\ref{sec:section-group}) compose differently
from ordinary linker inputs:
there can be only one instance in the output, no matter how many times
a section group is repeated in the input.
The choice of which to discard is left to the linker.

% \paragraph{Linker script}
% It is permissible for a linker not to accept control scripts.
% In this case, its behaviour is much more hard-coded,
% and much more subject to arbitrary variation.
% The \textsf{gold} linker does not accept control scripts, 
% but its hard-coded behaviour tries to emulate the default control scripts of the GNU linker
% (which are themselves programmatically generated at build time).
% It is hard to argue that the GNU linker's script is definitive; 
% in practice, a linker not accepting a linker script
% adheres to looser criteria equating to ``any sensible script''.
% In general, the minimum sensible 
% behaviour is to preserve (rather than discard) allocatable sections, 
% preserve and transform ABI-defined metadata to retain consistency with the output data,
% and abstain from inserting arbitrary additional information
% except in ABI-prescribed sections (which should be non-allocatable).  (CHECK for exceptions to either of these.)
% Of course, custom linker scripts can deviate from these sensible defaults,
% so they are not a requirement imposed on all linkers per se.

\paragraph{Orphan section placement}
Sections not matched by any clause in the linker script are still included in the output.
They can be placed in any output section having suitable flags; the choice is left to the linker.

% \paragraph{Section merging}
% ``SHF\_MERGE is an optional flag indicating a possible optimization. The link-editor is allowed to perform the optimization, or to ignore the optimization. 
% (from the Oracle guide; in Sys V docs?)

\paragraph{Linker-generated structures}
The GOT, PLT and other run-time structures (\S\ref{sec:got-plt}) 
are effectively lists, whose order is arbitrary. 
Link order is not enforced.
In practice, the order adopted often reflects the linker-internal hash table implementation.
% might reasonably be assumed, but is not specified.

\paragraph{Relaxation}
%Conceptually, linkers do not know about instruction encodings.
%Relocations describe how to fix up input files' contents at the byte level,
%without reference to what fixed-up instructions mean.
As we have seen, most linkers do in fact
know a little about instruction encoding, even if conceptually they need not.
%They use this knowledge to optimise output sections
%for size and/or execution speed, by
A family of linker optimisations known as ``relaxations'' 
can rewrite content at relocation site (choosing a shorter calling sequence, say) 
and section boundaries (overlapping leading and trailing padding in exception
handling information, say).

\paragraph{Phase anomalies} 
A linker necessarily makes multiple passes over its inputs.
Passes include enumerating inputs, calculating output section layout, 
calculating addresses, applying relocations, and so on.
Some linker features interact in ways which induce circular dependencies between
these passes, which the linker resolves in arbitrary and often undocumented ways.
One example is input enumeration: to identify which archive members
to include in a link, the linker searches archives for definitions
of the symbols required by other input objects.
However, the linker script might subsequently provide its own definition
for such a symbol, obviating the need for definitions that were (perhaps transitively) pulled in.
Whether they are removed from the link is an undocumented detail; 
in in our experience they are not.
%tend not to be.
% all linkers we know of, they are not. (FIXME: check this.)
% However, linker phases could be restructured so that they are never pulled in at all.
% Another example is in placement of linker-generated structures like the global offset table (GOT). 
% Placement of the GOT is controled by the linker script,
% meaning it must be sized when the script runs.
% The same definition-obviation behaviour might remove all via-GOT references
% to a given symbol, hence obviating the need for its slot, meaning the size
% should be recomputed after script processing, meaning the address-assignment phase
% should be re-run. 
% Again, real linkers do not do this recomputation.
% If they did, it need not converge to a fixed point, since linker script behaviour
% may depend on section sizes and hence create an oscillation.
% (FIXME: I thik it might also create a via-GOT reference
% to a previously non-GOTted symbol, which would make life interesting.
% Not yet sure if linker scripts can set up such a reference though.)

