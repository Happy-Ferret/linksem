
\subsection{Looseness}
\label{sec:looseness}

The basic operation of a linker is to concatenate inputs 
into a new, combined output. 
This sounds deterministic, and indeed, linking is deterministic in simple cases.
For example, a link job controlled by a well-defined linker script
and whose input consists only of simple freestanding object files
will be deterministic---unless it contains common symbols, 
orphan sections, section groups, mergeable sections or similar features,
or if the linker is required to insert padding.
In practice, nearly all link jobs have one or other of these properties.

\paragraph{Output ordering}
Archive members are ordered in ``the order in which they are seen during the link''.
This means the order is determined by the linker's algorithm for
traversing the dependency graph. 
For efficiency, 
and to implement the rules for binding to archive members as a side-effect, 
this is typically neither a depth- nor breadth-first traversal of references,
but a traversal of \emph{definitions} in linker command-line order
combined with limited back-tracking 
(re-scanning from the start of the current archive whenever a new archive
member is included).
Of course, alternative implementations are possible, 
so this ordering may only be specified loosely.

\paragraph{Section padding amount}
Alignment constraints may be imposed 
in two ways: when input sections are appended to an output section, 
each with its own alignment; 
and when one output section is ended and another begins.
Both cause padding bytes to be inserted. 
In the former case, the linker chooses the greatest alignment of all input sections
that make up the output section.
In the latter case, the linker inserts padding before beginning a fresh output section.
In general, superfluous padding is not an error, but 
is wasteful.
Our specification outlaws this waste, 
by taking the view that the minimum amount be the only allowable amount.
Unfortunately, we have seen cases where the \textsf{gold} linker inserts
superfluous padding, e.g.\ starting at a 16-byte-aligned address
and adding a whole 16 bytes of padding
before the next section of 16-byte alignment.
It is unclear whether this is a bug; 
we believe so (and have filed GNU binutils bug 18979 (FIXME: remove for blind review)).

\paragraph{Section padding contents}
It is not specified what byte values a linker may use
to pad a section.
In practice, linkers use zeroes for data and either zeroes or nop-sequences for code.
Nop-sequences have the advantage that control can flow between abutting sections
even in the presence of padding; 
it is not uncommon to invoke this behaviour, 
for example 
the GNU toolchain's process initialization and finalization logic 
is split between \textsf{crti.o} and \textsf{crtn.o},
and control flows across the section boundary.
Inserting null bytes between these sections would generate a bad link.
(Fragmenting a single instruction across section boundaries
is also conceivable, and would be broken by any kind of padding, 
although we have never seen it.)
For an \textit{n}-byte nop-sequence, 
many choices of instruction may be available, 
depending on the lengths of available nop instructions.

% However, sequences containing multi-byte instructions may affect program semantics
% on ISAs with variable-length instruction encodings, 
% if the program can be caused to jump into the middle of the sequence,
% in which case they are no longer a nop.
% It is important that any such sequence \emph{starting at any byte}
% has either fall-through or trap semantics
% according to the host ISA.

\paragraph{Segment padding amount} 
The GNU linker features an optimisation
that tries to optimise disk-memory trade-offs.
It seems reasonable to specify that 
wasteful padding should not be inserted, but 
no single trade-off is always appropriate.
LINK to binutils bug 19203 (REMOVE for blind review).

\paragraph{Common symbol placement}
Linker scripts control all common symbols at once.
Some ABIs also define ``large common''.
Control of the ordering of individual common symbols
is not provided.
Link order is the obvious choice, but cannot be assumed: FIXME do we really see this (I think so)?

\paragraph{``Link once'' or section group selection}
Like common symbols, 
sections that are members of section groups compose differently
from ordinary linker inputs:
there can be only one instance in the output, no matter how many times
a section group is repeated in the input.

\paragraph{Linker script}
It is permissible for a linker not to accept control scripts.
In this case, its behaviour is much more hard-coded,
and much more subject to arbitrary variation.
The \textsf{gold} linker does not accept control scripts, 
but its hard-coded behaviour tries to emulate the default control scripts of the GNU linker
(which are themselves programmatically generated at build time).
It is hard to argue that the GNU linker's script is definitive; 
in practice, a linker not accepting a linker script
adheres to looser criteria equating to ``any sensible script''.
In general, the minimum sensible 
behaviour is to preserve (rather than discard) allocatable sections, 
preserve and transform ABI-defined metadata to retain consistency with the output data,
and abstain from inserting arbitrary additional information
except in ABI-prescribed sections (which should be non-allocatable).  (CHECK for exceptions to either of these.)
Of course, custom linker scripts can deviate from these sensible defaults,
so they are not a requirement imposed on all linkers per se.

\paragraph{Orphan section placement}
Sections not matched by the linker script can be placed anywhere
having suitable flags.

\paragraph{Section merging}
``SHF\_MERGE is an optional flag indicating a possible optimization. The link-editor is allowed to perform the optimization, or to ignore the optimization. 
(from the Oracle guide; in Sys V docs?)

\paragraph{Linker-generated structures}
GOT, PLT and other run-time structures

\paragraph{Relaxation}
Conceptually, linkers do not know about instruction encodings.
Relocations describe how to fix up input files' contents at the byte level,
without reference to what fixed-up instructions mean.
However, for optimisation purposes, most linkers do in fact
know a little about instruction encoding.
They use this knowledge to optimise output sections
for size and/or execution speed, by ``relaxing'' contents
at reference points (choosing a shorter calling sequence, say) 
and section boundaries (overlapping leading and trailing padding in exception
handling information, say).

\paragraph{Phase anomalies} 
A linker necessarily makes multiple passes over its inputs.
Passes include enumerating inputs, calculating output section layout, 
calculating addresses, applying relocations, and so on.
Some linker features interact in ways which induce circular dependencies between
these passes. 
Linkers resolve these in arbitrary and often undocumented ways.
One example is input enumeration: to identify which archive members
to include in a link, the linker searches archives for definitions
of the symbols required by other input objects.
However, the linker script might subsequently provide its own definition
for such a symbol, obviating the need for definitions that were (perhaps transitively) pulled in.
Whether they are removed from the link is an undocumented detail; 
in all linkers we know of, they are not. (FIXME: check this.)
However, linker phases could be restructured so that they are never pulled in at all.
Another example is in linker-generated structures like the global offset table (GOT). 
The memory placement of the GOT is controllable in the linker script,
meaning it must be sized when the script's interpreter runs. 
The same definition-obviation behaviour might remove all via-GOT references
to a given symbol, hence obviating the need for its slot, meaning the size
should be recomputed after script processing, meaning the address-assignment phase
should be re-run. 
Again, real linkers do not do this recomputation.
If they did, it need not converge to a fixed point, since linker script behaviour
may depend on section sizes and hence create an oscillation.
(FIXME: I thik it might also create a via-GOT reference
to a previously non-GOTted symbol, which would make life interesting.
Not yet sure if linker scripts can set up such a reference though.)

