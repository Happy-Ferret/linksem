\subsection{Linking \texttt{hello}}
\label{sec:hello}

In the C programming language, a ``hello, world!'' program is among the simplest possible.
However, for a linker, such a simple program amounts to a complex job,
since it links with the C library---often the most complex library on the system,
in terms of the linker features it exercises.

In this section we outline what happens when a hello-world C program, compiled with \textsf{gcc} 
for the x86-64 architecture,
is linked against uClibc\footnote{\url{http://uclibc.org/}}, 
a fully-featured C library slightly simpler than the system-default GNU C library.
% At each point we describe the relevant features of our formalisation

\paragraph{Parse command line}
This stage is responsible for identifying input files and link options.
The command for linking a hello-world program, slightly simplified to omit directory names, 
is as follows.

\begin{lstlisting}[language=plain,basicstyle=\footnotesize\ttfamily]
ld -m elf_x86_64 -static -o hello crt1.o crti.o crtbeginT.o \
   hello.o --start-group -lgcc -lc --end-group crtend.o crtn.o 
\end{lstlisting}

Options beginning \textsf{-lX} say ``look up library \textsf{libX} on the library search path'', 
and denote input files; they resolve to files \textsf{libgcc.a} and \textsf{libc.a}.
Only \textsf{hello.o} came from compiling the program;
the other files have been supplied by the compiler (\textsf{libgcc.a}, \textsf{crt\{1,i,n\}.o})
and C library (\textsf{libc.a}, \textsf{crt\{beginT,end\}.o}).
Other options are modifiers to the link; some apply to the whole link 
(like \textsf{-m~elf\_x86\_64}, selecting x86-64 output)
whereas others affect only the input files that follow them, or until negated 
(here \textsf{--start-group} and \textsf{--end-group}).\footnote{Confusingly, \textsf{-static} is 
also of this kind: if any \textsf{-lX} options preceded it, they might be linked dynamically, meaning the output
would \emph{not} be statically linked.}
``Groups'' of archives affect symbol resolution: within a group,
symbols may be resolved cyclically, whereas outside a group, 
references from archives only bind to objects appearing earlier in command-line order.\footnote{This
behaviour dates from a time when unnecessarily scanning archives would create
noticeable link-time slowdowns.}
Many modifiers cancel preceding ones or the relevant defaults 
(such as \textsf{-Ttext} which sets the output text section address), 
but others add content every time they are invoked
(such as \textsf{--defsym~name=expr}, which defines a new symbol).

The command line formalisation is structured as an interpreter, whose state 
is the collection of input files together with the currently active modifiers.
It is parameterised by a large list of option definitions, 
each incorporating the option syntax and also its semantics as a function from state to state.
The table (see Fig.~\ref{fig:command-line}) resembles the linker's \textsf{--help} text, expanded
with semantics for each option.
Arguments not matching any list entry are treated as input files, cloning the current per-input-file modifiers.
Complex options such as \textsf{--push-state} exist, requiring that a state include both a current value and a stack of previously saved values.

\begin{figure*}
\begin{lstlisting}[language=plain,basicstyle=\scriptsize\sffamily]
let command_line_table = [
  (["-o"; "--output"],       (["FILE"], []), fun args -> set_or_replace_opt (OutputFilename(head (fst args))), "Set output file name");
  (["-Bsymbolic-functions"], ([], []),       fun args -> set_or_replace_opt (BindFunctionsEarly), "Bind global function references locally");
  (["-Ttext-segment"],       (["ADDR"], []), fun args -> set_or_replace_opt (TextSegmentStart(parse_addr (head (fst args)))), "Set address of text segment");
  (["-("; "--start-group"],  ([], []),       fun _ ->   (fun state -> start_group state), "Start a group");
  (["-)"; "--end-group"],    ([], []),       fun _ ->   (fun state -> end_group state), "End a group");
  (* ... *)
]
\end{lstlisting}
\caption{Excerpt from the specification of GNU linker command-line options}
\label{fig:command-line}
\end{figure*}

\paragraph{Resolve symbols to objects} 
Although only eight files appear in the command, the two archives contain a total of 891 objects.
To discard those that are unneeded, the linker next resolves symbol references between all 897 objects.
The semantics of symbol resolution are complex, since 
it matters whether an object file came from an archive, and, if so, 
whether the referencing object appeared to the left or right of that archive on the command line.
Our semantics is factored into an ``eligibility predicate'' answering whether a given
reference can bind to a given definition, and an 
ordering on eligible definitions such that
the first eligible definition is the intended referent.
The ordering is based on command-line order, but also accounts for the semantics of 
substitution: definitions in relocatable files take precedence over archives, hence 
providing the semantics necessary for the \textsf{malloc.o} substitution example (\S\ref{sec:substitution}).
Once all symbol references are resolved, any unreferenced objects can be excluded.
In our case, this leaves 61 objects in the link.

% these amount to Having collected a set of input files, the options applying to each,
% and the global link options, 
% we inspect the input files to reveal their structure.
% Each input file might be an object file, an archive or a linker script
% (or, with dynamic linking support, a shared object).
% The semantics of symbol resolution is different in each case,
% so even after enumerating the contents of an archive, we must remember
% which symbol-resolution behaviour is associated with it.
% In practice, for error reporting, we remember all details of the originating archive.
%     let def_is_eligible = (fun (def_idx, def, def_linkable) -> 
%         let ref_is_unnamed = (ref.ref_symname = "")
%         in
%         let ref_is_to_defined_or_common_symbol = ((natural_of_elf64_half ref.ref_syment.elf64_st_shndx) <> stn_undef)
%         in
%         let def_sym_is_ref_sym = (ref_idx = def_idx && ref.ref_sym_scn = def.def_sym_scn
%             && ref.ref_sym_idx = def.def_sym_idx)
%         in
%         let (def_obj, (def_fname, def_blob, def_origin), def_options) = def_linkable
%         in
%         let (def_u, def_coords) = def_origin
%         in
%         let (def_in_group, def_in_archive) = match def_coords with
%               InArchive(aid, aidx, _, _) :: InGroup(gid, gidx) :: [_] -> (Just gid, Just aid)
%             | InArchive(aid, aidx, _, _) :: [_]                       -> (Nothing, Just aid)
%             | InGroup(gid, gidx) :: [_]                              -> (Just gid, Nothing)
%             | [_]                                                    -> (Nothing, Nothing)
%             | _ -> failwith "internal error: didn't understand origin coordinates of definition"
%         end
%         in
%         let ref_is_leftmore = ref_idx <= def_idx
%         in
%         (* For simplicity we include the case of "same archive" in "in group with". *)
%         let ref_is_in_group_with_def = match def_in_group with 
%               Nothing -> false
%             | Just def_gid -> 
%                 match ref_coords with
%                   InArchive(_, _, _, _) :: InGroup(gid, _) :: [_] -> gid = def_gid
%                 | InGroup(gid, _) :: [_]                       -> gid = def_gid
%                 | _ -> false
%                 end
%             end
%         in
%         (* but maybe same archive? *)
%         let ref_and_def_are_in_same_archive = match (def_coords, ref_coords) with
%             (InArchive(x1, _, _, _) :: _, InArchive(x2, _, _, _) :: _) -> x1 = x2
%             | _ -> false
%         end
%         in
%         let def_is_in_archive = match def_in_archive with
%             Just _ -> true
%             | Nothing -> false
%         end
%         in
%         if ref_is_to_defined_or_common_symbol then def_sym_is_ref_sym
%         else 
%             if ref_is_unnamed then false
%             else
%                 if def_is_in_archive
%                 then
%                     (not ref_is_weak) 
%                     && (
%                            ref_is_leftmore
%                         || ref_and_def_are_in_same_archive
%                         || ref_is_in_group_with_def
%                     )
%                 else 
%                     true
%     )


\paragraph{Generate support structures}
The linker is responsible for generating the support structures used by different code models.
In most ABIs, these include the GOT (global offset table; a table of pointers) and PLT 
(procedure linkage table; a table of trampolines).
These are used for indirect addressing, when code compiled with narrow addressing modes
must reach definitions which might be located far away.
Although in principle they exist only to serve position-independent code models (\S\ref{sec:code-models}), 
various orthogonal features have been specified so as to use them 
(notably thread-local storage and GNU \textsf{IRELATIVE} relocations)  
so even non-position-independent code requires them.
The linker remains oblivious to the particulars of the models;
but must generate the GOT and PLT according to the relocations in the input.
%(These relocations implicitly embody a code model, since under a different code model,
%the compiler would have selected different instructions with different relocations.)
For example, it generates a GOT consisting of one entry 
for each distinct symbol definition that is used in a GOT-based relocation.\footnote{Mismatch 
of code models happens when input code uses addressing modes which cannot reach far enough 
to point to the addresses assigned by the linker.
In such cases, the linker's relocation calculations overflow, the overflow is detected
and the link is aborted.
This is most common when the linker is deferring bindings until dynamic link time: 
any deferred binding must be assumed to be potentially located far away,
so 32-bit addressing are not wide enough unless indirected via a local GOT or PLT.
On seeing a reference not relocated this way, 
the linker aborts with the infamous ``recompile with \textsf{-fPIC}'' message.}
% (although it is the input code's code model that determines which references these are).
A final complication is that although support structures are a function of the overall link contents,
they must be generated early, \emph{before} the linker script runs, 
because the linker script expects control over where they get placed.
This is dealt with in ad-hoc ways; for example, the GNU linker
pretends that these structures reside in the first input object on the command line.
% This is a nasty hack in GNU (magic sections appear on the first input file), 
Since our \textsf{libc.a} uses thread-local storage (TLS) ABI extensions,
and our input objects make use of it (for \textsf{errno}, which is set by \textsf{printf()}),
many of the GOT slots we generate are used to support run-time machinery for thread-local storage,
and we must also support TLS relocations (below).

\paragraph{Optimise relocations and instructions} 
Immediately before generating these support structures, 
many linkers apply optimisations the relocations and, in some cases,
to the instructions that use them.
For example, in our \textsf{hello} link, 
to avoid use of the GOT when static-linking, the GNU linker will turn 
the following \textsf{mov}, which loads an address from the GOT

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=fixed,language=plain]
48 8b 05 00 00 00 00      mov    0x0(%rip),%rax
         `---------' to be relocated: 
                     R_X86_64_GOTPCREL   __libc_stack_end-0x4
\end{lstlisting}

into the following \textsf{lea} which calculates it directly.

\begin{lstlisting}[basicstyle=\footnotesize\ttfamily,columns=fixed,language=plain]
48 8d 05 3d 1e 20 00      lea    0x201e3d(%rip),%rax
         `---------' applied relocation:
                     R_X86_64_PC32       __libc_stack_end-0x4
\end{lstlisting}

The ABI documentation includes a list of other ``standard'' optimisations that may be applied. 
A linker is free to use them or not.\footnote{\ldots{} the newer \textsf{gold} linker 
does not currently apply them.}
Our model currently lacks knowledge of the instruction set architecture, so does not capture these optimisations.
Since the GNU linker does not currently provide any way to disable these optimisations
(even when supplying options intended to disable optimisations).
we diverge from it here: our GOT will contain more slots,
subsequent address assignments will be skewed,
and more instructions will indirect via the GOT.
% (We can, however, generate working output.)

\paragraph{Compose output sections} The main pass over the linker control script
assigns input sections to output sections.
The default linker script is 226 lines long.
Our formalisation defines the linker script language's abstract syntax in Lem,
using Lem for arithmetic and pattern-matching logic.
For example, a fragment of the original linker script

\begin{lstlisting}[basicstyle=\scriptsize\sffamily,language=plain]
.preinit_array     :
{
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP ( *(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
}
\end{lstlisting}
  
becomes the following.

\begin{lstlisting}[basicstyle=\scriptsize\sffamily,language=plain]
OutputSection(AlwaysOutput, Nothing, ".preinit_array", [
    DefineSymbol(IfUsed, "__preinit_array_start", hidden_sym_spec)
  ; InputQuery(KeepEvenWhenGC, DefaultSort, filter_and_concat (
        fun s -> name_matches ".preinit_array" s))
  ; DefineSymbol(IfUsed, "__preinit_array_end", hidden_sym_spec)
])
\end{lstlisting}

Section composition is mostly concatenation, but ELF section flags can mark sections as mergeable.

Most commonly these are sections containing strings, signified by an additional section flag.
Again, it is up to the linker whether or not sections are merged.
FIXME: hmm, we don't merge yet.
Symbol definitions made in the script can \emph{substitute} (\S\ref{sec:substitution}) for definitions 
in the input files. (This means that the reachability calculation
used to discard unwanted inputs was not definitive: it may have included
some objects that are no longer needed, since the relevant bindings were altered .
script execution.)

% (optional) discard unreferenced sections
\paragraph{Garbage collection} To provide a finer-grained 
removal of unwanted input, and to compensate for the problem that, as we noted,
the initial reachability calculation is subject to invalidation, 
the command line may request an additional garbage collection pass (\textsf{--gc-sections}).
This also entails delaying address assignment, to avoid allocating addresses for sections
that will be collected.
Normally \textsf{--gc-sections} is not used, and we currently do not model it.

\paragraph{Assign addresses to symbols} Another pass over the linker script now
assigns addresses to output sections. 
Addresses can be computed explicitly in the script using arithmetic, and can depend on the size
and address of any section placed earlier in the script. 
By default, addresses are computed using a location counter
that is automatically incremented, rounded up to account for the section alignment specified in the input files.

\paragraph{Apply relocations} Once addresses have been assigned, relocations can be applied.
This is actually where linking happens. 
265 relocations of six different kinds (\texttt{32}, \texttt{32S}, \texttt{GOTPCREL}, 
\texttt{GOTTPOFF}, \texttt{PC32}, \texttt{PLT32}).
Of these, \texttt{GOTTPOFF} is a thread-local relocation.

\paragraph{Generate output} Finally, we have a relocated memory image.
We can compare this against the input \textsf{hello} object; this comparison fails
because the GNU linker has altered some instructions (and generated a smaller-than-expected GOT).
Our image nevertheless otherwise corresponds very closely to the GNU linker output; 
it can be serialised straightforwardly into an output ELF file and executed with identical
semantics.
