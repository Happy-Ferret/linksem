\section{Introduction}

Programming language research focusses largely on the source-language
semantics of programs and their compilation to machine code, as do the
vast majority of programmers.
But, under the hood, much real code crucially depends on complex
\emph{linker behaviour} to work as intended:  as we shall see, even statically linking
a \texttt{hello\_world.c} program with a C library turns out to be
remarkably subtle.  
%
% PS: starting from here (though I can see it's quite SKish) seems a
% bit backwards, forcing attention on the binaries and *then* asking
% the reader to imagine where they come from.
%Real programs consist of binary instructions, and data, executing on a machine.
%How these binaries are \emph{linked} has a crucial influence on their semantics.
Unlike compilation, the linking process remains largely invisible and
poorly studied, % understood 
for programmers and researchers alike.

Consider, for example, the familiar C \textsf{malloc()} and \textsf{calloc()}
functions in Fig.~\ref{fig:glibc-malloc}, abstracted from their GNU C
library implementation.
What does this code do?
Looking just at the function definitions from a C-language point of view, it ``obviously'' implements 
\textsf{\_\_libc\_malloc} and \textsf{\_\_libc\_calloc} using a third
internal helper function \textsf{\_int\_malloc()}.
%
But this is not actually true: those two functions are not guaranteed
to always call the helper as defined in this file.  
%
Then C has no notion of aliases, 
but the code depends on these for defining \textsf{malloc} and \textsf{calloc}.
What happens if the user supplies their own \textsf{malloc}, as many
programs do?  What other definitions does the file export?

%What are the two functions called? 
%Do they always call the helper as defined in the file?
%
%
%PS not sure we can argue ``cannot'' answer...
Conventional source-language semantics do not attempt to address these
questions, and in practice
%---or if it does so, it does so wrongly.
%C has no notion of aliases, but the code depends on these for defining \textsf{malloc}.
linker features are used to control name binding and symbol
visibility, among many other things. 
%---in fact there is no guarantee that the \textsf{\_int\_malloc()} calls will land within this file.
Many tools and libraries rely on the ability to replace or interpose on bindings.
%, or that calls to \textsf{malloc()} elsewhere in the same librarywill actually bind to this \textsf{malloc()}.
This is not a fringe issue: a large fraction of real codebases rely on
linker features to realise their intended semantics, especially codebases lower in the stack. 
A typical Unix system kernel (e.g.~Linux) and core libraries (e.g.~\textsf{glibc}) make considerable use of such features.
%, while many program binaries do likewise.
To say anything about the correctness of these binaries requires
understanding linking in detail. 
% PS: these two cites seem to be off the point to me
%traditional source-level analyses (e.g.~\cite{hoare-axiomatic-1969, reynolds-separation-2002}) are not sufficient.
%, unless or until they have been augmented to account for linking.

\begin{figure}[t]
%PS got rid of the comment syntax - visually heavy, and no need for
%this to be that literally syntactically valid C
\begin{lstlisting}[language=C,basicstyle=\footnotesize\sffamily,columns=flexible]
void* _int_malloc(mstate av, size_t bytes)
  { ... }
void* __libc_malloc(size_t bytes)
  { ...
    void *mem = _int_malloc(av, sz);
    ...
  }
void* __libc_calloc(size_t bytes)
  { ...
    void *mem = _int_malloc(av, sz);
    ...
  }
strong_alias (__libc_malloc, __malloc) 
strong_alias (__libc_malloc, malloc)
strong_alias (__libc_calloc, __calloc) 
weak_alias (__libc_calloc, calloc)
\end{lstlisting}
\caption{Outline of the GNU C library's \textsf{malloc} and \textsf{calloc}}
\label{fig:glibc-malloc}
\end{figure}

In other words, much software is not written merely in a programming
language like C, 
%or even Haskell (linked by the system linker), 
but also in `linker speak'---our term for the collection of languages by which the linker is invoked and controlled.
These include the linker command-line, metadata contained within object files, assembler and compiler directives that generate that, and in fact an entire script language used exclusively by the linker.
%
Linker-speak is currently specified haphazardly or not at all.
As a result it is often used incorrectly or without developer understanding, often in unportable or fragile ways.
Linkers are seldom well-tested, and for many purposes, the implementation is its own oracle: unlucky developers grappling with corner-case behaviour must simply work with (or around) the linker's observed behaviour.
Both users and implementers lack any recourse to a reference, standard or specification. 


The challenge of verified toolchains makes these problems even more acute: existing
approaches to verified compilation typically do not address linking at
all, or address only the aspects
of linking that \emph{can} be understood in terms of a conventional
source-language semantics, and other previous semantic work on linking
has studied it only in a highly idealised form. But 
truly accounting for linking must rest on accurate modelling of a large, usable subset of its features.

In this paper, we describe the first detailed, accurate formal semantics for linking. 
Our semantics covers a large fraction of contemporary Unix linker features, and tightly models the behaviour of widely-used existing linkers on realistic link jobs.
Our research contributions are as follows.

\begin{verytightitemize}
\item
We review and clarify the roles played by linking and loading in mainstream systems, emphasising
how linkers are not merely concerned with separate compilation, but rather that ``linker-speak'' has real semantic effects.
Linkers complement and supplement programming languages, offering
features such as memory layout control, versioning and interposition
that are not exposed by programming languages. % (and arguably ought not to be).
%PS I guess this paper is not making the ``arguably ought not to be''
%argument


\item As a foundation for the semantics of linking on modern Unix
  platforms, we describe a complete, validated  model of the
  Executable and Linkable (ELF) binary file format as it is really
  used---derived from the System~V ABI
  specification~\cite{elf-sco-model}, as extended by four platform ABIs
  for popular commodity microprocessor families (AARCH64, AMD64, IA32
  and Power64), and additionally incorporating various extensions,
  notably the widely-used GNU extensions.  
We validate this by testing on 7054 binaries found in the wild.
To our knowledge this is the first formal model of a realistic and
widely-used linking and executable format, and the first formal
elucidation of components of the platform ABI.  It can be (and already
has been) used as a front-end for other tools that need to read in ELF
files, e.g.~\cite{gray-integrated-2016,FP16}.

\item Using this model, we describe an executable specification of static linking of ELF binaries.
%PS added ``much of'' - but can we be more specific about what we
%don't do?
This includes the link-time semantics for much of the plethora of ELF features, 
together with the linker command line and the embedded linker script language
that controls linker operation.  It is sufficiently complete to
statically link that 
\texttt{hello\_world.c}.
We do not currently cover dynamic linking.
\ps{this isn't all really true...}
Our specification can be used in many modes: 
as a link-checker validating existing linker output; 
as an actual linker producing working output; 
and as a readable reference implementation capturing the semantics of ELF features; 
and as a basis for proof-assistant mechanised reasoning about
linking. 
\end{verytightitemize}
Our models of ELF files and of static linking 
are expressed as pure functional specifications in
Lem~\cite{mulligan-lem-2014}, which we use to generate both executable
OCaml code and theorem-prover definitions for reasoning.  We have
produced a complete Isabelle/HOL version of our definitions, comprising 33\,500 lines of
commented Isabelle source and approximately 1500 lines of handwritten
termination proofs for recursive functions, and work on HOL4 and Coq
versions is ongoing.  
This demonstrates that formal reasoning about our models is possible
in principle, and as a small example we have formally stated (but not
proved) the
correctness of AMD64 linker relocation w.r.t.~an Isabelle/HOL
machine-code semantics produced from Fox's L3 model~\cite{DBLP:conf/itp/Fox15}.
Larger developments may (as usual) require
reformulating some of the definitions for ease of proof.  
Our Lem source, executable OCaml, and theorem-prover definitions will be made available. 




This work may be of use to four quite disparate communities:
\begin{verytightitemize}
\item developers of new or existing linkers, who may use our model as a trusted external test oracle, both for link correctness and some aspects of ABI compliance.
\item authors of certified compilers (e.g.~\cite{amadio-certified-2014, kumar-cake-2014, leroy-formal-2009, sevcik-compcert-2013}) interested in producing ABI-compliant linkable ELF binaries, or extending their source languages with elements of linker-speak. 

\item designers of source-level verification tools built atop the formal
guarantees programming language standards and certified compilers
provide. %~\cite{appel-program-2014}.
As our opening example showed, linking is able not only to refine but to override source-level semantics, so source-level reasoning alone is not sound unless augmented with knowledge of linker features---that our semantics can provide.

\item researchers seeking to improve languages and toolchains, particularly for systems code: such work must somehow accommodate the various roles of linker-speak, whether by embracing it as it currently exists, or by replacing it.
\end{verytightitemize}
% \subsection{Context}
% \label{subsect.context}
