\section{Background}

\subsection{ELF file format}
The Executable and Linkable (ELF) file format~\cite{elf-sco-model} is a format for storing programs or their fragments on-disk, created as a result of compiling and linking.
A flexible format not tied specifically to any one machine architecture, ELF is now the \emph{de facto} standard format for executable and linkable files on Linux, various flavours of BSD, and embedded devices ranging from mobile phones to games consoles.
Unlike older formats, ELF merges the file format of executable and linkable files together into a unified format.

A skeleton outline of the ELF file format is provided in the System V ABI~\cite{elf-sco-model}, and using this specification enough structure is defined to properly parse-and-blit ELF files to and from disk.
However, to interpret the contents of a file more detail is needed, and therefore architecture-specific supplements to the core specification are provided for each microprocessor family.
These supplementary documents may complement, override, or fill in detail entirely missing from the core ELF specification.
%In some cases, these supplementary documents may provide extra section and segment types, extra flags, or other bits of structure to an ELF file specific to that platform.
%For example, the AARCH64 ABI supplement adds the \texttt{AARCH64\_BUILD\_ATTRIBUTES} section type, describing sections that contain unspecified compiler build attributes.
%In other cases, these supplementary documents may override the core-ELF specification.
%For example, the AARCH64 supplement overrides the interpretation of the ELF header field \texttt{e\_entry}, ostensibly the entry point for the program, but overridden to point to a location in the body of the file containing the entry point on AARCH64 platforms.
%In yet other cases, the core-ELF specification remains entirely silent on the contents and functioning of certain structural components of an ELF file.
%One key example of this is the interpretation of relocation records, which are tied to specific instruction encodings and therefore wholly ABI-specific, varying markedly from one ABI to another, and their semantics are therefore entirely delegated to the architecture-specific supplement for the platform in question.

Operating systems may also augment the format with their own extensions, specifying new file components that they may interpret or expect. %specifying additional flags, section and segment types, and other structural elements.
For example, many Linux ELF binaries contain \texttt{GNU} extensions.
%These augment the standard ELF file format, as for example, with the presence of a segment of type \texttt{PT\_GNU\_EH\_FRAME} containing exception handling information, or a section of type \texttt{STT\_GNU\_VERSION} containing versioning information.
Some of these extensions are collated in a document called the \emph{Linux Standard Base} (`LSB')~\cite{linux-standard-base}.
Many more, however, are either documented informally in mailing list messages, or not documented at all.

To capture enough of the structure of ELF files executed `in the wild', the core specification along with microprocessor-specific and operating-specific supplementary material must all be taken into account.
We note here, however, that in practice there is no clean separation of the latter two sets of supplementary material.
For example, the AMD64 ABI explicitly makes reference to \texttt{GNU}-specific extensions, for example (see Section 4.2 of~\cite{amd64-abi}).

% For example, Cardelli formalised a system of ``linksets'' 
% in which ``separate compilability'' could be formally stated and checked,
% modelling linking as a property-preserving merge operation,
% and assuming a source-level interface formalism including notions of signature and type checking.
% 
% Although such work can be valuable in new language and toolchain designs, 
% it does not suffice for modelling existing code.
% 
% Currently we are aware of no formal semantics for any substantial fragment of linker-speak,
% making only informal reasoning possible.
% 
% Existing approaches to formally verified toolchains 
% have effectively replaced the linker
% with a minimal language-specific linker
% intended merely to provide separate compilation semantics, 
% therefore not addressing the features on which many real codebases rely.

\subsection{Linking}

In this paper we focus on linking in System~V-derived Unix environments,
including GNU/Linux and all modern BSD variants (hence the use of ELF).
Windows and Mac OS (Darwin) environments exhibit broadly similar feature sets,
but the System~V environment's is generally a superset.
Following \citet{gingell_shared_1987}, we refer to the Unix linker command \textsf{ld}
as the \emph{batch linker}.

%, and 
%``dynamic linker'' to refer to the \textsf{ld.so} dynamic linker running
%at load time.

% (Although our formalisation effort has not got as far as capturing
% many aspects of dynamic linking,
% discussing the dynamic linker will be necessary---both for general completeness
% and for presenting a thorough survey of linker-speak.)

A batch linker takes multiple modules of \emph{relocatable object code} 
as input (in the form of \textsf{.o} files, or groups of them bundled as \textsf{.a} ``archive'' files).
It produces a single ``linked'' binary as output.
Linked binaries are usually executables, and embody the input modules.
The main work of the linker is to select and combine the necessary inputs, 
concretise symbolic references between them (encoded as metadata in the input files), 
into bit-patterns in the output binary,
and to organise the input modules' content
in a single logical memory image.

Object files consist principally of \emph{sections}, \emph{symbols} and \emph{relocations}.
Sections are chunks of bytes (code or data), treated as indivisible units
by the linker: they may be moved or combined, but not broken apart. 
Symbols give names to particular positions within a section, 
usually reflecting the source-level definition they represent.

In an input file, a symbol may be recorded as \emph{undefined}.
This means the object file references it, but it does not exist in that file.
Individual references are represented by \emph{relocation records}, sometimes called 
``fixups'': they record that a range of bytes within some section must be fixed up 
to point to the intended referent, denoted by a symbol.
Before linking, these bytes hold a placeholder value generated by the compiler.
After linking, they hold the encoded address of the referent.
Each relocation record selects an architecture-specific ``type'' of relocation, 
a recipe for fixing up the bytes according to the architecture's
addressing modes (such as absolute or PC-relative addressing),
field widths (a e.g.\ 16- or 32-bit branch target field)
and/or pointer encodings (e.g.\ 32- versus 64-bit).

% There is no explicit concept of \emph{binding} or \emph{reference} in linking.
% Relocation and address binding are tightly interwoven, 
% and there is no explicit concept of \emph{binding}.
% 
%   or \emph{reference} in linking.
% Even if a symbol is defined locally in a given object file, 
% references to it might still require relocation.
% This is because the symbol's address is not yet bound.
% For example, a pointer called \textsf{p} 
% initialized to point to a specific global variable \textsf{x}
% will appear in object code as
% (1) a word-sized portion of some section (probably called \textsf{\.data});
% (2) a defined symbol called \textsf{p} marking that range within the section; 
% (3) a relocation record marking that range as pointing to \textsf{x},
% whose address is not yet known.
% The symbol \textsf{x} also exists in the object file; it 
% may be either a defined or undefined symbol, 
% depending on whether it was defined in the originating compilation unit.
% In either case, its address is not decided until during linking, so 
% \textsf{p}'s relocation record remains essential.
% Making a concrete binding is called \emph{applying relocations}, 
% betraying its intertwinedness with the process of assigning memory addresses,
% and the metadata describing references are called \emph{relocation records}.
% The actual bytes of \textsf{p} will be filled with an arbitrary value,
% typically zero; only during relocation will they be filled in.

%These bit-patterns are either the address fields of encoded machine instructions (in code), 
%or pointer representations (in data).

A completely self-contained output binary is said to be ``statically linked''. 
Modern batch linkers allow some bindings to be deferred until a later \emph{dynamic linking} step.
% if they point to the dynamically-linkable libraries supplied on the command line.
% These are \emph{not} embodied in the output; rather,
% they serve to identify the libraries expected to be available at load time.
%Any references to dynamically-linked libraries are deferred
These references are represented as relocation records and symbol metadata
in the output binary, much like in the input files.
The main purpose of dynamic linking is to support sharing of library code across multiple processes at run time, saving memory.
Shared library binaries themselves are also produced by the batch linker,
and internally are not much different from executables.

Having composed a memory image out of its inputs, and applied relocations, 
the linker finally outputs a serialised form of this memory image
into the output binary, such that it can be re-created by the \emph{loader}.
A modern Unix typically contains two loaders: 
one in the kernel, used for statically linked binaries, and one in user-space used for dynamic linking (\textsf{ld.so}).

% Internally there are few differences
% between an executable and a shared library.
% The principal difference is that the shared library may not 
% embed any absolute memory addresses, since it may be loaded
% at any address, whereas executables are always loaded from 
% address zero.

%\footnote{Modern linkers can also produce executables
%with this property, called ``PIE'' for position-independent executable.}


% Dynamically linked binaries, whether executable or library, 
% differ from statically linked ones
% in that they include metadata used by the dynamic linker
% to apply the remaining relocations.
% The other key difference is that 
% shared libraries, in order for their memory to be physically 
% shared at run time across multiple processes, 
% are usually crafted so that their text does not need any relocation at all.
% Rather, code-to-code and code-to-data references are indirected 
% via more compact \emph{non-}shared support structures 
% (respectively the GOT, or global offset table, and PLT, or procedure linkage table).
% This allows multiple processes to simultaneously map the same unmodified text segment 
% at different load addresses.
% (Some non-Unix systems avoid the need for position-independent libary code by pre-registering 
% certain address ranges, to be used by all processes; Windows DLLs use this scheme.)

% \subsection{Linkers and module systems}

The relationship between linker features and programming language features is complex.
Many languages are said to have a ``module system'', having certain features corresponding to a linker's.
Although we mostly save discussion of this correspondence for later (\S\ref{sec:discussion})
it is worth remarking that while a typical module system provides mechanisms dealing in both abstract and concrete modules, linking is entirely concrete.
Linkers have no notion of module instantiation, nor of parameterisation; they focus only on the interconnection of concrete modules.
As we will see, this still encompasses a surprising variety of features, many of which have no analogue in languages' module systems.

The disparate and spotty specification of linking poses a challenge.
Ironically, Unix linking has become \emph{less} well specified over time.
System~V Unix's documentation included a detailed description of the linker,
but this was removed when the ELF format was introduced (revision~4), 
leaving only a manual page.
The POSIX Standard~\citep{ieee_standard_1988} even omits this, instead stating that its C and Fortran compilers 
``conceptually consist of a compiler and link editor''.
Although successive linkers, notably the GNU linker, offer detailed manuals, 
these are hardly normative.

% \subsection{Starting point}
