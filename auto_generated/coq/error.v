(* Generated by Lem from error.lem. *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import String.
Require Import Program.Wf.

Require Import coqharness.

Open Scope nat_scope.
Open Scope string_scope.

Require Import lem_basic_classes.
Require Export lem_basic_classes.

Require Import lem_list.
Require Export lem_list.

Require Import lem_maybe.
Require Export lem_maybe.

Require Import lem_num.
Require Export lem_num.

Require Import lem_string.
Require Export lem_string.

Require Import show.
Require Export show.


(** [error] is a type used to represent potentially failing computations. [Success]
  * marks a successful completion of a computation, whilst [Fail err] marks a failure,
  * with [err] as the reason.
  *)
Inductive error (a : Type) : Type :=
	 Success:  a -> error a
	| Fail:  string  -> error a.
Definition error_default{a: Type} : error a := Success DAEMON.
(* [?]: removed value specification. *)

Definition return0 {a : Type}  (r : a)  : error a:=  Success r.
(* [?]: removed value specification. *)

Definition with_success {a b : Type}  (err : error a) (fl : b) (suc : a -> b)  : b:= 
  match ( err) with 
    | Success s => suc s
    | Fail err  => fl
  end.
(* [?]: removed value specification. *)

Definition fail0 {a : Type}  (err : string )  : error a:=  Fail err.
(* [?]: removed value specification. *)

Definition >>= {a b : Type}  (x : error a) (f : a -> error b)  : error b:= 
	match ( x) with 
		| Success s => f s
		| Fail err  => Fail err
	end.
(* [?]: removed value specification. *)

Definition as_maybe {a : Type}  (e : error a)  : option a := 
  match ( e) with 
    | Fail err => None
    | Success s => Some s
  end.
(* [?]: removed value specification. *)

Program Fixpoint repeatM {a : Type}  (count : nat ) (action : error a)  : error (list a):= 
  if beq_nat count( 0) then
    return0 []
  else
    action >>= (fun (head1 : a) =>
    repeatM ( Coq.Init.Peano.minus count( 1)) action >>= (fun (tail1 : list a) =>
    return0 (head1::tail1))).
(* [?]: removed value specification. *)

Program Fixpoint repeatM' {a b : Type}  (count : nat ) (seed : b) (action : b -> error ((a*b) % type))  : error ((list a*b) % type):= 
  if beq_nat count( 0) then
    return0 ([], seed)
  else
    action seed >>= (fun (p : (a*b) % type) =>
    match ( (p) ) with ( (head1,  seed)) =>
      repeatM' ( Coq.Init.Peano.minus count ( 1)) seed action >>=
      (fun (p : (list a*b) % type) =>
         match ( (p) ) with ( (tail1,  seed)) =>
           return0 ((head1 :: tail1), seed) end) end).
(* [?]: removed value specification. *)

Program Fixpoint mapM {a b : Type}  (f : a -> error b) (xs : list a)  : error (list b):= 
	match ( xs) with 
		| []    => return0 []
		| x::xs =>
				f x >>= (fun (hd : b) =>
				mapM f xs >>= (fun (tl : list b) =>
				return0 (hd::tl)))
	end.
(* [?]: removed value specification. *)

Program Fixpoint foldM {a b : Type}  (f : a -> b -> error a) (e : a) (xs : list b)  : error a:= 
  match ( xs) with 
    | []    => return0 e
    | x::xs => f e x >>= (fun (res : a) => foldM f res xs)
  end.
(* [?]: removed value specification. *)

(* 

Instance x16_Show{a: Type} `{Show a}: Show (error  a):= {
	 show  :=  string_of_error
}.
 *)
