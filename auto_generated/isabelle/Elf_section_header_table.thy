header{*Generated by Lem from elf_section_header_table.lem.*}

theory "Elf_section_header_table" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_bool" 
	 "Lem_function" 
	 "Lem_list" 
	 "Lem_maybe" 
	 "Lem_num" 
	 "Lem_string" 
	 "Elf_types" 
	 "Endianness" 
	 "String_table" 
	 "Byte_sequence" 
	 "Error" 
	 "Missing_pervasives" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)

(*open import Elf_types*)
(*open import Endianness*)
(*open import String_table*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(** Special section indices. *)

(** [shn_undef]: marks an undefined, missing or irrelevant section reference.
  *)
definition shn_undef  :: " nat "  where 
     " shn_undef = (( 0 :: nat))"

(** [shn_loreserve]: this specifies the lower bound of the range of reserved
  * indices.
  *)
definition shn_loreserve  :: " nat "  where 
     " shn_loreserve = (( 65280 :: nat))"
 (* 0xff00 *)
(** [shn_loproc]: start of the range reserved for processor-specific semantics.
  *)
definition shn_loproc  :: " nat "  where 
     " shn_loproc = (( 65280 :: nat))"
 (* 0xff00 *)
(** [shn_hiproc]: end of the range reserved for processor-specific semantics.
  *)
definition shn_hiproc  :: " nat "  where 
     " shn_hiproc = (( 65311 :: nat))"
 (* 0xff1f *)
(** [shn_loos]: start of the range reserved for operating system-specific
  * semantics.
  *)
definition shn_loos  :: " nat "  where 
     " shn_loos = (( 65312 :: nat))"
 (* 0xff20 *)
(** [shn_hios]: end of the range reserved for operating system-specific
  * semantics.
  *)
definition shn_hios  :: " nat "  where 
     " shn_hios = (( 65343 :: nat))"
 (* 0xff3f *)
(** [shn_abs]: specifies the absolute values for the corresponding reference.
  * Symbols defined relative to section number [shn_abs] have absolute values
  * and are not affected by relocation.
  *)
definition shn_abs  :: " nat "  where 
     " shn_abs = (( 65521 :: nat))"
 (* 0xfff1 *)
(** [shn_common]: symbols defined relative to this index are common symbols,
  * such as unallocated C external variables.
  *)
definition shn_common  :: " nat "  where 
     " shn_common = (( 65522 :: nat))"
 (* 0xfff2 *)
(** [shn_xindex]: an escape value.  It indicates the actual section header index
  * is too large to fit in the containing field and is located in another
  * location (specific to the structure where it appears).
  *)
definition shn_xindex  :: " nat "  where 
     " shn_xindex = (( 65535 :: nat))"
 (* 0xffff *)
(** [shn_hireserve]: specifies the upper-bound of reserved values.
  *)
definition shn_hireserve  :: " nat "  where 
     " shn_hireserve = (( 65535 :: nat))"
 (* 0xffff *)

(*val string_of_special_section_index : natural -> string*)

(** Section types. *)

(** Marks the section header as being inactive. *)
definition sht_null  :: " nat "  where 
     " sht_null = (( 0 :: nat))"

(** Section holds information defined by the program. *)
definition sht_progbits  :: " nat "  where 
     " sht_progbits = (( 1 :: nat))"

(** The following two section types hold a symbol table.  An object file may only
  * have one symbol table of each of the respective types.  The symtab provides
  * a place for link editing, whereas the dynsym section holds a minimal set of
  * dynamic linking symbols
  *)
definition sht_symtab  :: " nat "  where 
     " sht_symtab = (( 2 :: nat))"

definition sht_dynsym  :: " nat "  where 
     " sht_dynsym = (( 11 :: nat))"

(** Section holds a string table *)
definition sht_strtab  :: " nat "  where 
     " sht_strtab = (( 3 :: nat))"

(** Section holds relocation entries with explicit addends.  An object file may
  * have multiple section of this type.
  *)
definition sht_rela  :: " nat "  where 
     " sht_rela = (( 4 :: nat))"

(** Section holds a symbol hash table.  An object file may only have a single
  * hash table.
  *)
definition sht_hash  :: " nat "  where 
     " sht_hash = (( 5 :: nat))"

(** Section holds information for dynamic linking.  An object file may only have
  * a single dynamic section.
  *)
definition sht_dynamic  :: " nat "  where 
     " sht_dynamic = (( 6 :: nat))"

(** Section holds information that marks the file in some way. *)
definition sht_note  :: " nat "  where 
     " sht_note = (( 7 :: nat))"

(** Section occupies no space in the file but otherwise resembles a progbits
  * section.
  *)
definition sht_nobits  :: " nat "  where 
     " sht_nobits = (( 8 :: nat))"

(** Section holds relocation entries without explicit addends.  An object file
  * may have multiple section of this type.
  *)
definition sht_rel  :: " nat "  where 
     " sht_rel = (( 9 :: nat))"

(** Section type is reserved but has an unspecified meaning. *)
definition sht_shlib  :: " nat "  where 
     " sht_shlib = (( 10 :: nat))"

(** Section contains an array of pointers to initialisation functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
definition sht_init_array  :: " nat "  where 
     " sht_init_array = (( 14 :: nat))"

(** Section contains an array of pointers to termination functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
definition sht_fini_array  :: " nat "  where 
     " sht_fini_array = (( 15 :: nat))"

(** Section contains an array of pointers to initialisation functions that are
  * invoked before all other initialisation functions.  Each
  * pointer is taken as a parameterless function with a void return type.
  *)
definition sht_preinit_array  :: " nat "  where 
     " sht_preinit_array = (( 16 :: nat))"

(** Section defines a section group, i.e. a set of sections that are related and
  * must be treated especially by the linker.  May only appear in relocatable
  * objects.
  *)
definition sht_group  :: " nat "  where 
     " sht_group = (( 17 :: nat))"

(** Section is associated with sections of type SHT_SYMTAB and is required if
  * any of the section header indices referenced by that symbol table contains
  * the escape value SHN_XINDEX.
  *
  * FIXME: Lem bug as [int] type used throughout Lem codebase, rather than
  * [BigInt.t], so Lem chokes on these large constants below, hence the weird
  * way in which they are written.
  *)
definition sht_symtab_shndx  :: " nat "  where 
     " sht_symtab_shndx = (( 18 :: nat))"

definition sht_loos  :: " nat "  where 
     " sht_loos = (((( 3 :: nat) *( 1024 :: nat)) *( 1024 :: nat)) *( 512 :: nat))"
 (* 1610612736 (* 0x60000000 *) *)
definition sht_hios  :: " nat "  where 
     " sht_hios = ( (( 469762047 :: nat) *( 4 :: nat)) +( 3 :: nat))"
 (* 1879048191 (* 0x6fffffff *) *)
definition sht_loproc  :: " nat "  where 
     " sht_loproc = ( (( 469762048 :: nat) *( 4 :: nat)))"
 (* 1879048192 (* 0x70000000 *) *)
definition sht_hiproc  :: " nat "  where 
     " sht_hiproc = ( (( 536870911 :: nat) *( 4 :: nat)) +( 3 :: nat))"
 (* 2147483647 (* 0x7fffffff *) *)
definition sht_louser  :: " nat "  where 
     " sht_louser = ( (( 536870912 :: nat) *( 4 :: nat)))"
 (* 2147483648 (* 0x80000000 *) *)
definition sht_hiuser  :: " nat "  where 
     " sht_hiuser = ( (( 603979775 :: nat) *( 4 :: nat)) +( 3 :: nat))"
 (* 2415919103 (* 0x8fffffff *) *)

(*val string_of_section_type : (natural -> string) -> (natural -> string) ->
  (natural -> string) -> natural -> string*)

(** Section header table entry type. *)

(** [elf32_section_header_table_entry] is the type of entries in the section
  * header table in 32-bit ELF files.  Each entry in the table details a section
  * in the body of the ELF file.
  *) 
record elf32_section_header_table_entry =
  
 elf32_sh_name      ::" uint32 " (** Name of the section *)
   
 elf32_sh_type      ::" uint32 " (** Type of the section and its semantics *)
   
 elf32_sh_flags     ::" uint32 " (** Flags associated with the section *)
   
 elf32_sh_addr      ::" uint32 " (** Address of first byte of section in memory image *)
   
 elf32_sh_offset    ::" uint32 "  (** Offset from beginning of file of first byte of section *)
   
 elf32_sh_size      ::" uint32 " (** Section size in bytes *)
   
 elf32_sh_link      ::" uint32 " (** Section header table index link *)
   
 elf32_sh_info      ::" uint32 " (** Extra information, contents depends on type of section *)
   
 elf32_sh_addralign ::" uint32 " (** Alignment constraints for section *)
   
 elf32_sh_entsize   ::" uint32 " (** Size of each entry in table, if section is one *)
   


(** [elf64_section_header_table_entry] is the type of entries in the section
  * header table in 64-bit ELF files.  Each entry in the table details a section
  * in the body of the ELF file.
  *) 
record elf64_section_header_table_entry =
  
 elf64_sh_name      ::" uint32 " (** Name of the section *)
   
 elf64_sh_type      ::" uint32 " (** Type of the section and its semantics *)
   
 elf64_sh_flags     ::" uint64 " (** Flags associated with the section *)
   
 elf64_sh_addr      ::" Elf_Types_Local.uint64 " (** Address of first byte of section in memory image *)
   
 elf64_sh_offset    ::" uint64 "  (** Offset from beginning of file of first byte of section *)
   
 elf64_sh_size      ::" uint64 " (** Section size in bytes *)
   
 elf64_sh_link      ::" uint32 " (** Section header table index link *)
   
 elf64_sh_info      ::" uint32 " (** Extra information, contents depends on type of section *)
   
 elf64_sh_addralign ::" uint64 " (** Alignment constraints for section *)
   
 elf64_sh_entsize   ::" uint64 " (** Size of each entry in table, if section is one *)
   


(*val bytes_of_elf32_section_header_table_entry : endianness -> elf32_section_header_table_entry -> byte_sequence*)
definition bytes_of_elf32_section_header_table_entry  :: " endianness \<Rightarrow> elf32_section_header_table_entry \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf32_section_header_table_entry endian entry = (
  Byte_sequence.from_byte_lists [
    bytes_of_elf32_word endian(elf32_sh_name   entry)
  , bytes_of_elf32_word endian(elf32_sh_type   entry)
  , bytes_of_elf32_word endian(elf32_sh_flags   entry)
  , bytes_of_elf32_addr endian(elf32_sh_addr   entry)
  , bytes_of_elf32_off  endian(elf32_sh_offset   entry)
  , bytes_of_elf32_word endian(elf32_sh_size   entry)
  , bytes_of_elf32_word endian(elf32_sh_link   entry)
  , bytes_of_elf32_word endian(elf32_sh_info   entry)
  , bytes_of_elf32_word endian(elf32_sh_addralign   entry)
  , bytes_of_elf32_word endian(elf32_sh_entsize   entry)
  ])"


(*val read_elf32_section_header_table_entry : endianness -> byte_sequence -> error (elf32_section_header_table_entry * byte_sequence)*)
definition read_elf32_section_header_table_entry  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>(elf32_section_header_table_entry*byte_sequence)error "  where 
     " read_elf32_section_header_table_entry endian bs = (
	read_elf32_word endian bs >>= (\<lambda> (sh_name, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_type, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_flags, bs) . 
	read_elf32_addr endian bs >>= (\<lambda> (sh_addr, bs) . 
	read_elf32_off  endian bs >>= (\<lambda> (sh_offset, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_size, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_link, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_info, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_addralign, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (sh_entsize, bs) . 
		error_return ((| elf32_sh_name = sh_name, elf32_sh_type = sh_type,
                elf32_sh_flags = sh_flags, elf32_sh_addr = sh_addr,
                elf32_sh_offset = sh_offset, elf32_sh_size = sh_size,
                elf32_sh_link = sh_link, elf32_sh_info = sh_info,
                elf32_sh_addralign = sh_addralign, elf32_sh_entsize = sh_entsize |), bs))))))))))))"


(*val bytes_of_elf64_section_header_table_entry : endianness -> elf64_section_header_table_entry -> byte_sequence*)
definition bytes_of_elf64_section_header_table_entry  :: " endianness \<Rightarrow> elf64_section_header_table_entry \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf64_section_header_table_entry endian entry = (
  Byte_sequence.from_byte_lists [
    bytes_of_elf64_word  endian(elf64_sh_name   entry)
  , bytes_of_elf64_word  endian(elf64_sh_type   entry)
  , bytes_of_elf64_xword endian(elf64_sh_flags   entry)
  , bytes_of_elf64_addr  endian(elf64_sh_addr   entry)
  , bytes_of_elf64_off   endian(elf64_sh_offset   entry)
  , bytes_of_elf64_xword endian(elf64_sh_size   entry)
  , bytes_of_elf64_word  endian(elf64_sh_link   entry)
  , bytes_of_elf64_word  endian(elf64_sh_info   entry)
  , bytes_of_elf64_xword endian(elf64_sh_addralign   entry)
  , bytes_of_elf64_xword endian(elf64_sh_entsize   entry)
  ])"


(*val read_elf64_section_header_table_entry : endianness -> byte_sequence -> error (elf64_section_header_table_entry * byte_sequence)*)
definition read_elf64_section_header_table_entry  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>(elf64_section_header_table_entry*byte_sequence)error "  where 
     " read_elf64_section_header_table_entry endian bs = (
  read_elf64_word endian bs >>= (\<lambda> (sh_name, bs) . 
  read_elf64_word endian bs >>= (\<lambda> (sh_type, bs) . 
  read_elf64_xword endian bs >>= (\<lambda> (sh_flags, bs) . 
  read_elf64_addr endian bs >>= (\<lambda> (sh_addr, bs) . 
  read_elf64_off  endian bs >>= (\<lambda> (sh_offset, bs) . 
  read_elf64_xword endian bs >>= (\<lambda> (sh_size, bs) . 
  read_elf64_word endian bs >>= (\<lambda> (sh_link, bs) . 
  read_elf64_word endian bs >>= (\<lambda> (sh_info, bs) . 
  read_elf64_xword endian bs >>= (\<lambda> (sh_addralign, bs) . 
  read_elf64_xword endian bs >>= (\<lambda> (sh_entsize, bs) . 
    error_return ((| elf64_sh_name = sh_name, elf64_sh_type = sh_type,
                elf64_sh_flags = sh_flags, elf64_sh_addr = sh_addr,
                elf64_sh_offset = sh_offset, elf64_sh_size = sh_size,
                elf64_sh_link = sh_link, elf64_sh_info = sh_info,
                elf64_sh_addralign = sh_addralign, elf64_sh_entsize = sh_entsize |), bs))))))))))))"


(** The [sht_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
type_synonym sht_print_bundle =" (nat \<Rightarrow> string) * (nat \<Rightarrow> string) * (nat \<Rightarrow> string)"

(*val string_of_elf32_section_header_table_entry : sht_print_bundle -> elf32_section_header_table_entry -> string*)

(*val string_of_elf64_section_header_table_entry : sht_print_bundle -> elf64_section_header_table_entry -> string*)

(*val string_of_elf32_section_header_table_entry' : sht_print_bundle -> string_table -> elf32_section_header_table_entry -> string*)

(*val string_of_elf64_section_header_table_entry' : sht_print_bundle -> string_table -> elf64_section_header_table_entry -> string*)

(*val string_of_elf32_section_header_table_entry_default : elf32_section_header_table_entry -> string*)

(*val string_of_elf64_section_header_table_entry_default : elf64_section_header_table_entry -> string*)

(** Section header table type. *)

(** Type [elf32_section_header_table] represents a section header table for 32-bit
  * ELF files.  A section header table is an array (implemented as a list, here)
  * of section header table entries.
  *)
type_synonym elf32_section_header_table =" elf32_section_header_table_entry
  list "

record 'a HasElf32SectionHeaderTable_class=

  get_elf32_section_header_table_method ::" 'a \<Rightarrow>  elf32_section_header_table option "



(** Type [elf64_section_header_table] represents a section header table for 64-bit
  * ELF files.  A section header table is an array (implemented as a list, here)
  * of section header table entries.
  *)
type_synonym elf64_section_header_table =" elf64_section_header_table_entry
  list "

record 'a HasElf64SectionHeaderTable_class=

  get_elf64_section_header_table_method ::" 'a \<Rightarrow>  elf64_section_header_table option "



(*val bytes_of_elf32_section_header_table : endianness -> elf32_section_header_table -> byte_sequence*)
definition bytes_of_elf32_section_header_table  :: " endianness \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf32_section_header_table endian tbl = (
  Byte_sequence.concat_byte_sequence (List.map (bytes_of_elf32_section_header_table_entry endian) tbl))"


function (sequential,domintros)  read_elf32_section_header_table'  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>((elf32_section_header_table_entry)list)error "  where 
     " read_elf32_section_header_table' endian bs0 = (
  if length bs0 =( 0 :: nat) then
    error_return []
  else
    read_elf32_section_header_table_entry endian bs0 >>= (\<lambda> (entry, bs1) . 
    read_elf32_section_header_table' endian bs1 >>= (\<lambda> tail . 
    error_return (entry # tail))))" 
by pat_completeness auto


(*val read_elf32_section_header_table : natural -> endianness -> byte_sequence -> error (elf32_section_header_table * byte_sequence)*)
definition read_elf32_section_header_table  :: " nat \<Rightarrow> endianness \<Rightarrow> byte_sequence \<Rightarrow>((elf32_section_header_table_entry)list*byte_sequence)error "  where 
     " read_elf32_section_header_table table_size endian bs0 = (
  partition table_size bs0 >>= (\<lambda> (eat, rest) . 
  read_elf32_section_header_table' endian eat >>= (\<lambda> entries . 
  error_return (entries, rest))))"

;;

(*val bytes_of_elf64_section_header_table : endianness -> elf64_section_header_table -> byte_sequence*)
definition bytes_of_elf64_section_header_table  :: " endianness \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf64_section_header_table endian tbl = (
  Byte_sequence.concat_byte_sequence (List.map (bytes_of_elf64_section_header_table_entry endian) tbl))"


function (sequential,domintros)  read_elf64_section_header_table'  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>((elf64_section_header_table_entry)list)error "  where 
     " read_elf64_section_header_table' endian bs0 = (
  if length bs0 =( 0 :: nat) then
    error_return []
  else
    read_elf64_section_header_table_entry endian bs0 >>= (\<lambda> (entry, bs1) . 
    read_elf64_section_header_table' endian bs1 >>= (\<lambda> tail . 
    error_return (entry # tail))))" 
by pat_completeness auto


(*val read_elf64_section_header_table : natural -> endianness -> byte_sequence -> error (elf64_section_header_table * byte_sequence)*)
definition read_elf64_section_header_table  :: " nat \<Rightarrow> endianness \<Rightarrow> byte_sequence \<Rightarrow>((elf64_section_header_table_entry)list*byte_sequence)error "  where 
     " read_elf64_section_header_table table_size endian bs0 = (
  partition table_size bs0 >>= (\<lambda> (eat, rest) . 
  read_elf64_section_header_table' endian eat >>= (\<lambda> entries . 
  error_return (entries, rest))))"

;;

(*val elf32_size_correct : elf32_section_header_table_entry -> elf32_section_header_table -> bool*)
definition elf32_size_correct  :: " elf32_section_header_table_entry \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> bool "  where 
     " elf32_size_correct hdr tbl = (
  (let m = (unat(elf32_sh_size   hdr)) in
    if m =( 0 :: nat) then
      True
    else
      m =  (List.length tbl)))"

;;

(*val is_valid_elf32_section_header_table : elf32_section_header_table -> bool*)
definition is_valid_elf32_section_header_table  :: "(elf32_section_header_table_entry)list \<Rightarrow> bool "  where 
     " is_valid_elf32_section_header_table tbl = (
  (case  tbl of
      []    => False
    | x # xs =>        
(unat(elf32_sh_name   x) =( 0 :: nat)) \<and>
        ((unat(elf32_sh_type   x) = sht_null) \<and>
        ((unat(elf32_sh_flags   x) =( 0 :: nat)) \<and>
        ((unat(elf32_sh_addr   x) =( 0 :: nat)) \<and>
        ((unat(elf32_sh_offset   x) =( 0 :: nat)) \<and>
        ((unat(elf32_sh_info   x) =( 0 :: nat)) \<and>
        ((unat(elf32_sh_addralign   x) =( 0 :: nat)) \<and>
        ((unat(elf32_sh_entsize   x) =( 0 :: nat)) \<and>
        elf32_size_correct x tbl)))))))
        (* XXX: more correctness criteria in time *)
  ))"


(*val string_of_elf32_section_header_table : sht_print_bundle -> elf32_section_header_table -> string*)

(*val string_of_elf32_section_header_table' : sht_print_bundle -> string_table -> elf32_section_header_table -> string*)

(*val string_of_elf64_section_header_table : sht_print_bundle -> elf64_section_header_table -> string*)

(*val string_of_elf64_section_header_table' : sht_print_bundle -> string_table -> elf64_section_header_table -> string*)end
