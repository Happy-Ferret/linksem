header{*Generated by Lem from elf_header.lem.*}

theory "Elf_header" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_bool" 
	 "Lem_function" 
	 "Lem_list" 
	 "Lem_maybe" 
	 "Lem_num" 
	 "Lem_string" 
	 "Default_printing" 
	 "Endianness" 
	 "Elf_types" 
	 "Byte_sequence" 
	 "Error" 
	 "Missing_pervasives" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)

(*open import Default_printing*)
(*open import Endianness*)

(*open import Elf_types*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(** ELF object file types.  Enumerates the ELF object file types specified in the
 *  System V ABI.  Values between [elf_ft_lo_os] and [elf_ft_hi_os] inclusive are
 *  reserved for operating system specific values typically defined in an
 *  addendum to the System V ABI for that operating system.  Values between
 *  [elf_ft_lo_proc] and [elf_ft_hi_proc] inclusive are processor specific and
 *  are typically defined in an addendum to the System V ABI for that processor
 *  series.
 *)

(** No file type *)
definition elf_ft_none  :: " nat "  where 
     " elf_ft_none = (( 0 :: nat))"

(** Relocatable file *)
definition elf_ft_rel  :: " nat "  where 
     " elf_ft_rel = (( 1 :: nat))"

(** Executable file *)
definition elf_ft_exec  :: " nat "  where 
     " elf_ft_exec = (( 2 :: nat))"

(** Shared object file *)
definition elf_ft_dyn  :: " nat "  where 
     " elf_ft_dyn = (( 3 :: nat))"

(** Core file *)
definition elf_ft_core  :: " nat "  where 
     " elf_ft_core = (( 4 :: nat))"

(** Operating-system specific *)
definition elf_ft_lo_os  :: " nat "  where 
     " elf_ft_lo_os = (( 65024 :: nat))"
 (* 0xfe00 *)
(** Operating-system specific *)
definition elf_ft_hi_os  :: " nat "  where 
     " elf_ft_hi_os = (( 65279 :: nat))"
 (* 0xfeff *)
(** Processor specific *)
definition elf_ft_lo_proc  :: " nat "  where 
     " elf_ft_lo_proc = (( 65280 :: nat))"
 (* 0xff00 *)
(** Processor specific *)
definition elf_ft_hi_proc  :: " nat "  where 
     " elf_ft_hi_proc = (( 65535 :: nat))"
 (* 0xffff *)

(** [string_of_elf_file_type os proc m] produces a string representation of the
  * numeric encoding [m] of the ELF file type.  For values reserved for OS or
  * processor specific values, the higher-order functions [os] and [proc] are
  * used for printing, respectively.
  *)
(*val string_of_elf_file_type : (natural -> string) -> (natural -> string) -> natural -> string*)

(** [is_operating_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for operating system-specific purposes.
  *)
(*val is_operating_system_specific_object_file_type_value : natural -> bool*)
definition is_operating_system_specific_object_file_type_value  :: " nat \<Rightarrow> bool "  where 
     " is_operating_system_specific_object_file_type_value v = (  
(v \<ge>( 65024 :: nat)) \<and> (v \<le>( 65279 :: nat)))"


(** [is_processor_specific_file_type_value] checks whether a numeric value is
  * reserved by the ABI for processor-specific purposes.
  *)
(*val is_processor_specific_object_file_type_value : natural -> bool*)
definition is_processor_specific_object_file_type_value  :: " nat \<Rightarrow> bool "  where 
     " is_processor_specific_object_file_type_value v = (  
(v \<ge>( 65280 :: nat)) \<and> (v \<le>( 65535 :: nat)))"


(** ELF machine architectures (TODO: complete the conversion of the enumeration.) *)

(** Intel 386 *)
definition elf_ma_386  :: " nat "  where 
     " elf_ma_386 = (( 3 :: nat))"

(** IBM PowerPC *)
definition elf_ma_ppc  :: " nat "  where 
     " elf_ma_ppc = (( 20 :: nat))"

(** IBM PowerPC 64 *)
definition elf_ma_ppc64  :: " nat "  where 
     " elf_ma_ppc64 = (( 21 :: nat))"

(** AMD x86-64 *)
definition elf_ma_x86_64  :: " nat "  where 
     " elf_ma_x86_64 = (( 62 :: nat))"


(** [string_of_elf_machine_architecture m] produces a string representation of
  * the numeric encoding [m] of the ELF machine architecture.
  *)
(*val string_of_elf_machine_architecture : natural -> string*)

(* XXX: convert these into top-level definitions later...
(** [elf_machine_architecture] enumerates all the supported machine architectures
  * in the System V ABI.
  *)
type elf_machine_architecture
  = ELF_MA_Norc          (* Nanoradio optimised RISC *)
  | ELF_MA_Cool          (* iCelero CoolEngine *)
  | ELF_MA_Coge          (* Cognitive Smart Memory Processor *)
  | ELF_MA_CDP           (* Paneve CDP architecture family *)
  | ELF_MA_KVARC         (* KM211 KVARC processor *)
  | ELF_MA_KMX8          (* KM211 KMX8 8-bit processor *)
  | ELF_MA_KMX16         (* KM211 KMX16 16-bit processor *)
  | ELF_MA_KMX32         (* KM211 KMX32 32-bit processor *)
  | ELF_MA_KM32          (* KM211 KM32 32-bit processor *)
  | ELF_MA_MCHP_PIC      (* Microchip 8-bit PIC(r) family *)
  | ELF_MA_XCORE         (* XMOS xCORE processor family *)
  | ELF_MA_BA2           (* Beyond BA2 CPU architecture *)
  | ELF_MA_BA1           (* Beyond BA1 CPU architecture *)  
  | ELF_MA_5600EX        (* Freescale 56800EX Digital Signal Controller (DSC) *)
  | ELF_MA_78KOR         (* 199 Renesas 78KOR family *)
  | ELF_MA_VideoCore5    (* Broadcom VideoCore V processor *)
  | ELF_MA_RL78          (* Renesas RL78 family *)
  | ELF_MA_Open8         (* Open8 8-bit RISC soft processing core *)
  | ELF_MA_ARC_Compact2  (* Synopsys ARCompact V2 *)
  | ELF_MA_CoreA_2nd     (* KIPO_KAIST Core-A 2nd generation processor family *)
  | ELF_MA_CoreA_1st     (* KIPO_KAIST Core-A 1st generation processor family *)
  | ELF_MA_CloudShield   (* CloudShield architecture family *)
  | ELF_MA_SLE9X         (* Infineon Technologies SLE9X core *)
  | ELF_MA_L10M          (* Intel L10M *)
  | ELF_MA_K10M          (* Intel K10M *)
  | ELF_MA_AArch64       (* ARM 64-bit architecture (AARCH64) *)
  | ELF_MA_AVR32         (* Atmel Corporation 32-bit microprocessor family *)
  | ELF_MA_STM8          (* STMicroelectronics STM8 8-bit microcontroller *)
  | ELF_MA_TILE64        (* Tilera TILE64 multicore architecture family *)
  | ELF_MA_TILEPro       (* Tilera TILEPro multicore architecture family *)
  | ELF_MA_MicroBlaze    (* Xilinix MicroBlaze 32-bit RISC soft processor core *)
  | ELF_MA_CUDA          (* NVIDIA CUDA architecture *)
  | ELF_MA_TILEGx        (* Tilera TILE-Gx multicore architecture family *)
  | ELF_MA_Cypress       (* Cypress M8C microprocessor *)
  | ELF_MA_R32C          (* Renesas R32C series microprocessors *)
  | ELF_MA_TriMedia      (* NXP Semiconductors TriMedia architecture family *)
  | ELF_MA_QDSP6         (* QUALCOMM DSP6 processor *)
  | ELF_MA_8051          (* Intel 8051 and variants *)
  | ELF_MA_STXP7X        (* STMicroelectronics STxP7x family of configurable and extensible RISC processors *)
  | ELF_MA_NDS32         (* Andes Technology compact code size embedded RISC processor family *)
  | ELF_MA_eCOG1X        (* Cyan Technology eCOG1X family *)
  | ELF_MA_MAXQ30        (* Dallas Semiconductor MAXQ30 Core Micro-controllers *)
  | ELF_MA_XIMO16        (* New Japan Radio (NJR) 16-bit DSP Processor *)
  | ELF_MA_MANIK         (* M2000 Reconfigurable RISC Microprocessor *)
  | ELF_MA_CrayNV2       (* Cray Inc. NV2 vector architecture *)
  | ELF_MA_RX            (* Renesas RX family *)
  | ELF_MA_METAG         (* Imagination Technologies META processor architecture *)
  | ELF_MA_MCST_Elbrus   (* MCST Elbrus general purpose hardware architecture *)
  | ELF_MA_eCOG16        (* Cyan Technology eCOG16 family *)
  | ELF_MA_CR16          (* National Semiconductor CompactRISC CR16 16-bit microprocessor *)
  | ELF_MA_ETPU          (* Freescale Extended Time Processing Unit *)
  | ELF_MA_TSK3000       (* Altium TSK3000 core *)
  | ELF_MA_RS08          (* Freescale RS08 embedded processor *)
  | ELF_MA_SHARC         (* Analog Devices SHARC family of 32-bit DSP processors *)
  | ELF_MA_eCOG2         (* Cyan Technology eCOG2 microprocessor *)
  | ELF_MA_Score7        (* Sunplus S+core7 RISC processor *)
  | ELF_MA_DSP24         (* New Japan Radio (NJR) 24-bit DSP Processor *)
  | ELF_MA_VideoCore3    (* Broadcom VideoCore III processor *)
  | ELF_MA_LatticeMICO32 (* RISC processor for Lattice FPGA architecture *)
  | ELF_MA_C17           (* Seiko Epson C17 family *)
  | ELF_MA_C6000         (* The Texas Instruments TMS320C6000 DSP family *)
  | ELF_MA_C2000         (* The Texas Instruments TMS320C2000 DSP family *)
  | ELF_MA_C5500         (* The Texas Instruments TMS320C55x DSP family *)
  | ELF_MA_MMDSP_PLUS    (* STMicroelectronics 64bit VLIW Data Signal Processor *)
  | ELF_MA_ZSP           (* LSI Logic 16-bit DSP Processor *)
  | ELF_MA_MMIX          (* Donald Knuth's educational 64-bit processor *)
  | ELF_MA_HUANY         (* Harvard University machine-independent object files *)
  | ELF_MA_Prism         (* SiTera Prism *)
  | ELF_MA_AVR           (* Atmel AVR 8-bit microcontroller *)
  | ELF_MA_FR30          (* Fujitsu FR30 *)
  | ELF_MA_D10V          (* Mitsubishi D10V *)
  | ELF_MA_D30V          (* Mitsubishi D30V *)
  | ELF_MA_v850          (* NEC v850 *)
  | ELF_MA_M32R          (* Mitsubishi M32R *)
  | ELF_MA_MN10300       (* Matsushita MN10300 *)
  | ELF_MA_MN10200       (* Matsushita MN10200 *)
  | ELF_MA_pJ            (* picoJava *)
  | ELF_MA_OpenRISC      (* OpenRISC 32-bit embedded processor *)
  | ELF_MA_ARC_Compact   (* ARC International ARCompact processor (old spelling/synonym: ELF_MA_ARC_A5) *)
  | ELF_MA_Xtensa        (* Tensilica Xtensa Architecture *)
  | ELF_MA_VideoCore     (* Alphamosaic VideoCore processor *)
  | ELF_MA_TMM_GPP       (* Thompson Multimedia General Purpose Processor *)
  | ELF_MA_NS32K         (* National Semiconductor 32000 series *)
  | ELF_MA_TPC           (* Tenor Network TPC processor *)
  | ELF_MA_SNP1K         (* Trebia SNP 1000 processor *)
  | ELF_MA_ST200         (* STMicroelectronics ST200 microcontroller *)
  | ELF_MA_IP2K          (* Ubicom IP2xxx microcontroller family *)
  | ELF_MA_MAX           (* MAX Processor *)
  | ELF_MA_CR            (* National Semiconductor CompactRISC microprocessor *)
  | ELF_MA_F2MC16        (* Fujitsu F2MC16 *)
  | ELF_MA_MSP430        (* Texas Instruments embedded microcontroller msp430 *)
  | ELF_MA_Blackfin      (* Analog Devices Blackfin (DSP) processor *)
  | ELF_MA_SE_C33        (* S1C33 Family of Seiko Epson processors *)
  | ELF_MA_SEP           (* Sharp embedded microprocessor *)
  | ELF_MA_Arca          (* Arca RISC Microprocessor *)
  | ELF_MA_Unicore       (* Microprocessor series from PKU-Unity Ltd. and MPRC of Peking University *)
  | ELF_MA_eXcess        (* eXcess: 16/32/64-bit configurable embedded CPU *)
  | ELF_MA_DXP           (* Icera Semiconductor Inc. Deep Execution Processor *)
  | ELF_MA_Altera_Nios2  (* Altera Nios II soft-core processor *)
  | ELF_MA_CRX           (* National Semiconductor CompactRISC CRX microprocessor *)
  | ELF_MA_XGATE         (* Motorola XGATE embedded processor *)
  | ELF_MA_C166          (* Infineon C16x/XC16x processor *)
  | ELF_MA_M16C          (* Renesas M16C series microprocessors *)
  | ELF_MA_dsPIC30F      (* Microchip Technology dsPIC30F Digital Signal Controller *)
  | ELF_MA_CE            (* Freescale Communication Engine RISC core *)
  | ELF_MA_M32C          (* Renesas M32C series microprocessors *)
  | ELF_MA_None          (* No machine *)
  | ELF_MA_M32           (* AT&T WE 32100 *)
  | ELF_MA_SPARC         (* SPARC *)
  | ELF_MA_386           (* Intel 80386 *)
  | ELF_MA_68K           (* Motorola 68000 *)
  | ELF_MA_88K           (* Motorola 88000 *)
  | ELF_MA_860           (* Intel 80860 *)
  | ELF_MA_MIPS          (* MIPS I Architecture *)
  | ELF_MA_S370          (* IBM System/370 Processor *)
  | ELF_MA_MIPS_RS3_LE   (* MIPS RS3000 Little-endian *)
  | ELF_MA_PARISC        (* Hewlett-Packard PA-RISC *)
  | ELF_MA_VPP500        (* Fujitsu VPP500 *)
  | ELF_MA_SPARC32PLUS   (* Enhanced instruction set SPARC *)
  | ELF_MA_960           (* Intel 80960 *)
  | ELF_MA_PPC           (* PowerPC *)
  | ELF_MA_PPC64         (* 64-bit PowerPC *)
  | ELF_MA_S390          (* IBM System/390 Processor *)
  | ELF_MA_SPU           (* IBM SPU/SPC *)
  | ELF_MA_V800          (* NEC V800 *)
  | ELF_MA_FR20          (* Fujitsu FR20 *)
  | ELF_MA_RH32          (* TRW RH-32 *)
  | ELF_MA_RCE           (* Motorola RCE *)
  | ELF_MA_ARM           (* ARM 32-bit architecture (AARCH32) *)
  | ELF_MA_Alpha         (* Digital Alpha *)
  | ELF_MA_SH            (* Hitachi SH *)
  | ELF_MA_SPARCv9       (* SPARC Version 9 *)
  | ELF_MA_TriCore       (* Siemens TriCore embedded processor *)
  | ELF_MA_ARC           (* Argonaut RISC Core, Argonaut Technologies Inc. *)
  | ELF_MA_H8_300        (* Hitachi H8/300 *)
  | ELF_MA_H8_300H       (* Hitachi H8/300H *)
  | ELF_MA_H8S           (* Hitachi H8S *)
  | ELF_MA_H8_500        (* Hitachi H8/500 *)
  | ELF_MA_IA_64         (* Intel IA-64 processor architecture *)
  | ELF_MA_MIPS_X        (* Stanford MIPS-X *)
  | ELF_MA_ColdFire      (* Motorola ColdFire *)
  | ELF_MA_68HC12        (* Motorola M68HC12 *)
  | ELF_MA_MMA           (* Fujitsu MMA Multimedia Accelerator *)
  | ELF_MA_PCP           (* Siemens PCP *)
  | ELF_MA_nCPU          (* Sony nCPU embedded RISC processor *)
  | ELF_MA_NDR1          (* Denso NDR1 microprocessor *)
  | ELF_MA_StarCore      (* Motorola Star*Core processor *)
  | ELF_MA_ME16          (* Toyota ME16 processor *)
  | ELF_MA_ST100         (* STMicroelectronics ST100 processor *)
  | ELF_MA_TinyJ         (* Advanced Logic Corp. TinyJ embedded processor family *)
  | ELF_MA_X86_64        (* AMD x86-64 architecture *)
  | ELF_MA_PDSP          (* Sony DSP Processor *)
  | ELF_MA_PDP10         (* Digital Equipment Corp. PDP-10 *)
  | ELF_MA_PDP11         (* Digital Equipment Corp. PDP-11 *)
  | ELF_MA_FX66          (* Siemens FX66 microcontroller *)
  | ELF_MA_ST9Plus       (* STMicroelectronics ST9+ 8/16 bit microcontroller *)
  | ELF_MA_ST7           (* STMicroelectronics ST7 8-bit microcontroller *)
  | ELF_MA_68HC16        (* Motorola MC68HC16 Microcontroller *)
  | ELF_MA_68HC11        (* Motorola MC68HC11 Microcontroller *)
  | ELF_MA_68HC08        (* Motorola MC68HC08 Microcontroller *)
  | ELF_MA_68HC05        (* Motorola MC68HC05 Microcontroller *)
  | ELF_MA_SVx           (* Silicon Graphics SVx *)
  | ELF_MA_ST19          (* STMicroelectronics ST19 8-bit microcontroller *)
  | ELF_MA_VAX           (* Digital VAX *)
  | ELF_MA_CRIS          (* Axis Communications 32-bit embedded processor *)
  | ELF_MA_Javelin       (* Infineon Technologies 32-bit embedded processor *)
  | ELF_MA_Firepath      (* Element 14 64-bit DSP Processor *)
  | ELF_MA_Intel209      (* Reserved by Intel *)
  | ELF_MA_Intel208      (* Reserved by Intel *)
  | ELF_MA_Intel207      (* Reserved by Intel *)
  | ELF_MA_Intel206      (* Reserved by Intel *)
  | ELF_MA_Intel205      (* Reserved by Intel *)
  | ELF_MA_Intel182      (* Reserved by Intel *)
  | ELF_MA_ARM184        (* Reserved by ARM *)
  | ELF_MA_Reserved6     (* Reserved for future use *)
  | ELF_MA_Reserved11    (* Reserved for future use *)
  | ELF_MA_Reserved12    (* Reserved for future use *)
  | ELF_MA_Reserved13    (* Reserved for future use *)
  | ELF_MA_Reserved14    (* Reserved for future use *)
  | ELF_MA_Reserved16    (* Reserved for future use *)
  | ELF_MA_Reserved24    (* Reserved for future use *)
  | ELF_MA_Reserved25    (* Reserved for future use *)
  | ELF_MA_Reserved26    (* Reserved for future use *)
  | ELF_MA_Reserved27    (* Reserved for future use *)
  | ELF_MA_Reserved28    (* Reserved for future use *)
  | ELF_MA_Reserved29    (* Reserved for future use *)
  | ELF_MA_Reserved30    (* Reserved for future use *)
  | ELF_MA_Reserved31    (* Reserved for future use *)
  | ELF_MA_Reserved32    (* Reserved for future use *)
  | ELF_MA_Reserved33    (* Reserved for future use *)
  | ELF_MA_Reserved34    (* Reserved for future use *)
  | ELF_MA_Reserved35    (* Reserved for future use *)
  | ELF_MA_Reserved121   (* Reserved for future use *)
  | ELF_MA_Reserved122   (* Reserved for future use *)
  | ELF_MA_Reserved123   (* Reserved for future use *)
  | ELF_MA_Reserved124   (* Reserved for future use *)
  | ELF_MA_Reserved125   (* Reserved for future use *)
  | ELF_MA_Reserved126   (* Reserved for future use *)
  | ELF_MA_Reserved127   (* Reserved for future use *)
  | ELF_MA_Reserved128   (* Reserved for future use *)
  | ELF_MA_Reserved129   (* Reserved for future use *)
  | ELF_MA_Reserved130   (* Reserved for future use *)
  | ELF_MA_Reserved143   (* Reserved for future use *)
  | ELF_MA_Reserved144   (* Reserved for future use *)
  | ELF_MA_Reserved145   (* Reserved for future use *)
  | ELF_MA_Reserved146   (* Reserved for future use *)
  | ELF_MA_Reserved147   (* Reserved for future use *)
  | ELF_MA_Reserved148   (* Reserved for future use *)
  | ELF_MA_Reserved149   (* Reserved for future use *)
  | ELF_MA_Reserved150   (* Reserved for future use *)
  | ELF_MA_Reserved151   (* Reserved for future use *)
  | ELF_MA_Reserved152   (* Reserved for future use *)
  | ELF_MA_Reserved153   (* Reserved for future use *)
  | ELF_MA_Reserved154   (* Reserved for future use *)
  | ELF_MA_Reserved155   (* Reserved for future use *)
  | ELF_MA_Reserved156   (* Reserved for future use *)
  | ELF_MA_Reserved157   (* Reserved for future use *)
  | ELF_MA_Reserved158   (* Reserved for future use *)
  | ELF_MA_Reserved159   (* Reserved for future use *)
  | ELF_MA_ReservedExt of nat (* Reserved for future use *)
*)

(** ELF version numbers.  Denotes the ELF version number of an ELF file.  Current is
  * defined to have a value of 1 with the present specification.  Extensions
  * may create versions of ELF with higher version numbers.
  *)

(** Invalid version *)
definition elf_ev_none  :: " nat "  where 
     " elf_ev_none = (( 0 :: nat))"

(** Current version *)
definition elf_ev_current  :: " nat "  where 
     " elf_ev_current = (( 1 :: nat))"


(** [string_of_elf_version_number m] produces a string representation of the
  * numeric encoding [m] of the ELF version number.
  *)
(*val string_of_elf_version_number : natural -> string*)

(** Check that an extended version number is correct (i.e. greater than 1). *)
definition is_valid_extended_version_number  :: " nat \<Rightarrow> bool "  where 
     " is_valid_extended_version_number (n :: nat) = ( n >( 1 :: nat))"


(** Identification indices.  The initial bytes of an ELF header (and an object
  * file) correspond to the e_ident member.
  *)

(** File identification *)
definition elf_ii_mag0  :: " nat "  where 
     " elf_ii_mag0 = (( 0 :: nat))"

(** File identification *)
definition elf_ii_mag1  :: " nat "  where 
     " elf_ii_mag1 = (( 1 :: nat))"

(** File identification *)
definition elf_ii_mag2  :: " nat "  where 
     " elf_ii_mag2 = (( 2 :: nat))"

(** File identification *)
definition elf_ii_mag3  :: " nat "  where 
     " elf_ii_mag3 = (( 3 :: nat))"

(** File class *)
definition elf_ii_class  :: " nat "  where 
     " elf_ii_class = (( 4 :: nat))"

(** Data encoding *)
definition elf_ii_data  :: " nat "  where 
     " elf_ii_data = (( 5 :: nat))"

(** File version *)
definition elf_ii_version  :: " nat "  where 
     " elf_ii_version = (( 6 :: nat))"

(** Operating system/ABI identification *)
definition elf_ii_osabi  :: " nat "  where 
     " elf_ii_osabi = (( 7 :: nat))"

(** ABI version *)
definition elf_ii_abiversion  :: " nat "  where 
     " elf_ii_abiversion = (( 8 :: nat))"

(** Start of padding bytes *)
definition elf_ii_pad  :: " nat "  where 
     " elf_ii_pad = (( 9 :: nat))"

(** Size of e*_ident[] *)
definition elf_ii_nident  :: " nat "  where 
     " elf_ii_nident = (( 16 :: nat))"


(** Magic number indices.  A file's first 4 bytes hold a ``magic number,''
  * identifying the file as an ELF object file.
  *)

(** Position: e*_ident[elf_ii_mag0], 0x7f magic number *)
definition elf_mn_mag0  :: " nat "  where 
     " elf_mn_mag0 = (( 127 :: nat))"

(** Position: e*_ident[elf_ii_mag1], 'E' format identifier *)
definition elf_mn_mag1  :: " nat "  where 
     " elf_mn_mag1 = (( 69 :: nat))"

(** Position: e*_ident[elf_ii_mag2], 'L' format identifier *)
definition elf_mn_mag2  :: " nat "  where 
     " elf_mn_mag2 = (( 76 :: nat))"

(** Position: e*_ident[elf_ii_mag3], 'F' format identifier *)
definition elf_mn_mag3  :: " nat "  where 
     " elf_mn_mag3 = (( 70 :: nat))"


(** ELf file classes.  The file format is designed to be portable among machines
  * of various sizes, without imposing the sizes of the largest machine on the
  * smallest. The class of the file defines the basic types used by the data
  * structures of the object file container itself.
  *)

(** Invalid class *)
definition elf_class_none  :: " nat "  where 
     " elf_class_none = (( 0 :: nat))"

(** 32 bit objects *)
definition elf_class_32  :: " nat "  where 
     " elf_class_32 = (( 1 :: nat))"

(** 64 bit objects *)
definition elf_class_64  :: " nat "  where 
     " elf_class_64 = (( 2 :: nat))"


(** [string_of_elf_file_class m] produces a string representation of the numeric
  * encoding [m] of the ELF file class.
  *)
(*val string_of_elf_file_class : natural -> string*)

(** ELF data encodings.  Byte e_ident[elf_ei_data] specifies the encoding of both the
  * data structures used by object file container and data contained in object
  * file sections.
  *)

(** Invalid data encoding *)
definition elf_data_none  :: " nat "  where 
     " elf_data_none = (( 0 :: nat))"

(** Two's complement values, least significant byte occupying lowest address *)
definition elf_data_2lsb  :: " nat "  where 
     " elf_data_2lsb = (( 1 :: nat))"

(** Two's complement values, most significant byte occupying lowest address *)
definition elf_data_2msb  :: " nat "  where 
     " elf_data_2msb = (( 2 :: nat))"


(** [string_of_elf_data_encoding m] produces a string representation of the
  * numeric encoding [m] of the ELF data encoding.
  *)
(*val string_of_elf_data_encoding : natural -> string*)

(** OS and ABI versions.  Byte e_ident[elf_ei_osabi] identifies the OS- or
  * ABI-specific ELF extensions used by this file. Some fields in other ELF
  * structures have flags and values that have operating system and/or ABI
  * specific meanings; the interpretation of those fields is determined by the
  * value of this byte.
  *)

(** No extensions or unspecified *)
definition elf_osabi_none  :: " nat "  where 
     " elf_osabi_none = (( 0 :: nat))"

(** Hewlett-Packard HP-UX *)
definition elf_osabi_hpux  :: " nat "  where 
     " elf_osabi_hpux = (( 1 :: nat))"

(** NetBSD *)
definition elf_osabi_netbsd  :: " nat "  where 
     " elf_osabi_netbsd = (( 2 :: nat))"

(** GNU *)
definition elf_osabi_gnu  :: " nat "  where 
     " elf_osabi_gnu = (( 3 :: nat))"

(** Linux, historical alias for GNU *)
definition elf_osabi_linux  :: " nat "  where 
     " elf_osabi_linux = (( 3 :: nat))"

(** Sun Solaris *)
definition elf_osabi_solaris  :: " nat "  where 
     " elf_osabi_solaris = (( 6 :: nat))"

(** AIX *)
definition elf_osabi_aix  :: " nat "  where 
     " elf_osabi_aix = (( 7 :: nat))"

(** IRIX *)
definition elf_osabi_irix  :: " nat "  where 
     " elf_osabi_irix = (( 8 :: nat))"

(** FreeBSD *)
definition elf_osabi_freebsd  :: " nat "  where 
     " elf_osabi_freebsd = (( 9 :: nat))"

(** Compaq Tru64 Unix *)
definition elf_osabi_tru64  :: " nat "  where 
     " elf_osabi_tru64 = (( 10 :: nat))"

(** Novell Modesto *)
definition elf_osabi_modesto  :: " nat "  where 
     " elf_osabi_modesto = (( 11 :: nat))"

(** OpenBSD *)
definition elf_osabi_openbsd  :: " nat "  where 
     " elf_osabi_openbsd = (( 12 :: nat))"

(** OpenVMS *)
definition elf_osabi_openvms  :: " nat "  where 
     " elf_osabi_openvms = (( 13 :: nat))"

(** Hewlett-Packard Non-stop Kernel *)
definition elf_osabi_nsk  :: " nat "  where 
     " elf_osabi_nsk = (( 14 :: nat))"

(** Amiga Research OS *)
definition elf_osabi_aros  :: " nat "  where 
     " elf_osabi_aros = (( 15 :: nat))"

(** FenixOS highly-scalable multi-core OS *)
definition elf_osabi_fenixos  :: " nat "  where 
     " elf_osabi_fenixos = (( 16 :: nat))"


(** [string_of_elf_osabi_version m] produces a string representation of the
  * numeric encoding [m] of the ELF OSABI version.
  *)
(*val string_of_elf_osabi_version : natural -> string*)

(** Checks an architecture defined OSABI version is correct, i.e. in the range
  * 64 to 255 inclusive.
  *)
definition is_valid_architecture_defined_osabi_version  :: " nat \<Rightarrow> bool "  where 
     " is_valid_architecture_defined_osabi_version (n :: nat) = (  
(n \<ge>( 64 :: nat)) \<and> (n \<le>( 255 :: nat)))"


(** ELF Header type *)

(** [ei_nident] is the fixed length of the identification field in the
  * [elf32_ehdr] type.
  *)
(*val ei_nident : nat*)
definition ei_nident  :: " nat "  where 
     " ei_nident = (( 16 :: nat))"


(** [elf32_header] is the type of headers for 32-bit ELF files.
  *)
record elf32_header =
  
 elf32_ident    ::" Elf_Types_Local.unsigned_char list " (** Identification field *)
   
 elf32_type     ::" uint32 "         (** The object file type *)
   
 elf32_machine  ::" uint32 "         (** Required machine architecture *)
   
 elf32_version  ::" uint32 "         (** Object file version *)
   
 elf32_entry    ::" uint32 "         (** Virtual address for transfer of control *)
   
 elf32_phoff    ::" uint32 "          (** Program header table offset in bytes *)
   
 elf32_shoff    ::" uint32 "          (** Section header table offset in bytes *)
   
 elf32_flags    ::" uint32 "         (** Processor-specific flags *)
   
 elf32_ehsize   ::" uint32 "         (** ELF header size in bytes *)
   
 elf32_phentsize::" uint32 "         (** Program header table entry size in bytes *)
   
 elf32_phnum    ::" uint32 "         (** Number of entries in program header table *)
   
 elf32_shentsize::" uint32 "         (** Section header table entry size in bytes *)
   
 elf32_shnum    ::" uint32 "         (** Number of entries in section header table *)
   
 elf32_shstrndx ::" uint32 "         (** Section header table entry for section name string table *)
   


record 'a HasElf32Header_class=

  get_elf32_header_method ::" 'a \<Rightarrow> elf32_header "



(** [elf64_header] is the type of headers for 32-bit ELF files.
  *)
record elf64_header =
  
 elf64_ident    ::" Elf_Types_Local.unsigned_char list " (** Identification field *)
   
 elf64_type     ::" uint32 "         (** The object file type *)
   
 elf64_machine  ::" uint32 "         (** Required machine architecture *)
   
 elf64_version  ::" uint32 "         (** Object file version *)
   
 elf64_entry    ::" Elf_Types_Local.uint64 "         (** Virtual address for transfer of control *)
   
 elf64_phoff    ::" uint64 "          (** Program header table offset in bytes *)
   
 elf64_shoff    ::" uint64 "          (** Section header table offset in bytes *)
   
 elf64_flags    ::" uint32 "         (** Processor-specific flags *)
   
 elf64_ehsize   ::" uint32 "         (** ELF header size in bytes *)
   
 elf64_phentsize::" uint32 "         (** Program header table entry size in bytes *)
   
 elf64_phnum    ::" uint32 "         (** Number of entries in program header table *)
   
 elf64_shentsize::" uint32 "         (** Section header table entry size in bytes *)
   
 elf64_shnum    ::" uint32 "         (** Number of entries in section header table *)
   
 elf64_shstrndx ::" uint32 "         (** Section header table entry for section name string table *)
   


record 'a HasElf64Header_class=

  get_elf64_header_method ::" 'a \<Rightarrow> elf64_header "



(*val is_elf32_executable_file : elf32_header -> bool*)
definition is_elf32_executable_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_executable_file hdr = (
  unat(elf32_type   hdr) = elf_ft_exec )"


(*val is_elf64_executable_file : elf64_header -> bool*)
definition is_elf64_executable_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_executable_file hdr = (
  unat(elf64_type   hdr) = elf_ft_exec )"


(*val is_elf32_shared_object_file : elf32_header -> bool*)
definition is_elf32_shared_object_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_shared_object_file hdr = (
  unat(elf32_type   hdr) = elf_ft_dyn )"


(*val is_elf64_shared_object_file : elf64_header -> bool*)
definition is_elf64_shared_object_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_shared_object_file hdr = (
  unat(elf64_type   hdr) = elf_ft_dyn )"


(*val is_elf32_relocatable_file : elf32_header -> bool*)
definition is_elf32_relocatable_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_relocatable_file hdr = (
  unat(elf32_type   hdr) = elf_ft_rel )"


(*val is_elf64_relocatable_file : elf64_header -> bool*)
definition is_elf64_relocatable_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_relocatable_file hdr = (
  unat(elf64_type   hdr) = elf_ft_rel )"


(*val is_elf32_linkable_file : elf32_header -> bool*)
definition is_elf32_linkable_file  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_linkable_file hdr = (
  is_elf32_shared_object_file hdr \<or> is_elf32_relocatable_file hdr )"


(*val is_elf64_linkable_file : elf64_header -> bool*)
definition is_elf64_linkable_file  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_linkable_file hdr = (
  is_elf64_shared_object_file hdr \<or> is_elf64_relocatable_file hdr )"


(*val get_elf32_machine_architecture : elf32_header -> natural*)
definition get_elf32_machine_architecture  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_machine_architecture hdr = (
  unat(elf32_machine   hdr))"


(*val get_elf64_machine_architecture : elf64_header -> natural*)
definition get_elf64_machine_architecture  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_machine_architecture hdr = (
  unat(elf64_machine   hdr))"


(*val get_elf32_osabi : elf32_header -> natural*)
definition get_elf32_osabi  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_osabi hdr = (
  (case  index(elf32_ident   hdr) ( elf_ii_osabi) of
      Some osabi => unat osabi
  ))"
 (* Partial: should never return Nothing *)

(*val get_elf64_osabi : elf64_header -> natural*)
definition get_elf64_osabi  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_osabi hdr = (
  (case  index(elf64_ident   hdr) ( elf_ii_osabi) of
      Some osabi => unat osabi
  ))"
 (* Partial: should never return Nothing *)

(** [deduce_endian] deduces the endianness of an ELF file based on the ELF
  * header's magic number.
  *)
(*val deduce_endianness : list unsigned_char -> endianness*)
definition deduce_endianness  :: "(Elf_Types_Local.unsigned_char)list \<Rightarrow> endianness "  where 
     " deduce_endianness id1 = (
  (case  index id1(( 5 :: nat)) of
      None => Little (* XXX: random default as read of magic number has failed! *)
    | Some v  =>
      if unat v = elf_data_2lsb then
        Little
      else if unat v = elf_data_2msb then
        Big
      else
        Little (* XXX: random default as value is not valid! *)
  ))"


(*val get_elf32_header_endianness : elf32_header -> endianness*)
definition get_elf32_header_endianness  :: " elf32_header \<Rightarrow> endianness "  where 
     " get_elf32_header_endianness hdr = (
  deduce_endianness ((elf32_ident   hdr)))"


(*val get_elf64_header_endianness : elf64_header -> endianness*)
definition get_elf64_header_endianness  :: " elf64_header \<Rightarrow> endianness "  where 
     " get_elf64_header_endianness hdr = (
  deduce_endianness ((elf64_ident   hdr)))"


(** The [hdr_print_bundle] type is used to tidy up other type signatures.  Some of the
  * top-level string_of_ functions require six or more functions passed to them,
  * which quickly gets out of hand.  This type is used to reduce that complexity.
  * The first component of the type is an OS specific print function, the second is
  * a processor specific print function.
  *)
type_synonym hdr_print_bundle =" (nat \<Rightarrow> string) * (nat \<Rightarrow> string)"

(*val string_of_elf32_header : hdr_print_bundle -> elf32_header -> string*)

(*val string_of_elf64_header : hdr_print_bundle -> elf64_header -> string*)

(*val string_of_elf32_header_default : elf32_header -> string*)

(*val string_of_elf64_header_default : elf64_header -> string*)

(*val bytes_of_elf32_header : elf32_header -> byte_sequence*)
definition bytes_of_elf32_header  :: " elf32_header \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf32_header hdr = (
  (let endian = (deduce_endianness(elf32_ident   hdr)) in
    Byte_sequence.from_byte_lists [
      List.map id(elf32_ident   hdr)
    , bytes_of_elf32_half endian(elf32_type   hdr)
    , bytes_of_elf32_half endian(elf32_machine   hdr)
    , bytes_of_elf32_word endian(elf32_version   hdr)
    , bytes_of_elf32_addr endian(elf32_entry   hdr)
    , bytes_of_elf32_off  endian(elf32_phoff   hdr)
    , bytes_of_elf32_off  endian(elf32_shoff   hdr)
    , bytes_of_elf32_word endian(elf32_flags   hdr)
    , bytes_of_elf32_half endian(elf32_ehsize   hdr)
    , bytes_of_elf32_half endian(elf32_phentsize   hdr)
    , bytes_of_elf32_half endian(elf32_phnum   hdr)
    , bytes_of_elf32_half endian(elf32_shentsize   hdr)
    , bytes_of_elf32_half endian(elf32_shnum   hdr)
    , bytes_of_elf32_half endian(elf32_shstrndx   hdr)
    ]))"


(*val read_elf32_header : byte_sequence -> error (elf32_header * byte_sequence)*)
definition read_elf32_header  :: " byte_sequence \<Rightarrow>(elf32_header*byte_sequence)error "  where 
     " read_elf32_header bs = (
	repeatM' ei_nident bs (read_unsigned_char default_endianness) >>= (\<lambda> (ident, bs) . 
  (let endian = (deduce_endianness ident) in
	read_elf32_half endian bs >>= (\<lambda> (typ1, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (machine, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (version, bs) . 
	read_elf32_addr endian bs >>= (\<lambda> (entry, bs) . 
	read_elf32_off  endian bs >>= (\<lambda> (phoff, bs) . 
	read_elf32_off  endian bs >>= (\<lambda> (shoff, bs) . 
	read_elf32_word endian bs >>= (\<lambda> (flags, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (ehsize, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (phentsize, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (phnum, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (shentsize, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (shnum, bs) . 
	read_elf32_half endian bs >>= (\<lambda> (shstrndx, bs) . 
    (case  index ident(( 4 :: nat)) of
        None => error_fail (''read_elf32_header: transcription of ELF identifier failed'')
      | Some c  =>
        if unat c = elf_class_32 then
		      error_return ((| elf32_ident = ident, elf32_type  = typ1,
                      elf32_machine = machine, elf32_version = version,
                      elf32_entry = entry, elf32_phoff = phoff,
                      elf32_shoff = shoff, elf32_flags = flags,
                      elf32_ehsize = ehsize, elf32_phentsize = phentsize,
                      elf32_phnum = phnum, elf32_shentsize = shentsize,
                      elf32_shnum = shnum, elf32_shstrndx = shstrndx |), bs)
        else
          error_fail (''read_elf32_header: not a 32-bit ELF file'')
    )))))))))))))))))"


(*val bytes_of_elf64_header : elf64_header -> byte_sequence*)
definition bytes_of_elf64_header  :: " elf64_header \<Rightarrow> byte_sequence "  where 
     " bytes_of_elf64_header hdr = (
  (let endian = (deduce_endianness(elf64_ident   hdr)) in
    Byte_sequence.from_byte_lists [
      List.map id(elf64_ident   hdr)
    , bytes_of_elf64_half endian(elf64_type   hdr)
    , bytes_of_elf64_half endian(elf64_machine   hdr)
    , bytes_of_elf64_word endian(elf64_version   hdr)
    , bytes_of_elf64_addr endian(elf64_entry   hdr)
    , bytes_of_elf64_off  endian(elf64_phoff   hdr)
    , bytes_of_elf64_off  endian(elf64_shoff   hdr)
    , bytes_of_elf64_word endian(elf64_flags   hdr)
    , bytes_of_elf64_half endian(elf64_ehsize   hdr)
    , bytes_of_elf64_half endian(elf64_phentsize   hdr)
    , bytes_of_elf64_half endian(elf64_phnum   hdr)
    , bytes_of_elf64_half endian(elf64_shentsize   hdr)
    , bytes_of_elf64_half endian(elf64_shnum   hdr)
    , bytes_of_elf64_half endian(elf64_shstrndx   hdr)
    ]))"


(*val read_elf64_header : byte_sequence -> error (elf64_header * byte_sequence)*)
definition read_elf64_header  :: " byte_sequence \<Rightarrow>(elf64_header*byte_sequence)error "  where 
     " read_elf64_header bs = (
  repeatM' ei_nident bs (read_unsigned_char default_endianness) >>= (\<lambda> (ident, bs) . 
  (let endian = (deduce_endianness ident) in
  read_elf64_half endian bs >>= (\<lambda> (typ1, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (machine, bs) . 
  read_elf64_word endian bs >>= (\<lambda> (version, bs) . 
  read_elf64_addr endian bs >>= (\<lambda> (entry, bs) . 
  read_elf64_off  endian bs >>= (\<lambda> (phoff, bs) . 
  read_elf64_off  endian bs >>= (\<lambda> (shoff, bs) . 
  read_elf64_word endian bs >>= (\<lambda> (flags, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (ehsize, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (phentsize, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (phnum, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (shentsize, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (shnum, bs) . 
  read_elf64_half endian bs >>= (\<lambda> (shstrndx, bs) . 
    (case  index ident(( 4 :: nat)) of
        None => error_fail (''read_elf64_header: transcription of ELF identifier failed'')
      | Some c  =>
        if unat c = elf_class_64 then
          error_return ((| elf64_ident = ident, elf64_type  = typ1,
                     elf64_machine = machine, elf64_version = version,
                     elf64_entry = entry, elf64_phoff = phoff,
                     elf64_shoff = shoff, elf64_flags = flags,
                     elf64_ehsize = ehsize, elf64_phentsize = phentsize,
                     elf64_phnum = phnum, elf64_shentsize = shentsize,
                     elf64_shnum = shnum, elf64_shstrndx = shstrndx |), bs)
        else
          error_fail (''read_elf64_header: not a 64-bit ELF file'')
    )))))))))))))))))"


(*val is_elf32_header_padding_correct : elf32_header -> bool*)
definition is_elf32_header_padding_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_padding_correct ehdr = (  
(index(elf32_ident   ehdr)(( 9 :: nat))  = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 10 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 11 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 12 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 13 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 14 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)))) \<and>  
(index(elf32_ident   ehdr)(( 15 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat))))))))))"


(*val is_elf32_header_magic_number_correct : elf32_header -> bool*)
definition is_elf32_header_magic_number_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_magic_number_correct ehdr = (  
(index(elf32_ident   ehdr)(( 0 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 127 :: nat)))) \<and>
  ((index(elf32_ident   ehdr)(( 1 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 69 :: nat))))  \<and>
  ((index(elf32_ident   ehdr)(( 2 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 76 :: nat))))  \<and>  
(index(elf32_ident   ehdr)(( 3 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 70 :: nat)))))))"


(*val is_elf32_header_class_correct : elf32_header -> bool*)
definition is_elf32_header_class_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_class_correct ehdr = (
  index(elf32_ident   ehdr)(( 4 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 1 :: nat))))"


(*val is_elf32_header_version_correct : elf32_header -> bool*)
definition is_elf32_header_version_correct  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_version_correct ehdr = (
  index(elf32_ident   ehdr)(( 6 :: nat)) = Some (Elf_Types_Local.unsigned_char_of_nat(( 1 :: nat))))"


(** [is_valid_elf32_header] checks whether an [elf32_header] value is a valid 32-bit
  * ELF file header (i.e. [elf32_ident] is [ei_nident] entries long, and other
  * constraints on headers).
  *)
(*val is_elf32_header_valid : elf32_header -> bool*)
definition is_elf32_header_valid  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_valid ehdr = (  
(List.length(elf32_ident   ehdr) = ei_nident) \<and>  
(is_elf32_header_magic_number_correct ehdr \<and>  
(is_elf32_header_padding_correct ehdr \<and>  
(is_elf32_header_class_correct ehdr \<and>
  is_elf32_header_version_correct ehdr))))"


(** [get_elf32_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf32_header_program_table_size : elf32_header -> natural*)
definition get_elf32_header_program_table_size  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_header_program_table_size ehdr = (
  (let phentsize = (unat(elf32_phentsize   ehdr)) in
  (let phnum     = (unat(elf32_phnum   ehdr)) in
    phentsize * phnum)))"


(** [get_elf64_header_program_table_size] calculates the size of the program table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf64_header_program_table_size : elf64_header -> natural*)
definition get_elf64_header_program_table_size  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_header_program_table_size ehdr = (
  (let phentsize = (unat(elf64_phentsize   ehdr)) in
  (let phnum     = (unat(elf64_phnum   ehdr)) in
    phentsize * phnum)))"


(** [is_elf32_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
(*val is_elf32_header_section_table_present : elf32_header -> bool*)
definition is_elf32_header_section_table_present  :: " elf32_header \<Rightarrow> bool "  where 
     " is_elf32_header_section_table_present ehdr = (
  \<not> (unat(elf32_shoff   ehdr) =( 0 :: nat)))"


(** [is_elf64_header_section_table_present] calculates whether a section table
  * is present in the ELF file or not.
  *)
(*val is_elf64_header_section_table_present : elf64_header -> bool*)
definition is_elf64_header_section_table_present  :: " elf64_header \<Rightarrow> bool "  where 
     " is_elf64_header_section_table_present ehdr = (
  \<not> (unat(elf64_shoff   ehdr) =( 0 :: nat)))"


(** [get_elf32_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf32_header_section_table_size : elf32_header -> natural*)
definition get_elf32_header_section_table_size  :: " elf32_header \<Rightarrow> nat "  where 
     " get_elf32_header_section_table_size ehdr = (
  (let shentsize = (unat(elf32_shentsize   ehdr)) in
  (let shnum     = (unat(elf32_shnum   ehdr)) in
    shentsize * shnum)))"


(** [get_elf64_header_section_table_size] calculates the size of the section table
  * (entry size x number of entries) based on data in the ELF header.
  *)
(*val get_elf64_header_section_table_size : elf64_header -> natural*)
definition get_elf64_header_section_table_size  :: " elf64_header \<Rightarrow> nat "  where 
     " get_elf64_header_section_table_size ehdr = (
  (let shentsize = (unat(elf64_shentsize   ehdr)) in
  (let shnum     = (unat(elf64_shnum   ehdr)) in
    shentsize * shnum)))"

end
