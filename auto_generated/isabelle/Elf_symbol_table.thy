header{*Generated by Lem from elf_symbol_table.lem.*}

theory "Elf_symbol_table" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_bool" 
	 "Lem_list" 
	 "Lem_maybe" 
	 "Lem_num" 
	 "Lem_string" 
	 "Lem_tuple" 
	 "Byte_sequence" 
	 "Error" 
	 "Missing_pervasives" 
	 "Show" 
	 "Elf_types" 
	 "Endianness" 
	 "String_table" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import Tuple*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

(*open import Elf_types*)
(*open import Endianness*)
(*open import String_table*)

(** Undefined symbol index *)

definition stn_undef  :: " nat "  where 
     " stn_undef = (( 0 :: nat))"


(** Symbol binding *)

definition stb_local  :: " nat "  where 
     " stb_local = (( 0 :: nat))"

definition stb_global  :: " nat "  where 
     " stb_global = (( 1 :: nat))"

definition stb_weak  :: " nat "  where 
     " stb_weak = (( 2 :: nat))"

definition stb_loos  :: " nat "  where 
     " stb_loos = (( 10 :: nat))"

definition stb_hios  :: " nat "  where 
     " stb_hios = (( 12 :: nat))"

definition stb_loproc  :: " nat "  where 
     " stb_loproc = (( 13 :: nat))"

definition stb_hiproc  :: " nat "  where 
     " stb_hiproc = (( 15 :: nat))"


(*val string_of_symbol_binding : nat -> (nat -> string) -> (nat -> string) -> string*)
definition string_of_symbol_binding  :: " nat \<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow> string "  where 
     " string_of_symbol_binding m os proc = (
  if m = stb_local then
    (''STB_LOCAL'')
  else if m = stb_global then
    (''STB_GLOBAL'')
  else if m = stb_weak then
    (''STB_WEAK'')
  else if (m \<ge> stb_loos) \<and> (m \<le> stb_hios) then
    os m
  else if (m \<ge> stb_loproc) \<and> (m \<le> stb_hiproc) then
    proc m
  else
    (''Invalid symbol binding''))"


(** Symbol types *)

definition stt_notype  :: " nat "  where 
     " stt_notype = (( 0 :: nat))"

definition stt_object  :: " nat "  where 
     " stt_object = (( 1 :: nat))"

definition stt_func  :: " nat "  where 
     " stt_func = (( 2 :: nat))"

definition stt_section  :: " nat "  where 
     " stt_section = (( 3 :: nat))"

definition stt_file  :: " nat "  where 
     " stt_file = (( 4 :: nat))"

definition stt_common  :: " nat "  where 
     " stt_common = (( 5 :: nat))"

definition stt_tls  :: " nat "  where 
     " stt_tls = (( 6 :: nat))"

definition stt_loos  :: " nat "  where 
     " stt_loos = (( 10 :: nat))"

definition stt_hios  :: " nat "  where 
     " stt_hios = (( 12 :: nat))"

definition stt_loproc  :: " nat "  where 
     " stt_loproc = (( 13 :: nat))"

definition stt_hiproc  :: " nat "  where 
     " stt_hiproc = (( 15 :: nat))"


(*val string_of_symbol_type : natural -> (natural -> string) -> (natural -> string) -> string*)
definition string_of_symbol_type  :: " nat \<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow>(nat \<Rightarrow> string)\<Rightarrow> string "  where 
     " string_of_symbol_type m os proc = (
  if m = stt_notype then
    (''STT_NOTYPE'')
  else if m = stt_object then
    (''STT_OBJECT'')
  else if m = stt_func then
    (''STT_FUNC'')
  else if m = stt_section then
    (''STT_SECTION'')
  else if m = stt_file then
    (''STT_FILE'')
  else if m = stt_common then
    (''STT_COMMON'')
  else if m = stt_tls then
    (''STT_TLS'')
  else if (m \<ge> stt_loos) \<and> (m \<le> stt_hios) then
    os m
  else if (m \<ge> stt_loproc) \<and> (m \<le> stt_hiproc) then
    proc m
  else
    (''Invalid symbol type''))"


(** Symbol visibility *)

definition stv_default  :: " nat "  where 
     " stv_default = (( 0 :: nat))"

definition stv_internal  :: " nat "  where 
     " stv_internal = (( 1 :: nat))"

definition stv_hidden  :: " nat "  where 
     " stv_hidden = (( 2 :: nat))"

definition stv_protected  :: " nat "  where 
     " stv_protected = (( 3 :: nat))"


(*val string_of_symbol_visibility : natural -> string*)
definition string_of_symbol_visibility  :: " nat \<Rightarrow> string "  where 
     " string_of_symbol_visibility m = (
  if m = stv_default then
    (''STV_DEFAULT'')
  else if m = stv_internal then
    (''STV_INTERNAL'')
  else if m = stv_hidden then
    (''STV_HIDDEN'')
  else if m = stv_protected then
    (''STV_PROTECTED'')
  else
    (''Invalid symbol visibility''))"


(** ELF32 symbol table type *)

record elf32_symbol_table_entry =
  
 elf32_st_name  ::" uint32 "
   
 elf32_st_value ::" uint32 "
   
 elf32_st_size  ::" uint32 "
   
 elf32_st_info  ::" Elf_Types_Local.unsigned_char "
   
 elf32_st_other ::" Elf_Types_Local.unsigned_char "
   
 elf32_st_shndx ::" uint32 "
   


(** Extraction of symbol table data *)

(* Functions below common to 32- and 64-bit! *)

(*val get_symbol_binding : unsigned_char -> natural*)
definition get_symbol_binding  :: " Elf_Types_Local.unsigned_char \<Rightarrow> nat "  where 
     " get_symbol_binding entry = (
  unat (Elf_Types_Local.unsigned_char_rshift entry(( 4 :: nat))))"


(*val get_symbol_type : unsigned_char -> natural*)
definition get_symbol_type  :: " Elf_Types_Local.unsigned_char \<Rightarrow> nat "  where 
     " get_symbol_type entry = (
  unat (Elf_Types_Local.unsigned_char_land entry (Elf_Types_Local.unsigned_char_of_nat(( 15 :: nat)))))"
 (* 0xf *)

(*val get_symbol_info : unsigned_char -> unsigned_char -> natural*)
definition get_symbol_info  :: " Elf_Types_Local.unsigned_char \<Rightarrow> Elf_Types_Local.unsigned_char \<Rightarrow> nat "  where 
     " get_symbol_info entry0 entry1 = (
  unat (Elf_Types_Local.unsigned_char_plus
    (Elf_Types_Local.unsigned_char_lshift entry0(( 4 :: nat))) (Elf_Types_Local.unsigned_char_land entry1
      (Elf_Types_Local.unsigned_char_of_nat(( 15 :: nat))))))"
 (*0xf*)  

(*val get_symbol_visibility : unsigned_char -> natural*)
definition get_symbol_visibility  :: " Elf_Types_Local.unsigned_char \<Rightarrow> nat "  where 
     " get_symbol_visibility entry = (
  unat (Elf_Types_Local.unsigned_char_land entry (Elf_Types_Local.unsigned_char_of_nat(( 3 :: nat)))))"
 (* 0x3*)

type_synonym symtab_print_bundle =" (nat \<Rightarrow> string) * (nat \<Rightarrow> string)"

(*val string_of_elf32_symbol_table_entry : elf32_symbol_table_entry -> string*)

type_synonym elf32_symbol_table =" elf32_symbol_table_entry list "

(*val string_of_elf32_symbol_table : elf32_symbol_table -> string*)

record 'a HasElf32SymbolTable_class=

  get_elf32_symbol_table_method ::" 'a \<Rightarrow> elf32_symbol_table "



(*val read_elf32_symbol_table_entry : endianness -> byte_sequence -> error (elf32_symbol_table_entry * byte_sequence)*)
definition read_elf32_symbol_table_entry  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>(elf32_symbol_table_entry*byte_sequence)error "  where 
     " read_elf32_symbol_table_entry endian bs0 = (
  read_elf32_word endian bs0 >>= (\<lambda> (st_name, bs0) . 
  read_elf32_addr endian bs0 >>= (\<lambda> (st_value, bs0) . 
  read_elf32_word endian bs0 >>= (\<lambda> (st_size, bs0) . 
  read_unsigned_char endian bs0 >>= (\<lambda> (st_info, bs0) . 
  read_unsigned_char endian bs0 >>= (\<lambda> (st_other, bs0) . 
  read_elf32_half endian bs0 >>= (\<lambda> (st_shndx, bs0) . 
    error_return ((| elf32_st_name = st_name, elf32_st_value = st_value,
                 elf32_st_size = st_size, elf32_st_info = st_info,
                 elf32_st_other = st_other, elf32_st_shndx = st_shndx |), bs0))))))))"


(*val read_elf32_symbol_table : endianness -> byte_sequence -> error elf32_symbol_table*)
function (sequential,domintros)  read_elf32_symbol_table  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " read_elf32_symbol_table endian bs0 = (
  if length bs0 =( 0 :: nat) then
    error_return []
  else
    read_elf32_symbol_table_entry endian bs0 >>= (\<lambda> (head, bs0) . 
    read_elf32_symbol_table endian bs0 >>= (\<lambda> tail . 
    error_return (head # tail))))" 
by pat_completeness auto


(** ELF64 symbol table type *)

record elf64_symbol_table_entry =
  
 elf64_st_name  ::" uint32 "
   
 elf64_st_info  ::" Elf_Types_Local.unsigned_char "
   
 elf64_st_other ::" Elf_Types_Local.unsigned_char "
   
 elf64_st_shndx ::" uint32 "
   
 elf64_st_value ::" Elf_Types_Local.uint64 "
   
 elf64_st_size  ::" uint64 "
   


(*val string_of_elf64_symbol_table_entry : elf64_symbol_table_entry -> string*)

type_synonym elf64_symbol_table =" elf64_symbol_table_entry list "

(*val string_of_elf64_symbol_table : elf64_symbol_table -> string*)

record 'a HasElf64SymbolTable_class=

  get_elf64_symbol_table_method ::" 'a \<Rightarrow> elf64_symbol_table "



(*val read_elf64_symbol_table_entry : endianness -> byte_sequence -> error (elf64_symbol_table_entry * byte_sequence)*)
definition read_elf64_symbol_table_entry  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>(elf64_symbol_table_entry*byte_sequence)error "  where 
     " read_elf64_symbol_table_entry endian bs0 = (
  read_elf64_word endian bs0 >>= (\<lambda> (st_name, bs0) . 
  read_unsigned_char endian bs0 >>= (\<lambda> (st_info, bs0) . 
  read_unsigned_char endian bs0 >>= (\<lambda> (st_other, bs0) . 
  read_elf64_half endian bs0 >>= (\<lambda> (st_shndx, bs0) . 
  read_elf64_addr endian bs0 >>= (\<lambda> (st_value, bs0) . 
  read_elf64_xword endian bs0 >>= (\<lambda> (st_size, bs0) . 
    error_return ((| elf64_st_name = st_name, elf64_st_info = st_info,
                 elf64_st_other = st_other, elf64_st_shndx = st_shndx,
                 elf64_st_value = st_value, elf64_st_size = st_size |), bs0))))))))"


(*val read_elf64_symbol_table : endianness -> byte_sequence -> error elf64_symbol_table*)
function (sequential,domintros)  read_elf64_symbol_table  :: " endianness \<Rightarrow> byte_sequence \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " read_elf64_symbol_table endian bs0 = (
  if length bs0 =( 0 :: nat) then
    error_return []
  else
    read_elf64_symbol_table_entry endian bs0 >>= (\<lambda> (head, bs0) . 
    read_elf64_symbol_table endian bs0 >>= (\<lambda> tail . 
    error_return (head # tail))))" 
by pat_completeness auto


(** Association map of symbol name, symbol type, symbol size, and symbol address.
  *)
type_synonym symbol_address_map
  =" (string * (nat * nat * nat)) list "

(*val get_elf32_symbol_image_address : elf32_symbol_table -> string_table -> error symbol_address_map*)
definition get_elf32_symbol_image_address  :: "(elf32_symbol_table_entry)list \<Rightarrow> string_table \<Rightarrow>((string*(nat*nat*nat))list)error "  where 
     " get_elf32_symbol_image_address symtab strtab = (
  mapM (\<lambda> entry . 
    (let name = (unat(elf32_st_name   entry)) in
    (let addr = (unat(elf32_st_value   entry)) in
    (let size1 = (unat(elf32_st_size   entry) *( 8 :: nat)) in
    (let typ1  = (get_symbol_type(elf32_st_info   entry)) in
      String_table.get_string_at name strtab >>= (\<lambda> str . 
      error_return (str, (typ1, size1, addr)))))))
  ) symtab )"


(*val get_elf64_symbol_image_address : elf64_symbol_table -> string_table -> error symbol_address_map*)
definition get_elf64_symbol_image_address  :: "(elf64_symbol_table_entry)list \<Rightarrow> string_table \<Rightarrow>((string*(nat*nat*nat))list)error "  where 
     " get_elf64_symbol_image_address symtab strtab = (
  mapM (\<lambda> entry . 
    (let name = (unat(elf64_st_name   entry)) in
    (let addr = (unat(elf64_st_value   entry)) in
    (let size1 = (unat(elf64_st_size   entry)) in
    (let typ1  = (get_symbol_type(elf64_st_info   entry)) in
      String_table.get_string_at name strtab >>= (\<lambda> str . 
      error_return (str, (typ1, size1, addr)))))))
  ) symtab )"
end
