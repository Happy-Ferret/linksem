header{*Generated by Lem from elf_interpreted_segment.lem.*}

theory "Elf_interpreted_segment" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_bool" 
	 "Lem_num" 
	 "Lem_string" 
	 "Elf_types" 
	 "Byte_sequence" 
	 "Missing_pervasives" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import Num*)
(*open import String*)

(*open import Elf_types*)

(*open import Byte_sequence*)
(*open import Missing_pervasives*)
(*open import Show*)

record elf32_interpreted_segment =
  
 elf32_segment_body  ::" byte_sequence "        (** Body of the segment *)
   
 elf32_segment_type  ::" nat "              (** Type of the segment *)
   
 elf32_segment_size  ::" nat "              (** Size of the segment in bytes *)
   
 elf32_segment_memsz ::" nat "              (** Size of the segment in memory in bytes *)
   
 elf32_segment_base  ::" nat "              (** Base address of the segment *)
   
 elf32_segment_paddr ::" nat "              (** Physical address of segment *)
   
 elf32_segment_align ::" nat "              (** Alignment of the segment *)
   
 elf32_segment_offset ::" nat "             (** Offset of the segment *)
   
 elf32_segment_flags ::" (bool * bool * bool)" (** READ, WRITE, EXECUTE flags. *)
   


record elf64_interpreted_segment =
  
 elf64_segment_body  ::" byte_sequence "        (** Body of the segment *)
   
 elf64_segment_type  ::" nat "              (** Type of the segment *)
   
 elf64_segment_size  ::" nat "              (** Size of the segment in bytes *)
   
 elf64_segment_memsz ::" nat "              (** Size of the segment in memory in bytes *)
   
 elf64_segment_base  ::" nat "              (** Base address of the segment *)
   
 elf64_segment_paddr ::" nat "              (** Physical address of segment *)
   
 elf64_segment_align ::" nat "              (** Alignment of the segment *)
   
 elf64_segment_offset ::" nat "             (** Offset of the segment *)
   
 elf64_segment_flags ::" (bool * bool * bool)" (** READ, WRITE, EXECUTE flags. *)
   


type_synonym elf32_interpreted_segments =" elf32_interpreted_segment list "
type_synonym elf64_interpreted_segments =" elf64_interpreted_segment list "

(*val elf32_interpret_program_header_flags : elf32_word -> (bool * bool * bool)*)
definition elf32_interpret_program_header_flags  :: " uint32 \<Rightarrow> bool*bool*bool "  where 
     " elf32_interpret_program_header_flags flags = (
  (let zero = (Elf_Types_Local.uint32_of_nat(( 0 :: nat))) in
  (let one  = (Elf_Types_Local.uint32_of_nat(( 1 :: nat))) in
  (let two  = (Elf_Types_Local.uint32_of_nat(( 2 :: nat))) in
  (let four = (Elf_Types_Local.uint32_of_nat(( 4 :: nat))) in
    (\<not> (Elf_Types_Local.uint32_land flags one = zero),
      \<not> (Elf_Types_Local.uint32_land flags two = zero),
      \<not> (Elf_Types_Local.uint32_land flags four = zero)))))))"


(*val elf64_interpret_program_header_flags : elf64_word -> (bool * bool * bool)*)
definition elf64_interpret_program_header_flags  :: " uint32 \<Rightarrow> bool*bool*bool "  where 
     " elf64_interpret_program_header_flags flags = (
  (let zero = (Elf_Types_Local.uint32_of_nat(( 0 :: nat))) in
  (let one  = (Elf_Types_Local.uint32_of_nat(( 1 :: nat))) in
  (let two  = (Elf_Types_Local.uint32_of_nat(( 2 :: nat))) in
  (let four = (Elf_Types_Local.uint32_of_nat(( 4 :: nat))) in
    (\<not> (Elf_Types_Local.uint32_land flags one = zero),
      \<not> (Elf_Types_Local.uint32_land flags two = zero),
      \<not> (Elf_Types_Local.uint32_land flags four = zero)))))))"


(*val string_of_flags : (bool * bool * bool) -> string*)

(*val string_of_elf32_interpreted_segment : elf32_interpreted_segment -> string*)

(*val string_of_elf64_interpreted_segment : elf64_interpreted_segment -> string*)
end
