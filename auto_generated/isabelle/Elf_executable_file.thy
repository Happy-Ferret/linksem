header{*Generated by Lem from elf_executable_file.lem.*}

theory "Elf_executable_file" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_bool" 
	 "Lem_list" 
	 "Lem_num" 
	 "Lem_maybe" 
	 "Lem_string" 
	 "Elf_header" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_types" 
	 "Elf_section_header_table" 
	 "Elf_symbol_table" 
	 "Elf_program_header_table" 
	 "String_table" 
	 "Byte_sequence" 
	 "Error" 
	 "Missing_pervasives" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)

(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Elf_interpreted_segment*)
(*open import Elf_types*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_program_header_table*)

(*open import String_table*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

record elf32_executable_file =
  
 elf32_executable_file_header               ::" elf32_header "
   
 elf32_executable_file_program_header_table ::" elf32_program_header_table "
   
 elf32_executable_file_section_header_table ::" elf32_section_header_table "
   
 elf32_executable_file_interpreted_segments ::" elf32_interpreted_segments "
   
 elf32_executable_file_interpreted_sections ::" elf32_interpreted_sections "
   
 elf32_executable_file_bits_and_bobs        ::" (nat * byte_sequence) list "
   


(*val bytes_of_elf32_executable_file : elf32_executable_file -> error byte_sequence*)
definition bytes_of_elf32_executable_file  :: " elf32_executable_file \<Rightarrow>(byte_sequence)error "  where 
     " bytes_of_elf32_executable_file ef = (
  (let endian      = (get_elf32_header_endianness(elf32_executable_file_header   ef)) in
  (let hdr_bytes   = (bytes_of_elf32_header(elf32_executable_file_header   ef)) in
  (let hdr_layout  = (( 0 :: nat), hdr_bytes) in
  (let pht_bytes   = (bytes_of_elf32_program_header_table endian(elf32_executable_file_program_header_table   ef)) in
  (let sht_bytes   = (bytes_of_elf32_section_header_table endian(elf32_executable_file_section_header_table   ef)) in
  (let pht_off     = (unat(elf32_phoff  (elf32_executable_file_header   ef))) in
  (let sht_off     = (unat(elf32_shoff  (elf32_executable_file_header   ef))) in
  (let pht_layout  = (pht_off, pht_bytes) in
  (let sht_layout  = (sht_off, sht_bytes) in
  (let bab_layout  = ((elf32_executable_file_bits_and_bobs   ef)) in
  if List.length(elf32_executable_file_program_header_table   ef) =
    List.length(elf32_executable_file_interpreted_segments   ef) then
    if List.length(elf32_executable_file_section_header_table   ef) =
      List.length(elf32_executable_file_interpreted_sections   ef) then
      (let segs_zip = (List.zip(elf32_executable_file_program_header_table   ef)(elf32_executable_file_interpreted_segments   ef)) in
      (let sects_zip = (List.zip(elf32_executable_file_section_header_table   ef)(elf32_executable_file_interpreted_sections   ef)) in
      (let segs_layout =        
(List.map (\<lambda> (seg, interp_seg) . 
          (unat(elf32_p_offset   seg),(elf32_segment_body   interp_seg))
        ) segs_zip)
      in
      (let sects_layout =        
(List.map (\<lambda> (sect1, interp_sect) . 
          (unat(elf32_sh_offset   sect1),(elf32_section_body   interp_sect))
        ) sects_zip)
      in
      (let pre_layout = ((([hdr_layout, pht_layout, sht_layout] @ sects_layout) @ segs_layout) @ bab_layout) in
      (let final_layout =        
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) .  natural_ordering off_x off_y)
          pre_layout)
      in
      (let concats =        
(foldM (\<lambda> x y . 
          (let (current_offset, so_far) = x in
          (let (point_to_add, body) = y in
            if point_to_add < current_offset then
              (let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if Byte_sequence.length body < diff then
                  error_return (current_offset, so_far)
                else
                  Byte_sequence.partition diff body >>= (\<lambda> (_, cut1) . 
                  (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, cut1]) in
                  (let delta  = (current_offset + Byte_sequence.length cut1) in
                    error_return (delta, concat1)))))
            else
              (let diff   = (point_to_add - current_offset) in
              (let reps   = (Byte_sequence.create diff (0 :: 8 word)) in
              (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, reps, body]) in
              (let delta  = (point_to_add + Byte_sequence.length body) in
                error_return (delta, concat1)))))))
        ) (( 0 :: nat), Byte_sequence.empty) final_layout)
      in
        concats >>= (\<lambda> (offset, body) . 
        error_return body))))))))
    else
      error_fail (''bytes_of_elf32_executable_file: interpreted sections and section header table must have same length'')
  else
    error_fail (''bytes_of_elf32_executable_file: interpreted segments and program header table must have same length''))))))))))))"


(** Invariant:
      * Program header table and interpreted segments are in correspondence:
        * Length of two lists must be identical
        * First element of PHT must describe first interpreted segment, second
          element should describe second element, and so on.
*)
record elf64_executable_file =
  
 elf64_executable_file_header               ::" elf64_header "
   
 elf64_executable_file_program_header_table ::" elf64_program_header_table "
   
 elf64_executable_file_section_header_table ::" elf64_section_header_table "
   
 elf64_executable_file_interpreted_segments ::" elf64_interpreted_segments "
   
 elf64_executable_file_interpreted_sections ::" elf64_interpreted_sections "
   
 elf64_executable_file_bits_and_bobs        ::" (nat * byte_sequence) list "
   


(*val bytes_of_elf64_executable_file : elf64_executable_file -> error byte_sequence*)
definition bytes_of_elf64_executable_file  :: " elf64_executable_file \<Rightarrow>(byte_sequence)error "  where 
     " bytes_of_elf64_executable_file ef = (
  (let endian      = (get_elf64_header_endianness(elf64_executable_file_header   ef)) in
  (let hdr_bytes   = (bytes_of_elf64_header(elf64_executable_file_header   ef)) in
  (let hdr_layout  = (( 0 :: nat), hdr_bytes) in
  (let pht_bytes   = (bytes_of_elf64_program_header_table endian(elf64_executable_file_program_header_table   ef)) in
  (let sht_bytes   = (bytes_of_elf64_section_header_table endian(elf64_executable_file_section_header_table   ef)) in
  (let pht_off     = (unat(elf64_phoff  (elf64_executable_file_header   ef))) in
  (let sht_off     = (unat(elf64_shoff  (elf64_executable_file_header   ef))) in
  (let pht_layout  = (pht_off, pht_bytes) in
  (let sht_layout  = (sht_off, sht_bytes) in
  (let bab_layout  = ((elf64_executable_file_bits_and_bobs   ef)) in
  if List.length(elf64_executable_file_program_header_table   ef) =
    List.length(elf64_executable_file_interpreted_segments   ef) then
    if List.length(elf64_executable_file_section_header_table   ef) =
      List.length(elf64_executable_file_interpreted_sections   ef) then
      (let segs_zip = (List.zip(elf64_executable_file_program_header_table   ef)(elf64_executable_file_interpreted_segments   ef)) in
      (let sects_zip = (List.zip(elf64_executable_file_section_header_table   ef)(elf64_executable_file_interpreted_sections   ef)) in
      (let segs_layout =        
(List.map (\<lambda> (seg, interp_seg) . 
          (unat(elf64_p_offset   seg),(elf64_segment_body   interp_seg))
        ) segs_zip)
      in
      (let sects_layout =        
(List.map (\<lambda> (sect1, interp_sect) . 
          (unat(elf64_sh_offset   sect1),(elf64_section_body   interp_sect))
        ) sects_zip)
      in
      (let pre_layout = ((([hdr_layout, pht_layout, sht_layout] @ sects_layout) @ segs_layout) @ bab_layout) in
      (let final_layout =        
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) .  natural_ordering off_x off_y)
          pre_layout)
      in
      (let concats =        
(foldM (\<lambda> x y . 
          (let (current_offset, so_far) = x in
          (let (point_to_add, body) = y in
            if point_to_add < current_offset then
              (let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if Byte_sequence.length body < diff then
                  error_return (current_offset, so_far)
                else
                  Byte_sequence.partition diff body >>= (\<lambda> (_, cut1) . 
                  (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, cut1]) in
                  (let delta  = (current_offset + Byte_sequence.length cut1) in
                    error_return (delta, concat1)))))
            else
              (let diff   = (point_to_add - current_offset) in
              (let reps   = (Byte_sequence.create diff (0 :: 8 word)) in
              (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, reps, body]) in
              (let delta  = (point_to_add + Byte_sequence.length body) in
                error_return (delta, concat1)))))))
        ) (( 0 :: nat), Byte_sequence.empty) final_layout)
      in
        concats >>= (\<lambda> (offset, body) . 
        error_return body))))))))
    else
      error_fail (''bytes_of_elf64_executable_file: interpreted sections and section header table must have same length'')
  else
    error_fail (''bytes_of_elf64_executable_file: interpreted segments and program header table must have same length''))))))))))))"


(*val obtain_elf32_program_header_table : elf32_header -> byte_sequence -> error elf32_program_header_table*)
definition obtain_elf32_program_header_table  :: " elf32_header \<Rightarrow> byte_sequence \<Rightarrow>((elf32_program_header_table_entry)list)error "  where 
     " obtain_elf32_program_header_table hdr bs0 = (
  (let endian      = (get_elf32_header_endianness hdr) in
  (let pentries    = (unat(elf32_phnum   hdr))     in
  (let pentry_size = (unat(elf32_phentsize   hdr)) in
  (let psize       = (pentries * pentry_size) in
    if psize =( 0 :: nat) then
      error_fail (''obtain_elf32_program_header_table: mandatory program header table not present'')
    else
      (let poffset = (unat(elf32_phoff   hdr)) in
      Byte_sequence.offset_and_cut poffset psize bs0 >>= (\<lambda> pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_program_header_table psize endian pexact >>= (\<lambda> (pht, _) . 
      error_return pht))))))))"


(*val obtain_elf64_program_header_table : elf64_header -> byte_sequence -> error elf64_program_header_table*)
definition obtain_elf64_program_header_table  :: " elf64_header \<Rightarrow> byte_sequence \<Rightarrow>((elf64_program_header_table_entry)list)error "  where 
     " obtain_elf64_program_header_table hdr bs0 = (
  (let endian      = (get_elf64_header_endianness hdr) in
  (let pentries    = (unat(elf64_phnum   hdr))     in
  (let pentry_size = (unat(elf64_phentsize   hdr)) in
  (let psize       = (pentries * pentry_size) in
    if psize =( 0 :: nat) then
      error_fail (''obtain_elf64_program_header_table: mandatory program header table not present'')
    else
      (let poffset = (unat(elf64_phoff   hdr)) in
      Byte_sequence.offset_and_cut poffset psize bs0 >>= (\<lambda> pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_program_header_table psize endian pexact >>= (\<lambda> (pht, _) . 
      error_return pht))))))))"


(*val obtain_elf32_section_header_table : elf32_header -> byte_sequence -> error elf32_section_header_table*)
definition obtain_elf32_section_header_table  :: " elf32_header \<Rightarrow> byte_sequence \<Rightarrow>((elf32_section_header_table_entry)list)error "  where 
     " obtain_elf32_section_header_table hdr bs0 = (
  (let endian      = (get_elf32_header_endianness hdr) in
  (let sentries    = (unat(elf32_shnum   hdr)) in
  (let sentry_size = (unat(elf32_shentsize   hdr)) in
  (let ssize       = (sentries * sentry_size) in
    if ssize =( 0 :: nat) then
      error_return []
    else
      (let soffset = (unat(elf32_shoff   hdr)) in
      Byte_sequence.offset_and_cut soffset ssize bs0 >>= (\<lambda> sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_section_header_table ssize endian sexact >>= (\<lambda> (sht, _) . 
      error_return sht))))))))"


(*val obtain_elf64_section_header_table : elf64_header -> byte_sequence -> error elf64_section_header_table*)
definition obtain_elf64_section_header_table  :: " elf64_header \<Rightarrow> byte_sequence \<Rightarrow>((elf64_section_header_table_entry)list)error "  where 
     " obtain_elf64_section_header_table hdr bs0 = (
  (let endian      = (get_elf64_header_endianness hdr) in
  (let sentries    = (unat(elf64_shnum   hdr)) in
  (let sentry_size = (unat(elf64_shentsize   hdr)) in
  (let ssize       = (sentries * sentry_size) in
    if ssize =( 0 :: nat) then
      error_return []
    else
      (let soffset = (unat(elf64_shoff   hdr)) in
      Byte_sequence.offset_and_cut soffset ssize bs0 >>= (\<lambda> sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_section_header_table ssize endian sexact >>= (\<lambda> (sht, _) . 
      error_return sht))))))))"


(*val obtain_elf32_interpreted_segments : elf32_program_header_table -> byte_sequence -> error elf32_interpreted_segments*)
definition obtain_elf32_interpreted_segments  :: "(elf32_program_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf32_interpreted_segment)list)error "  where 
     " obtain_elf32_interpreted_segments pht bdy = (
  mapM (\<lambda> ph . 
    (let offset   = (unat(elf32_p_offset   ph))  in
    (let size1     = (unat(elf32_p_filesz   ph)) in
    Byte_sequence.offset_and_cut offset size1 bdy >>= (\<lambda> relevant . 
    (let vaddr    = (unat(elf32_p_vaddr   ph)) in
    (let paddr    = (unat(elf32_p_paddr   ph)) in
    (let memsz    = (unat(elf32_p_memsz   ph)) in
    (let typ1      = (unat(elf32_p_type   ph))  in
    (let align    = (unat(elf32_p_align   ph)) in
    (let flags    = (elf32_interpret_program_header_flags(elf32_p_flags   ph)) in
      if memsz < size1 then
        error_fail (''obtain_elf32_interpreted_segments: memory size of segment cannot be less than file size'')
      else
        error_return  (| elf32_segment_body = relevant, elf32_segment_type = typ1,
 elf32_segment_size = size1, elf32_segment_memsz = memsz,
 elf32_segment_base = vaddr,
 elf32_segment_paddr = paddr, elf32_segment_align = align,
 elf32_segment_offset = offset, elf32_segment_flags = flags  |))))))))))
    ) pht )"


(*val obtain_elf64_interpreted_segments : elf64_program_header_table -> byte_sequence -> error elf64_interpreted_segments*)
definition obtain_elf64_interpreted_segments  :: "(elf64_program_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf64_interpreted_segment)list)error "  where 
     " obtain_elf64_interpreted_segments pht bdy = (
  mapM (\<lambda> ph . 
    (let offset   = (unat(elf64_p_offset     ph))  in
    (let size1     = (unat(elf64_p_filesz   ph)) in
    Byte_sequence.offset_and_cut offset size1 bdy >>= (\<lambda> relevant . 
    (let vaddr    = (unat(elf64_p_vaddr    ph)) in
    (let paddr    = (unat(elf64_p_paddr    ph)) in
    (let memsz    = (unat(elf64_p_memsz   ph)) in
    (let typ1      = (unat(elf64_p_type    ph))  in
    (let align    = (unat(elf64_p_align   ph)) in
    (let flags    = (elf64_interpret_program_header_flags(elf64_p_flags   ph)) in
      if memsz < size1 then
        error_fail (''obtain_elf64_interpreted_segments: memory size of segment cannot be less than file size'')
      else
        error_return  (| elf64_segment_body = relevant, elf64_segment_type = typ1,
 elf64_segment_size = size1, elf64_segment_memsz = memsz,
 elf64_segment_base = vaddr, elf64_segment_paddr = paddr,
 elf64_segment_align = align,
 elf64_segment_offset = offset, elf64_segment_flags = flags  |))))))))))
    ) pht )"


(*val obtain_elf32_interpreted_sections : elf32_section_header_table -> byte_sequence -> error elf32_interpreted_sections*)
definition obtain_elf32_interpreted_sections  :: "(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf32_interpreted_section)list)error "  where 
     " obtain_elf32_interpreted_sections sht bs0 = (
  mapM (\<lambda> sh . 
    (let offset = (unat(elf32_sh_offset    sh)) in
    (let size1   = (unat(elf32_sh_size   sh)) in
    (let name   = (unat(elf32_sh_name   sh)) in
    (let typ1    = (unat(elf32_sh_type   sh)) in
    (let flags  = (unat(elf32_sh_flags   sh)) in
    (let base   = (unat(elf32_sh_addr   sh)) in
    (let link   = (unat(elf32_sh_link   sh)) in
    (let info   = (unat(elf32_sh_info   sh)) in
    (let align  = (unat(elf32_sh_addralign   sh)) in
    (let entry_size = (unat(elf32_sh_entsize   sh)) in
    Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> relevant . 
      error_return  (| elf32_section_name = name, elf32_section_type = typ1,
 elf32_section_flags = flags, elf32_section_base = base, elf32_section_offset = offset,
 elf32_section_size = size1,
 elf32_section_link = link, elf32_section_info = info,
 elf32_section_align = align,
 elf32_section_entry_size = entry_size, elf32_section_body = relevant  |))))))))))))
  ) sht )"


(*val obtain_elf64_interpreted_sections : elf64_section_header_table -> byte_sequence -> error elf64_interpreted_sections*)
definition obtain_elf64_interpreted_sections  :: "(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf64_interpreted_section)list)error "  where 
     " obtain_elf64_interpreted_sections sht bs0 = (
  mapM (\<lambda> sh . 
    (let offset = (unat(elf64_sh_offset     sh)) in
    (let size1   = (unat(elf64_sh_size   sh)) in
    (let name   = (unat(elf64_sh_name    sh)) in
    (let typ1    = (unat(elf64_sh_type    sh)) in
    (let flags  = (unat(elf64_sh_flags   sh)) in
    (let base   = (unat(elf64_sh_addr    sh)) in
    (let link   = (unat(elf64_sh_link    sh)) in
    (let info   = (unat(elf64_sh_info    sh)) in
    (let align  = (unat(elf64_sh_addralign   sh)) in
    (let entry_size = (unat(elf64_sh_entsize   sh)) in
    Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> relevant . 
      error_return  (| elf64_section_name = name, elf64_section_type = typ1,
 elf64_section_flags = flags, elf64_section_base = base, elf64_section_offset = offset,
 elf64_section_size = size1,
 elf64_section_link = link, elf64_section_info = info,
 elf64_section_align = align,
 elf64_section_entry_size = entry_size, elf64_section_body = relevant  |))))))))))))
  ) sht )"


(*val find_first_not_in_range : natural -> list (natural * natural) -> natural*)
function (sequential,domintros)  find_first_not_in_range  :: " nat \<Rightarrow>(nat*nat)list \<Rightarrow> nat "  where 
     " find_first_not_in_range start ranges = (
  (case  List.filter (\<lambda> (x, y) .  (start \<ge> x) \<and> (start \<le> y)) ranges of
      [] => start
    | _  => find_first_not_in_range (start +( 1 :: nat)) ranges
  ))" 
by pat_completeness auto


(*val find_first_in_range : natural -> list (natural * natural) -> natural*)
function (sequential,domintros)  find_first_in_range  :: " nat \<Rightarrow>(nat*nat)list \<Rightarrow> nat "  where 
     " find_first_in_range start ranges = (
  (case  List.filter (\<lambda> (x, y) .  (start \<ge> x) \<and> (start \<le> y)) ranges of
      [] => find_first_in_range (start +( 1 :: nat)) ranges
    | _  => start
  ))" 
by pat_completeness auto


(*val compute_differences : natural -> natural -> list (natural * natural) -> error (list (natural * natural))*)
function (sequential,domintros)  compute_differences  :: " nat \<Rightarrow> nat \<Rightarrow>(nat*nat)list \<Rightarrow>((nat*nat)list)error "  where 
     " compute_differences start max1 ranges = (
  if start = max1 then
    error_return []
  else if start > max1 then
    error_fail (''compute_differences: passed maximum'')
  else
    (let first = (find_first_not_in_range start ranges) in
      if first \<ge> max1 then
        error_return []
      else
        (let last = (find_first_in_range first ranges) in
          if last > max1 then
            error_return [(first, max1)]
          else
            compute_differences last max1 ranges >>= (\<lambda> tail . 
            error_return ((first, last)# tail)))))" 
by pat_completeness auto


(*val obtain_elf32_bits_and_bobs : elf32_header -> elf32_program_header_table -> elf32_interpreted_segments
  -> elf32_section_header_table -> elf32_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
definition obtain_elf32_bits_and_bobs  :: " elf32_header \<Rightarrow>(elf32_program_header_table_entry)list \<Rightarrow>(elf32_interpreted_segment)list \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow>(elf32_interpreted_section)list \<Rightarrow> byte_sequence \<Rightarrow>((nat*byte_sequence)list)error "  where 
     " obtain_elf32_bits_and_bobs hdr segs interp_segs sects interp_sects bs0 = (
  (let hdr_off_len  = (( 0 :: nat), unat(elf32_ehsize   hdr)) in
  (let pht_off      = (unat(elf32_phoff   hdr)) in
  (let pht_len      = (unat(elf32_phentsize   hdr) * unat(elf32_phnum   hdr)) in
  (let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  (let sht_off      = (unat(elf32_shoff   hdr)) in
  (let sht_len      = (unat(elf32_shentsize   hdr) * unat(elf32_shnum   hdr)) in
  (let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if List.length interp_segs = List.length segs then
      (let seg_zip = (List.zip segs interp_segs) in
      if List.length interp_sects = List.length sects then
        (let sect_zip = (List.zip sects interp_sects) in
        (let seg_off_len  =          
(List.map (\<lambda> (seg, interp_seg) . 
            (let start = (unat(elf32_p_offset   seg)) in
            (let len   = ((elf32_segment_size   interp_seg)) in
            (start, (start + len))))) seg_zip)
        in
        (let sect_off_len =          
(List.map (\<lambda> (sect1, interp_sect) . 
            (let start = (unat(elf32_sh_offset   sect1)) in
            (let len   = ((elf32_section_size   interp_sect)) in
            (start, (start + len))))) sect_zip)
        in
        (let pre_layout   = (hdr_off_len # (pht_off_len # (sht_off_len # (seg_off_len @ sect_off_len)))) in
        (let layout       =          
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) . 
            natural_ordering off_x off_y
          ) pre_layout)
        in
          compute_differences(( 0 :: nat)) (Byte_sequence.length bs0) layout >>= (\<lambda> diffs . 
            mapM (\<lambda> (start, len) . 
              Byte_sequence.offset_and_cut start len bs0 >>= (\<lambda> rel . 
              error_return (start, rel))
            ) diffs))))))
      else
        error_fail (''obtain_elf32_bits_and_bobs: section header table and interpreted section differ in length''))
    else
      error_fail (''obtain_elf32_bits_and_bobs: program header table and interpreted segments differ in length'')))))))))"


(*val obtain_elf64_bits_and_bobs : elf64_header -> elf64_program_header_table -> elf64_interpreted_segments
  -> elf64_section_header_table -> elf64_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
definition obtain_elf64_bits_and_bobs  :: " elf64_header \<Rightarrow>(elf64_program_header_table_entry)list \<Rightarrow>(elf64_interpreted_segment)list \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow>(elf64_interpreted_section)list \<Rightarrow> byte_sequence \<Rightarrow>((nat*byte_sequence)list)error "  where 
     " obtain_elf64_bits_and_bobs hdr segs interp_segs sects interp_sects bs0 = (
  (let hdr_off_len  = (( 0 :: nat), unat(elf64_ehsize   hdr)) in
  (let pht_off      = (unat(elf64_phoff   hdr)) in
  (let pht_len      = (unat(elf64_phentsize   hdr) * unat(elf64_phnum   hdr)) in
  (let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  (let sht_off      = (unat(elf64_shoff   hdr)) in
  (let sht_len      = (unat(elf64_shentsize   hdr) * unat(elf64_shnum   hdr)) in
  (let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if List.length interp_segs = List.length segs then
      (let seg_zip = (List.zip segs interp_segs) in
      if List.length interp_sects = List.length sects then
        (let sect_zip = (List.zip sects interp_sects) in
        (let seg_off_len  =          
(List.map (\<lambda> (seg, interp_seg) . 
            (let start = (unat(elf64_p_offset   seg)) in
            (let len   = ((elf64_segment_size   interp_seg)) in
            (start, (start + len))))) seg_zip)
        in
        (let sect_off_len =          
(List.map (\<lambda> (sect1, interp_sect) . 
            (let start = (unat(elf64_sh_offset   sect1)) in
            (let len   = ((elf64_section_size   interp_sect)) in
            (start, (start + len))))) sect_zip)
        in
        (let pre_layout   = (hdr_off_len # (pht_off_len # (sht_off_len # (seg_off_len @ sect_off_len)))) in
        (let layout       =          
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) . 
            natural_ordering off_x off_y
          ) pre_layout)
        in
          compute_differences(( 0 :: nat)) (Byte_sequence.length bs0) layout >>= (\<lambda> diffs . 
            mapM (\<lambda> (start, len) . 
              Byte_sequence.offset_and_cut start len bs0 >>= (\<lambda> rel . 
              error_return (start, rel))
            ) diffs))))))
      else
        error_fail (''obtain_elf64_bits_and_bobs: section header table and interpreted section differ in length''))
    else
      error_fail (''obtain_elf64_bits_and_bobs: program header table and interpreted segments differ in length'')))))))))"


(*val read_elf32_executable_file : byte_sequence -> error elf32_executable_file*)
definition read_elf32_executable_file  :: " byte_sequence \<Rightarrow>(elf32_executable_file)error "  where 
     " read_elf32_executable_file bs0 = (
  read_elf32_header bs0 >>= (\<lambda> (hdr, bs1) . 
  if \<not> (is_elf32_executable_file hdr) then
    error_fail (''read_elf32_executable_file: ELF file is not an executable file'')
  else
    obtain_elf32_program_header_table hdr bs0 >>= (\<lambda> pht  . 
    obtain_elf32_section_header_table hdr bs0 >>= (\<lambda> sht  . 
    obtain_elf32_interpreted_segments pht bs0 >>= (\<lambda> segs . 
    obtain_elf32_interpreted_sections sht bs0 >>= (\<lambda> sects . 
    obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0 >>= (\<lambda> bits_and_bobs . 
    error_return (| elf32_executable_file_header = hdr,
                elf32_executable_file_program_header_table = pht,
                elf32_executable_file_section_header_table = sht,
                elf32_executable_file_interpreted_segments = segs,
                elf32_executable_file_interpreted_sections = sects,
                elf32_executable_file_bits_and_bobs = bits_and_bobs |))))))))"


(*val read_elf64_executable_file : byte_sequence -> error elf64_executable_file*)
definition read_elf64_executable_file  :: " byte_sequence \<Rightarrow>(elf64_executable_file)error "  where 
     " read_elf64_executable_file bs0 = (
  read_elf64_header bs0 >>= (\<lambda> (hdr, bs1) . 
  if \<not> (is_elf64_executable_file hdr) then
    error_fail (''read_elf64_executable_file: ELF file is not an executable file'')
  else
    obtain_elf64_program_header_table hdr bs0 >>= (\<lambda> pht  . 
    obtain_elf64_section_header_table hdr bs0 >>= (\<lambda> sht  . 
    obtain_elf64_interpreted_segments pht bs0 >>= (\<lambda> segs . 
    obtain_elf64_interpreted_sections sht bs0 >>= (\<lambda> sects . 
    obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0 >>= (\<lambda> bits_and_bobs . 
    error_return (| elf64_executable_file_header = hdr,
                elf64_executable_file_program_header_table = pht,
                elf64_executable_file_section_header_table = sht,
                elf64_executable_file_interpreted_segments = segs,
                elf64_executable_file_interpreted_sections = sects,
                elf64_executable_file_bits_and_bobs = bits_and_bobs |))))))))"


(*val get_elf32_executable_file_section_header_string_table : elf32_executable_file -> error string_table*)
definition get_elf32_executable_file_section_header_string_table  :: " elf32_executable_file \<Rightarrow>(string_table)error "  where 
     " get_elf32_executable_file_section_header_string_table f3 = (
  (let hdr  = ((elf32_executable_file_header   f3)) in
  (let sht  = ((elf32_executable_file_section_header_table   f3)) in
  (let segs = ((elf32_executable_file_interpreted_segments   f3)) in
  (let idx  = (unat(elf32_shstrndx   hdr)) in
  bytes_of_elf32_executable_file f3 >>= (\<lambda> bs0 . 
    (case  Elf_Types_Local.index sht idx of
        None => error_fail (''obtain_elf32_string_table: invalid offset into section header table'')
      | Some sect1 =>
          (let offset = (unat(elf32_sh_offset   sect1)) in
          (let size1   = (unat(elf32_sh_size   sect1)) in
          Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> rel . 
          (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
          error_return (String_table.mk_string_table strings (Elf_Types_Local.char_of_unsigned_char (0 :: 8 word)))))))
    )))))))"


(*val get_elf64_executable_file_section_header_string_table : elf64_executable_file -> error string_table*)
definition get_elf64_executable_file_section_header_string_table  :: " elf64_executable_file \<Rightarrow>(string_table)error "  where 
     " get_elf64_executable_file_section_header_string_table f3 = (
  (let hdr  = ((elf64_executable_file_header   f3)) in
  (let sht  = ((elf64_executable_file_section_header_table   f3)) in
  (let segs = ((elf64_executable_file_interpreted_segments   f3)) in
  (let idx  = (unat(elf64_shstrndx   hdr)) in
  bytes_of_elf64_executable_file f3 >>= (\<lambda> bs0 . 
    (case  Elf_Types_Local.index sht idx of
        None => error_fail (''obtain_elf64_string_table: invalid offset into section header table'')
      | Some sect1 =>
          (let offset = (unat(elf64_sh_offset     sect1)) in
          (let size1   = (unat(elf64_sh_size   sect1)) in
          Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> rel . 
          (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
          error_return (String_table.mk_string_table strings (Elf_Types_Local.char_of_unsigned_char (0 :: 8 word)))))))
    )))))))"


(*val get_elf32_executable_file_symbol_string_table : elf32_executable_file -> error string_table*)
definition get_elf32_executable_file_symbol_string_table  :: " elf32_executable_file \<Rightarrow>(string_table)error "  where 
     " get_elf32_executable_file_symbol_string_table f3 = (
  (let hdr     = ((elf32_executable_file_header   f3)) in
  (let sht     = ((elf32_executable_file_section_header_table   f3)) in
  (let segs    = ((elf32_executable_file_interpreted_segments   f3)) in
  (let strtabs = (Missing_pervasives.mapMaybei (\<lambda> index1 sect1 . 
    if unat(elf32_sh_type   sect1) = sht_strtab then
      if index1 = unat(elf32_shstrndx   hdr) then
        None
      else
        Some sect1
    else
      None) sht)
  in
    bytes_of_elf32_executable_file f3 >>= (\<lambda> bs0 . 
    mapM (\<lambda> sect1 . 
      (let offset  = (unat(elf32_sh_offset    sect1)) in
      (let size1    = (unat(elf32_sh_size   sect1)) in
      Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> bs1 . 
      (let strings = (Byte_sequence.string_of_byte_sequence bs1) in
      error_return (String_table.mk_string_table strings (Elf_Types_Local.char_of_unsigned_char (0 :: 8 word)))))))) strtabs
    >>= (\<lambda> strings . 
      String_table.concat_string_table strings)))))))"


(*val get_elf64_executable_file_symbol_string_table : elf64_executable_file -> error string_table*)
definition get_elf64_executable_file_symbol_string_table  :: " elf64_executable_file \<Rightarrow>(string_table)error "  where 
     " get_elf64_executable_file_symbol_string_table f3 = (
  (let hdr     = ((elf64_executable_file_header   f3)) in
  (let sht     = ((elf64_executable_file_section_header_table   f3)) in
  (let segs    = ((elf64_executable_file_interpreted_segments   f3)) in
  (let strtabs = (Missing_pervasives.mapMaybei (\<lambda> index1 sect1 . 
    if unat(elf64_sh_type   sect1) = sht_strtab then
      if index1 = unat(elf64_shstrndx   hdr) then
        None
      else
        Some sect1
    else
      None) sht)
  in
    bytes_of_elf64_executable_file f3 >>= (\<lambda> bs0 . 
    mapM (\<lambda> sect1 . 
      (let offset  = (unat(elf64_sh_offset     sect1)) in
      (let size1    = (unat(elf64_sh_size   sect1)) in
      Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> bs1 . 
      (let strings = (Byte_sequence.string_of_byte_sequence bs1) in
      error_return (String_table.mk_string_table strings (Elf_Types_Local.char_of_unsigned_char (0 :: 8 word)))))))) strtabs
    >>= (\<lambda> strings . 
      String_table.concat_string_table strings)))))))"


(*val get_elf32_executable_file_symbol_table : elf32_executable_file -> error elf32_symbol_table*)
definition get_elf32_executable_file_symbol_table  :: " elf32_executable_file \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " get_elf32_executable_file_symbol_table f3 = (
  (let hdr     = ((elf32_executable_file_header   f3)) in
  (let sht     = ((elf32_executable_file_section_header_table   f3)) in
  (let segs    = ((elf32_executable_file_interpreted_segments   f3)) in
  (let endian  = (get_elf32_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf32_sh_type   sect1) = sht_symtab
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf32_sh_offset   symtab)) in
        (let size1   = (unat(elf32_sh_size   symtab)) in
        bytes_of_elf32_executable_file f3 >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> relevant . 
        read_elf32_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf32_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB'')
    )))))))"


(*val get_elf64_executable_file_symbol_table : elf64_executable_file -> error elf64_symbol_table*)
definition get_elf64_executable_file_symbol_table  :: " elf64_executable_file \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " get_elf64_executable_file_symbol_table f3 = (
  (let hdr     = ((elf64_executable_file_header   f3)) in
  (let sht     = ((elf64_executable_file_section_header_table   f3)) in
  (let segs    = ((elf64_executable_file_interpreted_segments   f3)) in
  (let endian  = (get_elf64_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf64_sh_type   sect1) = sht_symtab
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf64_sh_offset     symtab)) in
        (let size1   = (unat(elf64_sh_size   symtab)) in
        bytes_of_elf64_executable_file f3 >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> relevant . 
        read_elf64_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf64_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB'')
    )))))))"


(*val get_elf32_executable_file_dynamic_symbol_table : elf32_executable_file -> error elf32_symbol_table*)
definition get_elf32_executable_file_dynamic_symbol_table  :: " elf32_executable_file \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " get_elf32_executable_file_dynamic_symbol_table ef = (
  (let hdr     = ((elf32_executable_file_header   ef)) in
  (let sht     = ((elf32_executable_file_section_header_table   ef)) in
  (let segs    = ((elf32_executable_file_interpreted_segments   ef)) in
  (let endian  = (get_elf32_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf32_sh_type   sect1) = sht_dynsym
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf32_sh_offset   symtab)) in
        (let size1   = (unat(elf32_sh_size   symtab)) in
        bytes_of_elf32_executable_file ef >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> relevant . 
        read_elf32_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf32_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM'')
    )))))))"


(*val get_elf64_executable_file_dynamic_symbol_table : elf64_executable_file -> error elf64_symbol_table*)
definition get_elf64_executable_file_dynamic_symbol_table  :: " elf64_executable_file \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " get_elf64_executable_file_dynamic_symbol_table ef = (
  (let hdr     = ((elf64_executable_file_header   ef)) in
  (let sht     = ((elf64_executable_file_section_header_table   ef)) in
  (let segs    = ((elf64_executable_file_interpreted_segments   ef)) in
  (let endian  = (get_elf64_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf64_sh_type   sect1) = sht_dynsym
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf64_sh_offset     symtab)) in
        (let size1   = (unat(elf64_sh_size   symtab)) in
        bytes_of_elf64_executable_file ef >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size1 bs0 >>= (\<lambda> relevant . 
        read_elf64_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf64_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM'')
    )))))))"


type_synonym elf32_executable_process_image ="
  elf32_interpreted_segments * nat "

type_synonym elf64_executable_process_image ="
  elf64_interpreted_segments * nat "

(*val get_elf32_executable_file_image : elf32_executable_file -> error elf32_executable_process_image*)
definition get_elf32_executable_file_image  :: " elf32_executable_file \<Rightarrow>((elf32_interpreted_segment)list*nat)error "  where 
     " get_elf32_executable_file_image f3 = (
  (let entr = ((elf32_entry  (elf32_executable_file_header   f3))) in
  (let segs = ((elf32_executable_file_interpreted_segments   f3)) in
    (case  List.filter (\<lambda> sg . (elf32_segment_type   sg) = elf_pt_load) segs of
        []    => error_fail (''get_elf32_executable_image: an executable ELF file must have at least one loadable segment'')
      | load  =>
          mapM (\<lambda> sg . 
            if(elf32_segment_memsz   sg) =( 0 :: nat) then
              error_return []
            else if(elf32_segment_memsz   sg) =(elf32_segment_size   sg) then
              error_return [sg]
            else if(elf32_segment_size   sg) <(elf32_segment_memsz   sg) then
              (* Cannot be negative due to check in constructing [segs]. *)
              (let diff  = ((elf32_segment_memsz   sg) -(elf32_segment_size   sg)) in
              (let zeros1 = (Byte_sequence.zeros diff) in
              (let addr  = ((elf32_segment_base   sg) +(elf32_segment_size   sg)) in
              (let align = ((elf32_segment_align   sg)) in
              (let paddr = ((elf32_segment_paddr   sg)) in
              (let seg   = 
  ((| elf32_segment_body = zeros1, elf32_segment_type =(elf32_segment_type   sg),
   elf32_segment_size = diff, elf32_segment_memsz = diff,
   elf32_segment_base = addr, elf32_segment_paddr = paddr,
   elf32_segment_align = align,
   elf32_segment_offset =(elf32_segment_offset   sg), elf32_segment_flags =(elf32_segment_flags   sg)  |))
              in
                error_return [sg, seg]))))))
            else
              error_fail (''get_elf32_executable_image: invariant invalidated'')) load >>= (\<lambda> bs_base . 
          error_return (List.concat bs_base, unat entr))
    ))))"


(*val get_elf64_executable_file_image : elf64_executable_file -> error elf64_executable_process_image*)
definition get_elf64_executable_file_image  :: " elf64_executable_file \<Rightarrow>((elf64_interpreted_segment)list*nat)error "  where 
     " get_elf64_executable_file_image f3 = ( 
  (let entr = ((elf64_entry  (elf64_executable_file_header   f3))) in
  (let segs = ((elf64_executable_file_interpreted_segments   f3)) in
    (case  List.filter (\<lambda> sg . (elf64_segment_type   sg) = elf_pt_load) segs of
        []    => error_fail (''get_elf64_executable_image: an executable ELF file must have at least one loadable segment'')
      | load  =>
          mapM (\<lambda> sg . 
            if(elf64_segment_memsz   sg) =( 0 :: nat) then
              error_return []
            else if(elf64_segment_memsz   sg) =(elf64_segment_size   sg) then
              error_return [sg]
            else if(elf64_segment_size   sg) <(elf64_segment_memsz   sg) then
              (* Cannot be negative due to check in constructing [segs]. *)
              (let diff  = ((elf64_segment_memsz   sg) -(elf64_segment_size   sg)) in
              (let zeros1 = (Byte_sequence.zeros diff) in
              (let addr  = ((elf64_segment_base   sg) +(elf64_segment_size   sg)) in
              (let align = ((elf64_segment_align   sg)) in
              (let paddr = ((elf64_segment_paddr   sg)) in
              (let seg   = 
  ((| elf64_segment_body = zeros1, elf64_segment_type =(elf64_segment_type   sg),
   elf64_segment_size = diff, elf64_segment_memsz = diff,
   elf64_segment_base = addr, elf64_segment_paddr = paddr,
   elf64_segment_align = align,
   elf64_segment_offset =(elf64_segment_offset   sg), elf64_segment_flags =(elf64_segment_flags   sg)  |))
              in
                error_return [sg, seg]))))))
            else
              error_fail (''get_elf64_executable_image: invariant invalidated'')) load >>= (\<lambda> bs_base . 
          error_return (List.concat bs_base, unat entr))
    ))))"


type_synonym global_symbol_init_info
  =" (string * (nat * nat * nat *  byte_sequence option)) list "

(*val get_elf32_executable_file_global_symbol_init : elf32_executable_file -> error global_symbol_init_info*)
definition get_elf32_executable_file_global_symbol_init  :: " elf32_executable_file \<Rightarrow>((string*(nat*nat*nat*(byte_sequence)option))list)error "  where 
     " get_elf32_executable_file_global_symbol_init f3 = (
  (let segs   = ((elf32_executable_file_interpreted_segments   f3)) in
  bytes_of_elf32_executable_file f3 >>= (\<lambda> bs0 . 
  get_elf32_executable_file_symbol_table f3 >>= (\<lambda> symtab . 
  get_elf32_executable_file_symbol_string_table f3 >>= (\<lambda> strtab . 
  Elf_symbol_table.get_elf32_symbol_image_address symtab strtab >>= (\<lambda> strs . 
    (let mapped = (mapM (\<lambda> (symbol, (typ1, size1, addr)) . 
      if typ1 = Elf_symbol_table.stt_object then
        get_elf32_executable_file_image f3 >>= (\<lambda> (img, entry) . 
        (let chunks =          
(List.filter (\<lambda> chunk .             
(addr \<ge>(elf32_segment_base   chunk)) \<and>
              ((addr + size1) \<le> ((elf32_segment_base   chunk) +(elf32_segment_size   chunk)))
          ) img)
        in
          (case  chunks of
              []    => error_fail (''get_elf32_global_symbol_init: global variable not present in executable image'')
            | [x]   =>
              (let rebase   = (addr -(elf32_segment_base   x)) in
              Byte_sequence.offset_and_cut rebase size1(elf32_segment_body   x) >>= (\<lambda> relevant . 
                error_return (symbol, (typ1, size1, addr, Some relevant))))
            | x # xs => error_fail (''get_elf32_global_symbol_init: invariant failed, global variable appears in multiple segments'')
          )))
      else
        error_return (symbol, (typ1, size1, addr, None))) strs)
    in
      mapped)))))))"


(*val get_elf64_executable_file_global_symbol_init : elf64_executable_file -> error global_symbol_init_info*)
definition get_elf64_executable_file_global_symbol_init  :: " elf64_executable_file \<Rightarrow>((string*(nat*nat*nat*(byte_sequence)option))list)error "  where 
     " get_elf64_executable_file_global_symbol_init f3 = (
  (let segs   = ((elf64_executable_file_interpreted_segments   f3)) in
  bytes_of_elf64_executable_file f3 >>= (\<lambda> bs0 . 
  get_elf64_executable_file_symbol_table f3 >>= (\<lambda> symtab . 
  get_elf64_executable_file_symbol_string_table f3 >>= (\<lambda> strtab . 
  Elf_symbol_table.get_elf64_symbol_image_address symtab strtab >>= (\<lambda> strs . 
    (let mapped = (mapM (\<lambda> (symbol, (typ1, size1, addr)) . 
      if typ1 = Elf_symbol_table.stt_object then
        get_elf64_executable_file_image f3 >>= (\<lambda> (img, entry) . 
        (let chunks =          
(List.filter (\<lambda> chunk .             
(addr \<ge>(elf64_segment_base   chunk)) \<and>
              ((addr + size1) \<le> ((elf64_segment_base   chunk) +(elf64_segment_size   chunk)))
          ) img)
        in
          (case  chunks of
              []    => error_fail (''get_elf64_global_symbol_init: global variable not present in executable image'')
            | [x]   =>
              (let rebase   = (addr -(elf64_segment_base   x)) in
              Byte_sequence.offset_and_cut rebase size1(elf64_segment_body   x) >>= (\<lambda> relevant . 
                error_return (symbol, (typ1, size1, addr, Some relevant))))
            | x # xs => error_fail (''get_elf64_global_symbol_init: invariant failed, global variable appears in multiple segments'')
          )))
      else
        error_return (symbol, (typ1, size1, addr, None))) strs)
    in
      mapped)))))))"


(*val string_of_elf32_executable_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf32_executable_file -> string*)

(*val string_of_elf64_executable_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf64_executable_file -> string*)end
