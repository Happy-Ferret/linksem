header{*Generated by Lem from error.lem.*}

theory "Error" 

imports 
 	 Main
	 "Lem_list" 
	 "Lem_num" 
	 "Lem_string" 
	 "Show" 

begin 

(*open import List*)
(*open import Num*)
(*open import String*)

(*open import Show*)

(** [error] is a type used to represent potentially failing computations. [Success]
  * marks a successful completion of a computation, whilst [Fail err] marks a failure,
  * with [err] as the reason.
  *)
datatype 'a error
	= Success " 'a "
	| Fail " string "

(** [return] is the monadic lifting function for [error], representing a successful
  * computation.
  *)
(*val return : forall 'a. 'a -> error 'a*)
definition error_return  :: " 'a \<Rightarrow> 'a error "  where 
     " error_return r = ( Success r )"


(** [fail err] represents a failing computation, with error message [err].
  *)
(*val fail : forall 'a. string -> error 'a*)
definition error_fail  :: " string \<Rightarrow> 'a error "  where 
     " error_fail err = ( Fail err )"


(** [(>>=)] is the monadic binding function for [error].
  *)
(*val >>= : forall 'a 'b. error 'a -> ('a -> error 'b) -> error 'b*)
fun error_bind :: " 'a error \<Rightarrow>('a \<Rightarrow> 'b error)\<Rightarrow> 'b error "  ("_>>=_" [80,80]80) where 
     "error_bind (Success s) f = ( f s )"
|"error_bind (Fail err) f = ( Fail err )" 
declare error_bind.simps [simp del]


(** [repeatM count action] fails if [action] is a failing computation, or
  * successfully produces a list [count] elements long, where each element is
  * the value successfully returned by [action].
  *)
(*val repeatM : forall 'a. nat -> error 'a -> error (list 'a)*)
function (sequential,domintros)  repeatM  :: " nat \<Rightarrow> 'a error \<Rightarrow>('a list)error "  where 
     " repeatM 0 action = ( error_return [])"
|" repeatM m action = (
				action >>= (\<lambda> head . 
				repeatM (m -( 1 :: nat)) action >>= (\<lambda> tail . 
				error_return (head # tail))))" 
by pat_completeness auto


(** [repeatM' count seed action] is a variant of [repeatM] that acts like [repeatM]
  * apart from any successful result returns a tuple whose second component is [seed]
  * and whose first component is the same as would be returned by [repeatM].
  *)
(*val repeatM' : forall 'a 'b. nat -> 'b -> ('b -> error ('a * 'b)) -> error ((list 'a) * 'b)*)
function (sequential,domintros)  repeatM'  :: " nat \<Rightarrow> 'b \<Rightarrow>('b \<Rightarrow>('a*'b)error)\<Rightarrow>('a list*'b)error "  where 
     " repeatM' 0 seed action = ( error_return ([], seed))"
|" repeatM' m seed action = (
				action seed >>= (\<lambda> (head, seed) . 
				repeatM' (m -( 1 :: nat)) seed action >>= (\<lambda> (tail, seed) . 
				error_return ((head # tail), seed))))" 
by pat_completeness auto

	
(** [mapM f xs] maps [f] across [xs], failing if [f] fails on any element of [xs].
  *)
(*val mapM : forall 'a 'b. ('a -> error 'b) -> list 'a -> error (list 'b)*)
function (sequential,domintros)  mapM  :: "('a \<Rightarrow> 'b error)\<Rightarrow> 'a list \<Rightarrow>('b list)error "  where 
     " mapM f ([]) = ( error_return [])"
|" mapM f (x # xs) = (
				f x >>= (\<lambda> hd . 
				mapM f xs >>= (\<lambda> tl . 
				error_return (hd # tl))))" 
by pat_completeness auto


(*val foldM : forall 'a 'b. ('a -> 'b -> error 'a) -> 'a -> list 'b -> error 'a*)
function (sequential,domintros)  foldM  :: "('a \<Rightarrow> 'b \<Rightarrow> 'a error)\<Rightarrow> 'a \<Rightarrow> 'b list \<Rightarrow> 'a error "  where 
     " foldM f e ([]) = ( error_return e )"
|" foldM f e (x # xs) = ( f e x >>= (\<lambda> res .  foldM f res xs))" 
by pat_completeness auto


(** [string_of_error err] produces a string representation of [err].
  *)
(*val string_of_error : forall 'a. Show 'a => error 'a -> string*)end
