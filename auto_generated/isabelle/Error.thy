chapter {* Generated by Lem from error.lem. *}

theory "Error" 

imports 
 	 Main
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import Show*)

(** [error] is a type used to represent potentially failing computations. [Success]
  * marks a successful completion of a computation, whilst [Fail err] marks a failure,
  * with [err] as the reason.
  *)
datatype 'a error
	= Success " 'a "
	| Fail " string "

(** [return] is the monadic lifting function for [error], representing a successful
  * computation.
  *)
(*val return : forall 'a. 'a -> error 'a*)
definition error_return  :: " 'a \<Rightarrow> 'a error "  where 
     " error_return r = ( Success r )"


(*val with_success : forall 'a 'b. error 'a -> 'b -> ('a -> 'b) -> 'b*)
fun with_success  :: " 'a error \<Rightarrow> 'b \<Rightarrow>('a \<Rightarrow> 'b)\<Rightarrow> 'b "  where 
     " with_success (Success s) fl suc = ( suc s )"
|" with_success (Fail err) fl suc = ( fl )" 
declare with_success.simps [simp del]


(** [fail err] represents a failing computation, with error message [err].
  *)
(*val fail : forall 'a. string -> error 'a*)
definition error_fail  :: " string \<Rightarrow> 'a error "  where 
     " error_fail err = ( Fail err )"


(** [(>>=)] is the monadic binding function for [error].
  *)
(*val >>= : forall 'a 'b. error 'a -> ('a -> error 'b) -> error 'b*)
fun error_bind :: " 'a error \<Rightarrow>('a \<Rightarrow> 'b error)\<Rightarrow> 'b error" ("_>>=_") where 
     "error_bind (Success s) f = ( f s )"
|"error_bind (Fail err) f = ( Fail err )" 
declare error_bind.simps [simp del]

	
(** [as_maybe e] drops an [error] value into a [maybe] value, throwing away
  * error information.
  *)

(*val as_maybe : forall 'a. error 'a -> maybe 'a*)
fun as_maybe  :: " 'a error \<Rightarrow> 'a option "  where 
     " as_maybe (Fail err) = ( None )"
|" as_maybe (Success s) = ( Some s )" 
declare as_maybe.simps [simp del]


(** [repeatM count action] fails if [action] is a failing computation, or
  * successfully produces a list [count] elements long, where each element is
  * the value successfully returned by [action].
  *)
(*val repeatM : forall 'a. natural -> error 'a -> error (list 'a)*)
function (sequential,domintros)  repeatM  :: " nat \<Rightarrow> 'a error \<Rightarrow>('a list)error "  where 
     " repeatM count1 action = (
  if count1 =( 0 :: nat) then
    error_return []
  else
    action >>= (\<lambda> head . 
    repeatM (count1 -( 1 :: nat)) action >>= (\<lambda> tail . 
    error_return (head # tail))))" 
by pat_completeness auto


(** [repeatM' count seed action] is a variant of [repeatM] that acts like [repeatM]
  * apart from any successful result returns a tuple whose second component is [seed]
  * and whose first component is the same as would be returned by [repeatM].
  *)
(*val repeatM' : forall 'a 'b. natural -> 'b -> ('b -> error ('a * 'b)) -> error ((list 'a) * 'b)*)
function (sequential,domintros)  repeatM'  :: " nat \<Rightarrow> 'b \<Rightarrow>('b \<Rightarrow>('a*'b)error)\<Rightarrow>('a list*'b)error "  where 
     " repeatM' count1 seed action = (
  if count1 =( 0 :: nat) then
    error_return ([], seed)
  else
    action seed >>= (\<lambda> (head, seed) . 
    repeatM' (count1 -( 1 :: nat)) seed action >>= (\<lambda> (tail, seed) . 
    error_return ((head # tail), seed))))" 
by pat_completeness auto

	
(** [mapM f xs] maps [f] across [xs], failing if [f] fails on any element of [xs].
  *)
(*val mapM : forall 'a 'b. ('a -> error 'b) -> list 'a -> error (list 'b)*)
function (sequential,domintros)  mapM  :: "('a \<Rightarrow> 'b error)\<Rightarrow> 'a list \<Rightarrow>('b list)error "  where 
     " mapM f ([]) = ( error_return [])"
|" mapM f (x # xs) = (
				f x >>= (\<lambda> hd . 
				mapM f xs >>= (\<lambda> tl1 . 
				error_return (hd # tl1))))" 
by pat_completeness auto


(*val foldM : forall 'a 'b. ('a -> 'b -> error 'a) -> 'a -> list 'b -> error 'a*)
function (sequential,domintros)  foldM  :: "('a \<Rightarrow> 'b \<Rightarrow> 'a error)\<Rightarrow> 'a \<Rightarrow> 'b list \<Rightarrow> 'a error "  where 
     " foldM f e ([]) = ( error_return e )"
|" foldM f e (x # xs) = ( f e x >>= (\<lambda> res .  foldM f res xs))" 
by pat_completeness auto


(** [string_of_error err] produces a string representation of [err].
  *)
(*val string_of_error : forall 'a. Show 'a => error 'a -> string*)
end
