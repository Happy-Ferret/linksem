chapter {* Generated by Lem from memory_image_orderings.lem. *}

theory "Memory_image_orderings" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "Missing_pervasives" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_map" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 
	 "Elf_file" 
	 "Elf_relocation" 
	 "Multimap" 
	 "Memory_image" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_classes" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*open import Set*)
(*open import Multimap*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*open import Show*)

(*open import Byte_sequence*)
(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_segment*)
(*open import Elf_interpreted_section*)
(*open import Elf_program_header_table*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)
(*open import Memory_image*)
(*open import Abi_classes*)
(* open import Abis *)

(*open import Missing_pervasives*)

(*val elfFileFeatureCompare : elf_file_feature -> elf_file_feature -> Basic_classes.ordering*)
fun elfFileFeatureCompare0  :: " elf_file_feature \<Rightarrow> elf_file_feature \<Rightarrow> ordering "  where 
     " elfFileFeatureCompare0 (ElfHeader0(x1)) (ElfHeader0(x2)) = ( (* equal tags, so ... *) elf64_header_compare x1 x2 )"
|" elfFileFeatureCompare0 (ElfHeader0(x1)) _ = ( LT )"
|" elfFileFeatureCompare0 (ElfSectionHeaderTable0(x1)) (ElfHeader0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSectionHeaderTable0(x1)) (ElfSectionHeaderTable0(x2)) = ( ( (* equal tags, so ... *)lexicographicCompareBy compare_elf64_section_header_table_entry x1 x2))"
|" elfFileFeatureCompare0 (ElfSectionHeaderTable0(x1)) _ = ( LT )"
|" elfFileFeatureCompare0 (ElfProgramHeaderTable0(x1)) (ElfHeader0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfProgramHeaderTable0(x1)) (ElfSectionHeaderTable0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfProgramHeaderTable0(x1)) (ElfProgramHeaderTable0(x2)) = ( (lexicographicCompareBy compare_elf64_program_header_table_entry x1 x2))"
|" elfFileFeatureCompare0 (ElfProgramHeaderTable0(x1)) _ = ( LT )"
|" elfFileFeatureCompare0 (ElfSection0(x1)) (ElfHeader0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSection0(x1)) (ElfSectionHeaderTable0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSection0(x1)) (ElfProgramHeaderTable0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSection0(x1)) (ElfSection0(x2)) = ( (pairCompare (genericCompare (op<) (op=)) compare_elf64_interpreted_section x1 x2))"
|" elfFileFeatureCompare0 (ElfSection0(x1)) _ = ( LT )"
|" elfFileFeatureCompare0 (ElfSegment0(x1)) (ElfHeader0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSegment0(x1)) (ElfSectionHeaderTable0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSegment0(x1)) (ElfProgramHeaderTable0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSegment0(x1)) (ElfSection0(x2)) = ( GT )"
|" elfFileFeatureCompare0 (ElfSegment0(x1)) (ElfSegment0(x2)) = ( (pairCompare (genericCompare (op<) (op=)) compare_elf64_interpreted_segment x1 x2))" 
declare elfFileFeatureCompare0.simps [simp del]


(*val elfFileFeatureTagEquiv : elf_file_feature -> elf_file_feature -> bool*)
fun elfFileFeatureTagEquiv0  :: " elf_file_feature \<Rightarrow> elf_file_feature \<Rightarrow> bool "  where 
     " elfFileFeatureTagEquiv0 (ElfHeader0(x1)) (ElfHeader0(x2)) = ( (* equal tags, so ... *) True )"
|" elfFileFeatureTagEquiv0 (ElfSectionHeaderTable0(x1)) (ElfSectionHeaderTable0(x2)) = ( True )"
|" elfFileFeatureTagEquiv0 (ElfProgramHeaderTable0(x1)) (ElfProgramHeaderTable0(x2)) = ( True )"
|" elfFileFeatureTagEquiv0 (ElfSection0(x1)) (ElfSection0(x2)) = ( True )"
|" elfFileFeatureTagEquiv0 (ElfSegment0(x1)) (ElfSegment0(x2)) = ( True )"
|" elfFileFeatureTagEquiv0 _ _ = ( False )" 
declare elfFileFeatureTagEquiv0.simps [simp del]


definition instance_Basic_classes_Ord_Memory_image_elf_file_feature_dict0  :: "(elf_file_feature)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_elf_file_feature_dict0 = ((|

  compare_method = elfFileFeatureCompare0,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (elfFileFeatureCompare0 f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (elfFileFeatureCompare0 f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (elfFileFeatureCompare0 f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (elfFileFeatureCompare0 f1 f2) ({GT, EQ})))|) )"


(*val tagCompare : forall 'abifeature. Ord 'abifeature =>
    range_tag 'abifeature -> range_tag 'abifeature -> Basic_classes.ordering*)
fun tagCompare0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature range_tag \<Rightarrow> 'abifeature range_tag \<Rightarrow> ordering "  where 
     " tagCompare0 dict_Basic_classes_Ord_abifeature ImageBase0 ImageBase0 = ( EQ )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature ImageBase0 _ = ( LT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature EntryPoint0 ImageBase0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature EntryPoint0 EntryPoint0 = ( EQ )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature EntryPoint0 _ = ( LT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolDef0(_)) ImageBase0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolDef0(_)) EntryPoint0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolDef0(x1)) (SymbolDef0(x2)) = ( symDefCompare0 x1 x2 )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolDef0(_)) _ = ( LT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolRef0(_)) ImageBase0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolRef0(_)) EntryPoint0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolRef0(_)) (SymbolDef0(_)) = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolRef0(x1)) (SymbolRef0(x2)) = ( symRefAndRelocSiteCompare0 x1 x2 )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (SymbolRef0(_)) _ = ( LT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (FileFeature0(_)) ImageBase0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (FileFeature0(_)) EntryPoint0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (FileFeature0(_)) (SymbolDef0(_)) = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (FileFeature0(_)) (SymbolRef0(_)) = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (FileFeature0(x1)) (FileFeature0(x2)) = ( elfFileFeatureCompare0 x1 x2 )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (FileFeature0(_)) _ = ( LT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (AbiFeature0(_)) ImageBase0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (AbiFeature0(_)) EntryPoint0 = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (AbiFeature0(_)) (SymbolDef0(_)) = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (AbiFeature0(_)) (SymbolRef0(_)) = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (AbiFeature0(_)) (FileFeature0(_)) = ( GT )"
|" tagCompare0 dict_Basic_classes_Ord_abifeature (AbiFeature0(x1)) (AbiFeature0(x2)) = (
  (compare_method   dict_Basic_classes_Ord_abifeature) x1 x2 )" 
declare tagCompare0.simps [simp del]


definition instance_Basic_classes_Ord_Memory_image_range_tag_dict1  :: " 'abifeature Ord_class \<Rightarrow>('abifeature range_tag)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_range_tag_dict1 dict_Basic_classes_Ord_abifeature = ((|

  compare_method = 
  (tagCompare0 dict_Basic_classes_Ord_abifeature),

  isLess_method = (\<lambda> tag1 .  (\<lambda> tag2 .  (tagCompare0 
  dict_Basic_classes_Ord_abifeature tag1 tag2 = LT))),

  isLessEqual_method = (\<lambda> tag1 .  (\<lambda> tag2 .  (op \<in>) (tagCompare0 
  dict_Basic_classes_Ord_abifeature tag1 tag2) ({LT, EQ}))),

  isGreater_method = (\<lambda> tag1 .  (\<lambda> tag2 .  (tagCompare0 
  dict_Basic_classes_Ord_abifeature tag1 tag2 = GT))),

  isGreaterEqual_method = (\<lambda> tag1 .  (\<lambda> tag2 .  (op \<in>) (tagCompare0 
  dict_Basic_classes_Ord_abifeature tag1 tag2) ({GT, EQ})))|) )"


(*val tagEquiv : forall 'abifeature. AbiFeatureTagEquiv 'abifeature => range_tag 'abifeature -> range_tag 'abifeature -> bool*)
fun tagEquiv0  :: " 'abifeature AbiFeatureTagEquiv_class \<Rightarrow> 'abifeature range_tag \<Rightarrow> 'abifeature range_tag \<Rightarrow> bool "  where 
     " tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature ImageBase0 ImageBase0 = ( True )"
|" tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature EntryPoint0 EntryPoint0 = ( True )"
|" tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature (SymbolDef0(x1)) (SymbolDef0(x2)) = ( True )"
|" tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature (SymbolRef0(_)) (SymbolRef0(_)) = ( True )"
|" tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature (FileFeature0(x1)) (FileFeature0(x2)) = ( elfFileFeatureTagEquiv0 x1 x2 )"
|" tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature (AbiFeature0(x1)) (AbiFeature0(x2)) = (
  (abiFeatureTagEquiv_method   dict_Abi_classes_AbiFeatureTagEquiv_abifeature) x1 x2 )"
|" tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature _ _ = ( False )" 
declare tagEquiv0.simps [simp del]


(* ------- end of Ord / compare / ConstructorToNaturalList functions *)


(*val unique_tag_matching : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => range_tag 'abifeature -> annotated_memory_image 'abifeature -> range_tag 'abifeature*)
definition unique_tag_matching0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature AbiFeatureTagEquiv_class \<Rightarrow> 'abifeature range_tag \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> 'abifeature range_tag "  where 
     " unique_tag_matching0 dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature tag img1 = ( 
    (case  Multimap.lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict1
     dict_Basic_classes_Ord_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      Lem_string_extra.instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature) tag(by_tag0   img1) of
        [] => failwith (''no tag match found'')
        | [(t, r)] => t
        | x => failwith ((''more than one tag match'')) (* (ranges:  ^ 
            (show (List.map (fun (t, r) -> r) x))
            ^  ) when asserted unique) *)
    ))"

    
(*val tagged_ranges_matching_tag : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => range_tag 'abifeature -> annotated_memory_image 'abifeature -> list (range_tag 'abifeature * maybe element_range)*)
definition tagged_ranges_matching_tag0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature AbiFeatureTagEquiv_class \<Rightarrow> 'abifeature range_tag \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>('abifeature range_tag*(element_range)option)list "  where 
     " tagged_ranges_matching_tag0 dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature tag img1 = ( 
    Multimap.lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict1
     dict_Basic_classes_Ord_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      Lem_string_extra.instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (tagEquiv0 dict_Abi_classes_AbiFeatureTagEquiv_abifeature) tag(by_tag0   img1))"


(*val element_range_compare : element_range -> element_range -> Basic_classes.ordering*)
definition element_range_compare0  :: " string*(nat*nat) \<Rightarrow> string*(nat*nat) \<Rightarrow> ordering "  where 
     " element_range_compare0 = ( pairCompare (\<lambda> x y. EQ) (pairCompare (genericCompare (op<) (op=)) (genericCompare (op<) (op=))))"


(*val unique_tag_matching_at_range_exact : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature =>
    maybe element_range
    -> range_tag 'abifeature
    -> annotated_memory_image 'abifeature
    -> range_tag 'abifeature*)
definition unique_tag_matching_at_range_exact0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature AbiFeatureTagEquiv_class \<Rightarrow>(element_range)option \<Rightarrow> 'abifeature range_tag \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> 'abifeature range_tag "  where 
     " unique_tag_matching_at_range_exact0 dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature r tag img1 = ( 
    (* 1. find tags a unique range labelled as ELF section header table. *)
    (let (_, (allRangeMatches :: ( 'abifeature range_tag) list)) = (list_unzip (Multimap.lookupBy0 
  (instance_Basic_classes_Ord_Maybe_maybe_dict
     (instance_Basic_classes_Ord_tup2_dict
        Lem_string_extra.instance_Basic_classes_Ord_string_dict
        (instance_Basic_classes_Ord_tup2_dict
           instance_Basic_classes_Ord_Num_natural_dict
           instance_Basic_classes_Ord_Num_natural_dict))) (instance_Basic_classes_Ord_Memory_image_range_tag_dict1
   dict_Basic_classes_Ord_abifeature) (op=) r(by_range0   img1)))
    in
    (let (tagAlsoMatches :: ( 'abifeature range_tag) list) = (List.filter (\<lambda> x .  tagEquiv0 
  dict_Abi_classes_AbiFeatureTagEquiv_abifeature x tag) allRangeMatches)
    in
    (case  tagAlsoMatches of
        [] => failwith (''no range/tag match when asserted to exist'')
        | [x] => x
        | _ => failwith (''multiple range/tag match when asserted unique'')
    ))))"


(*val symbol_def_ranges : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => annotated_memory_image 'abifeature -> (list (range_tag 'abifeature) * list (maybe element_range))*)
definition symbol_def_ranges0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature AbiFeatureTagEquiv_class \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>('abifeature range_tag)list*((element_range)option)list "  where 
     " symbol_def_ranges0 dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img1 = ( 
    (* find all element ranges labelled as ELF symbols *)
    (let (tags, maybe_ranges) = (list_unzip (
        tagged_ranges_matching_tag0 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature (SymbolDef0(null_symbol_definition0)) img1
    ))
    in
    (* some symbols, specifically ABS symbols, needn't label a range. *)
    (tags, maybe_ranges)))"


(*val name_of_symbol_def : symbol_definition -> string*)
definition name_of_symbol_def0  :: " symbol_definition \<Rightarrow> string "  where 
     " name_of_symbol_def0 sym1 = ((def_symname0   sym1))"


(*val defined_symbols_and_ranges : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature => annotated_memory_image 'abifeature -> list ((maybe element_range) * symbol_definition)*)
definition defined_symbols_and_ranges0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature AbiFeatureTagEquiv_class \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>((element_range)option*symbol_definition)list "  where 
     " defined_symbols_and_ranges0 dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img1 = ( 
    Lem_list.mapMaybe (\<lambda> (tag, maybeRange) .  
        (case  tag of
            SymbolDef0(ent) => Some (maybeRange, ent)
            | _ => failwith (''impossible: non-symbol def in list of symbol defs'')
        )) (tagged_ranges_matching_tag0 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature (SymbolDef0(null_symbol_definition0)) img1))"


(*val defined_symbols : forall 'abifeature. Ord 'abifeature, AbiFeatureTagEquiv 'abifeature =>  annotated_memory_image 'abifeature -> list symbol_definition*)
definition defined_symbols0  :: " 'abifeature Ord_class \<Rightarrow> 'abifeature AbiFeatureTagEquiv_class \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow>(symbol_definition)list "  where 
     " defined_symbols0 dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img1 = ( 
    (let (all_symbol_tags, all_symbol_ranges) = (symbol_def_ranges0 
  dict_Basic_classes_Ord_abifeature dict_Abi_classes_AbiFeatureTagEquiv_abifeature img1) in
    Lem_list.mapMaybe (\<lambda> tag .  
        (case  tag of
            SymbolDef0(ent) => Some ent
            | _ => failwith (''impossible: non-symbol def in list of symbol defs'')
        )) all_symbol_tags))"

end
