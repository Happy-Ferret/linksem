header{*Generated by Lem from elf_interpreted_section.lem.*}

theory "Elf_interpreted_section" 

imports 
 	 Main
	 "Lem_list" 
	 "Lem_num" 
	 "Lem_string" 
	 "Elf_types" 
	 "Byte_sequence" 
	 "Missing_pervasives" 
	 "Show" 

begin 

(*open import List*)
(*open import Num*)
(*open import String*)

(*open import Elf_types*)

(*open import Byte_sequence*)

(*open import Missing_pervasives*)
(*open import Show*)

record elf32_interpreted_section =
  
 elf32_section_name       ::" nat "       (** Name of the section *)
   
 elf32_section_type       ::" nat "       (** Type of the section *)
   
 elf32_section_flags      ::" nat "       (** Flags associated with the section *)
   
 elf32_section_base       ::" nat "       (** Base address of the section in memory *)
   
 elf32_section_offset     ::" nat "       (** Offset from beginning of file *)
   
 elf32_section_size       ::" nat "       (** Section size in bytes *)
   
 elf32_section_link       ::" nat "       (** Section header table index link *)
   
 elf32_section_info       ::" nat "       (** Extra information, depends on section type *)
   
 elf32_section_align      ::" nat "       (** Alignment constraints for section *)
   
 elf32_section_entry_size ::" nat "       (** Size of each entry in table, if section is one *)
   
 elf32_section_body       ::" byte_sequence " (** Body of section *)
   


record elf64_interpreted_section =
  
 elf64_section_name       ::" nat "       (** Name of the section *)
   
 elf64_section_type       ::" nat "       (** Type of the section *)
   
 elf64_section_flags      ::" nat "       (** Flags associated with the section *)
   
 elf64_section_base       ::" nat "       (** Base address of the section in memory *)
   
 elf64_section_offset     ::" nat "       (** Offset from beginning of file *)
   
 elf64_section_size       ::" nat "       (** Section size in bytes *)
   
 elf64_section_link       ::" nat "       (** Section header table index link *)
   
 elf64_section_info       ::" nat "       (** Extra information, depends on section type *)
   
 elf64_section_align      ::" nat "       (** Alignment constraints for section *)
   
 elf64_section_entry_size ::" nat "       (** Size of each entry in table, if section is one *)
   
 elf64_section_body       ::" byte_sequence " (** Body of section *)
   


type_synonym elf32_interpreted_sections =" elf32_interpreted_section list "
type_synonym elf64_interpreted_sections =" elf64_interpreted_section list "

(*val string_of_elf32_interpreted_section : elf32_interpreted_section -> string*)

(*val string_of_elf64_interpreted_section : elf64_interpreted_section -> string*)end
