chapter {* Generated by Lem from elf_file.lem. *}

theory "Elf_file" 

imports 
 	 Main
	 "/home/pes20/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/home/pes20/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/home/pes20/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/home/pes20/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/home/pes20/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/home/pes20/bitbucket/lem/isabelle-lib/Lem_string" 
	 "Show" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "Elf_header" 
	 "String_table" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)

(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Elf_interpreted_segment*)
(*open import Elf_types_native_uint*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_program_header_table*)

(*open import String_table*)

(*open import Byte_sequence*)
(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

record elf32_file =
  
 elf32_file_header               ::" elf32_header "
   
 elf32_file_program_header_table ::" elf32_program_header_table "
   
 elf32_file_section_header_table ::" elf32_section_header_table "
   
 elf32_file_interpreted_segments ::" elf32_interpreted_segments "
   
 elf32_file_interpreted_sections ::" elf32_interpreted_sections "
   
 elf32_file_bits_and_bobs        ::" (nat * byte_sequence) list "
   


(*val bytes_of_elf32_file : elf32_file -> error byte_sequence*)
definition bytes_of_elf32_file  :: " elf32_file \<Rightarrow>(byte_sequence)error "  where 
     " bytes_of_elf32_file ef = (
  (let endian      = (get_elf32_header_endianness(elf32_file_header   ef)) in
  (let hdr_bytes   = (bytes_of_elf32_header(elf32_file_header   ef)) in
  (let hdr_layout  = (( 0 :: nat), hdr_bytes) in
  (let pht_bytes   = (bytes_of_elf32_program_header_table endian(elf32_file_program_header_table   ef)) in
  (let sht_bytes   = (bytes_of_elf32_section_header_table endian(elf32_file_section_header_table   ef)) in
  (let pht_off     = (unat(elf32_phoff  (elf32_file_header   ef))) in
  (let sht_off     = (unat(elf32_shoff  (elf32_file_header   ef))) in
  (let pht_layout  = (pht_off, pht_bytes) in
  (let sht_layout  = (sht_off, sht_bytes) in
  (let bab_layout  = ((elf32_file_bits_and_bobs   ef)) in
  if List.length(elf32_file_program_header_table   ef) =
    List.length(elf32_file_interpreted_segments   ef) then
    if List.length(elf32_file_section_header_table   ef) =
      List.length(elf32_file_interpreted_sections   ef) then
      (let segs_zip  = (List.zip(elf32_file_program_header_table   ef)(elf32_file_interpreted_segments   ef)) in
      (let sects_zip = (List.zip(elf32_file_section_header_table   ef)(elf32_file_interpreted_sections   ef)) in
      (let segs_layout =        
(List.map (\<lambda> (seg, interp_seg) . 
          (unat(elf32_p_offset   seg),(elf32_segment_body   interp_seg))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf32_p_filesz   x) = (Elf_Types_Local.uint32_of_nat(( 0 :: nat))))) segs_zip))
      in
      (let sects_layout =        
(List.map (\<lambda> (sect1, interp_sect) . 
          (unat(elf32_sh_offset   sect1),(elf32_section_body   interp_sect))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf32_sh_type   x) = (Elf_Types_Local.uint32_of_nat sht_nobits))) sects_zip))
      in
      (let pre_layout = ((([hdr_layout, pht_layout, sht_layout] @ sects_layout) @ segs_layout) @ bab_layout) in
      (let final_layout =        
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) .  natural_ordering off_x off_y)
          pre_layout)
      in
      (let concats =        
(foldM (\<lambda> x y . 
          (let (current_offset, so_far) = x in
          (let (point_to_add, body) = y in
            if point_to_add < current_offset then
              (let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if Byte_sequence.length0 body < diff then
                  error_return (current_offset, so_far)
                else
                  Byte_sequence.partition0 diff body >>= (\<lambda> (_, cut1) . 
                  (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, cut1]) in
                  (let delta  = (current_offset + Byte_sequence.length0 cut1) in
                    error_return (delta, concat1)))))
            else
              (let diff   = (point_to_add - current_offset) in
              (let reps   = (Byte_sequence.create diff (0 :: 8 word)) in
              (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, reps, body]) in
              (let delta  = (point_to_add + Byte_sequence.length0 body) in
                error_return (delta, concat1)))))))
        ) (( 0 :: nat), Byte_sequence.empty) final_layout)
      in
        concats >>= (\<lambda> (offset, body) . 
        error_return body))))))))
    else
      error_fail (''bytes_of_elf32_file: interpreted sections and section header table must have same length'')
  else
    error_fail (''bytes_of_elf32_file: interpreted segments and program header table must have same length''))))))))))))"


(** Invariant:
      * Program header table and interpreted segments are in correspondence:
        * Length of two lists must be identical
        * First element of PHT must describe first interpreted segment, second
          element should describe second element, and so on.
*)
record elf64_file =
  
 elf64_file_header               ::" elf64_header "
   
 elf64_file_program_header_table ::" elf64_program_header_table "
   
 elf64_file_section_header_table ::" elf64_section_header_table "
   
 elf64_file_interpreted_segments ::" elf64_interpreted_segments "
   
 elf64_file_interpreted_sections ::" elf64_interpreted_sections "
   
 elf64_file_bits_and_bobs        ::" (nat * byte_sequence) list "
   


(*val bytes_of_elf64_file : elf64_file -> error byte_sequence*)
definition bytes_of_elf64_file  :: " elf64_file \<Rightarrow>(byte_sequence)error "  where 
     " bytes_of_elf64_file ef = (
  (let endian      = (get_elf64_header_endianness(elf64_file_header   ef)) in
  (let hdr_bytes   = (bytes_of_elf64_header(elf64_file_header   ef)) in
  (let hdr_layout  = (( 0 :: nat), hdr_bytes) in
  (let pht_bytes   = (bytes_of_elf64_program_header_table endian(elf64_file_program_header_table   ef)) in
  (let sht_bytes   = (bytes_of_elf64_section_header_table endian(elf64_file_section_header_table   ef)) in
  (let pht_off     = (unat(elf64_phoff  (elf64_file_header   ef))) in
  (let sht_off     = (unat(elf64_shoff  (elf64_file_header   ef))) in
  (let pht_layout  = (pht_off, pht_bytes) in
  (let sht_layout  = (sht_off, sht_bytes) in
  (let bab_layout  = ((elf64_file_bits_and_bobs   ef)) in
  if List.length(elf64_file_program_header_table   ef) =
    List.length(elf64_file_interpreted_segments   ef) then
    if List.length(elf64_file_section_header_table   ef) =
      List.length(elf64_file_interpreted_sections   ef) then
      (let segs_zip = (List.zip(elf64_file_program_header_table   ef)(elf64_file_interpreted_segments   ef)) in
      (let sects_zip = (List.zip(elf64_file_section_header_table   ef)(elf64_file_interpreted_sections   ef)) in
      (let segs_layout =        
(List.map (\<lambda> (seg, interp_seg) . 
          (unat(elf64_p_offset   seg),(elf64_segment_body   interp_seg))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf64_p_filesz   x) = (of_int (int (( 0 :: nat)))))) segs_zip))
      in
      (let sects_layout =        
(List.map (\<lambda> (sect1, interp_sect) . 
          (unat(elf64_sh_offset   sect1),(elf64_section_body   interp_sect))
        ) (List.filter (\<lambda> (x, _) .  \<not> ((elf64_sh_type   x) = (Elf_Types_Local.uint32_of_nat sht_nobits))) sects_zip))
      in
      (let pre_layout = ((([hdr_layout, pht_layout, sht_layout] @ sects_layout) @ segs_layout) @ bab_layout) in
      (let final_layout =        
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) .  natural_ordering off_x off_y)
          pre_layout)
      in
      (let concats =        
(foldM (\<lambda> x y . 
          (let (current_offset, so_far) = x in
          (let (point_to_add, body) = y in
            if point_to_add < current_offset then
              (let diff = (current_offset - point_to_add) in
                (* Completely contained inside other segment *)
                if Byte_sequence.length0 body < diff then
                  error_return (current_offset, so_far)
                else
                  Byte_sequence.partition0 diff body >>= (\<lambda> (_, cut1) . 
                  (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, cut1]) in
                  (let delta  = (current_offset + Byte_sequence.length0 cut1) in
                    error_return (delta, concat1)))))
            else
              (let diff   = (point_to_add - current_offset) in
              (let reps   = (Byte_sequence.create diff (0 :: 8 word)) in
              (let concat1 = (Byte_sequence.concat_byte_sequence [so_far, reps, body]) in
              (let delta  = (point_to_add + Byte_sequence.length0 body) in
                error_return (delta, concat1)))))))
        ) (( 0 :: nat), Byte_sequence.empty) final_layout)
      in
        concats >>= (\<lambda> (offset, body) . 
        error_return body))))))))
    else
      error_fail (''bytes_of_elf64_file: interpreted sections and section header table must have same length'')
  else
    error_fail (''bytes_of_elf64_file: interpreted segments and program header table must have same length''))))))))))))"


(*val obtain_elf32_program_header_table : elf32_header -> byte_sequence -> error elf32_program_header_table*)
definition obtain_elf32_program_header_table  :: " elf32_header \<Rightarrow> byte_sequence \<Rightarrow>((elf32_program_header_table_entry)list)error "  where 
     " obtain_elf32_program_header_table hdr bs0 = (
  (let endian      = (get_elf32_header_endianness hdr) in
  (let pentries    = (unat(elf32_phnum   hdr))     in
  (let pentry_size = (unat(elf32_phentsize   hdr)) in
  (let psize       = (pentries * pentry_size) in
    if psize =( 0 :: nat) then
      error_return []
    else
      (let poffset = (unat(elf32_phoff   hdr)) in
      Byte_sequence.offset_and_cut poffset psize bs0 >>= (\<lambda> pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_program_header_table psize endian pexact >>= (\<lambda> (pht, _) . 
      error_return pht))))))))"


(*val obtain_elf64_program_header_table : elf64_header -> byte_sequence -> error elf64_program_header_table*)
definition obtain_elf64_program_header_table  :: " elf64_header \<Rightarrow> byte_sequence \<Rightarrow>((elf64_program_header_table_entry)list)error "  where 
     " obtain_elf64_program_header_table hdr bs0 = (
  (let endian      = (get_elf64_header_endianness hdr) in
  (let pentries    = (unat(elf64_phnum   hdr))     in
  (let pentry_size = (unat(elf64_phentsize   hdr)) in
  (let psize       = (pentries * pentry_size) in
    if psize =( 0 :: nat) then
      error_return []
    else
      (let poffset = (unat(elf64_phoff   hdr)) in
      Byte_sequence.offset_and_cut poffset psize bs0 >>= (\<lambda> pexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_program_header_table psize endian pexact >>= (\<lambda> (pht, _) . 
      error_return pht))))))))"


(*val obtain_elf32_section_header_table : elf32_header -> byte_sequence -> error elf32_section_header_table*)
definition obtain_elf32_section_header_table  :: " elf32_header \<Rightarrow> byte_sequence \<Rightarrow>((elf32_section_header_table_entry)list)error "  where 
     " obtain_elf32_section_header_table hdr bs0 = (
  (let endian      = (get_elf32_header_endianness hdr) in
  (let sentries    = (unat(elf32_shnum   hdr)) in
  (let sentry_size = (unat(elf32_shentsize   hdr)) in
  (let ssize       = (sentries * sentry_size) in
    if ssize =( 0 :: nat) then
      error_return []
    else
      (let soffset = (unat(elf32_shoff   hdr)) in
      Byte_sequence.offset_and_cut soffset ssize bs0 >>= (\<lambda> sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf32_section_header_table ssize endian sexact >>= (\<lambda> (sht, _) . 
      error_return sht))))))))"


(*val obtain_elf64_section_header_table : elf64_header -> byte_sequence -> error elf64_section_header_table*)
definition obtain_elf64_section_header_table  :: " elf64_header \<Rightarrow> byte_sequence \<Rightarrow>((elf64_section_header_table_entry)list)error "  where 
     " obtain_elf64_section_header_table hdr bs0 = (
  (let endian      = (get_elf64_header_endianness hdr) in
  (let sentries    = (unat(elf64_shnum   hdr)) in
  (let sentry_size = (unat(elf64_shentsize   hdr)) in
  (let ssize       = (sentries * sentry_size) in
    if ssize =( 0 :: nat) then
      error_return []
    else
      (let soffset = (unat(elf64_shoff   hdr)) in
      Byte_sequence.offset_and_cut soffset ssize bs0 >>= (\<lambda> sexact . 
      (* Byte sequence irrelevant below as exact size used... *)
      read_elf64_section_header_table ssize endian sexact >>= (\<lambda> (sht, _) . 
      error_return sht))))))))"

      
(*val obtain_elf32_section_header_string_table : elf32_header -> elf32_section_header_table -> byte_sequence -> error string_table*)
definition obtain_elf32_section_header_string_table  :: " elf32_header \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>(string_table)error "  where 
     " obtain_elf32_section_header_string_table hdr sht bs0 = (
  (case  Elf_Types_Local.index sht (unat(elf32_shstrndx   hdr)) of 
    None => error_fail (''no section header string table'')
    | Some x => error_return x
  ) >>= (\<lambda> sh . 
  Byte_sequence.offset_and_cut (unat(elf32_sh_offset   sh)) (unat(elf32_sh_size   sh)) bs0 >>= (\<lambda> sexact . 
  error_return (string_table_of_byte_sequence sexact))))"

      
(*val obtain_elf64_section_header_string_table : elf64_header -> elf64_section_header_table -> byte_sequence -> error string_table*)
definition obtain_elf64_section_header_string_table  :: " elf64_header \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>(string_table)error "  where 
     " obtain_elf64_section_header_string_table hdr sht bs0 = (
  (case  Elf_Types_Local.index sht (unat(elf64_shstrndx   hdr)) of 
    None => error_fail (''no section header string table'')
    | Some x => error_return x
  ) >>= (\<lambda> sh . 
  Byte_sequence.offset_and_cut (unat(elf64_sh_offset   sh)) (unat(elf64_sh_size   sh)) bs0 >>= (\<lambda> sexact . 
  error_return (string_table_of_byte_sequence sexact))))"


(*val obtain_elf32_interpreted_segments : elf32_program_header_table -> byte_sequence -> error elf32_interpreted_segments*)
definition obtain_elf32_interpreted_segments  :: "(elf32_program_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf32_interpreted_segment)list)error "  where 
     " obtain_elf32_interpreted_segments pht bdy = (
  mapM (\<lambda> ph . 
    (let offset   = (unat(elf32_p_offset   ph))  in
    (let size2     = (unat(elf32_p_filesz   ph)) in
      (if size2 =( 0 :: nat) then
         error_return Byte_sequence.empty
       else
         Byte_sequence.offset_and_cut offset size2 bdy) >>= (\<lambda> relevant . 
    (let vaddr    = (unat(elf32_p_vaddr   ph)) in
    (let paddr    = (unat(elf32_p_paddr   ph)) in
    (let memsz    = (unat(elf32_p_memsz   ph)) in
    (let typ1      = (unat(elf32_p_type   ph))  in
    (let align    = (unat(elf32_p_align   ph)) in
    (let flags    = (elf32_interpret_program_header_flags(elf32_p_flags   ph)) in
      if memsz < size2 then
        error_fail (''obtain_elf32_interpreted_segments: memory size of segment cannot be less than file size'')
      else
        error_return  (| elf32_segment_body = relevant, elf32_segment_type = typ1,
 elf32_segment_size = size2, elf32_segment_memsz = memsz,
 elf32_segment_base = vaddr,
 elf32_segment_paddr = paddr, elf32_segment_align = align,
 elf32_segment_offset = offset, elf32_segment_flags = flags  |))))))))))
    ) pht )"


(*val obtain_elf64_interpreted_segments : elf64_program_header_table -> byte_sequence -> error elf64_interpreted_segments*)
definition obtain_elf64_interpreted_segments  :: "(elf64_program_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf64_interpreted_segment)list)error "  where 
     " obtain_elf64_interpreted_segments pht bdy = (
  mapM (\<lambda> ph . 
    (let offset   = (unat(elf64_p_offset     ph))  in
    (let size2     = (unat(elf64_p_filesz   ph)) in
      (if size2 =( 0 :: nat) then
         error_return Byte_sequence.empty
       else
         Byte_sequence.offset_and_cut offset size2 bdy) >>= (\<lambda> relevant . 
    (let vaddr    = (unat(elf64_p_vaddr    ph)) in
    (let paddr    = (unat(elf64_p_paddr    ph)) in
    (let memsz    = (unat(elf64_p_memsz   ph)) in
    (let typ1      = (unat(elf64_p_type    ph))  in
    (let align    = (unat(elf64_p_align   ph)) in
    (let flags    = (elf64_interpret_program_header_flags(elf64_p_flags   ph)) in
      if memsz < size2 then
        error_fail (''obtain_elf64_interpreted_segments: memory size of segment cannot be less than file size'')
      else
        error_return  (| elf64_segment_body = relevant, elf64_segment_type = typ1,
 elf64_segment_size = size2, elf64_segment_memsz = memsz,
 elf64_segment_base = vaddr, elf64_segment_paddr = paddr,
 elf64_segment_align = align,
 elf64_segment_offset = offset, elf64_segment_flags = flags  |))))))))))
    ) pht )"


(*val obtain_elf32_interpreted_sections : string_table -> elf32_section_header_table -> byte_sequence -> error elf32_interpreted_sections*)
definition obtain_elf32_interpreted_sections  :: " string_table \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf32_interpreted_section)list)error "  where 
     " obtain_elf32_interpreted_sections shstrtab sht bs0 = (
  mapM (\<lambda> sh . 
    (let offset = (unat(elf32_sh_offset    sh)) in
    (let size2   = (unat(elf32_sh_size   sh)) in
    (let name1   = (unat(elf32_sh_name   sh)) in
    (let typ1    = (unat(elf32_sh_type   sh)) in
    (let filesz = (if typ1 = sht_nobits then( 0 :: nat) else size2) in
    (let flags  = (unat(elf32_sh_flags   sh)) in
    (let base   = (unat(elf32_sh_addr   sh)) in
    (let link   = (unat(elf32_sh_link   sh)) in
    (let info   = (unat(elf32_sh_info   sh)) in
    (let align  = (unat(elf32_sh_addralign   sh)) in
    (let entry_size = (unat(elf32_sh_entsize   sh)) in
    (let name_string = ((case  (get_string_at name1 shstrtab) of Success n => n | Fail _ => ('''') )) in
      (if filesz =( 0 :: nat) then
        error_return Byte_sequence.empty
      else
        Byte_sequence.offset_and_cut offset filesz bs0) >>= (\<lambda> relevant . 
      error_return  (| elf32_section_name = name1, elf32_section_type = typ1,
 elf32_section_flags = flags, elf32_section_addr = base, elf32_section_offset = offset,
 elf32_section_size = size2,
 elf32_section_link = link, elf32_section_info = info,
 elf32_section_align = align,
 elf32_section_entsize = entry_size, elf32_section_body = relevant,
 elf32_section_name_as_string = name_string  |))))))))))))))
  ) sht )"


(*val obtain_elf64_interpreted_sections : string_table -> elf64_section_header_table -> byte_sequence -> error elf64_interpreted_sections*)
definition obtain_elf64_interpreted_sections  :: " string_table \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow> byte_sequence \<Rightarrow>((elf64_interpreted_section)list)error "  where 
     " obtain_elf64_interpreted_sections shstrtab sht bs0 = (
  mapM (\<lambda> sh . 
    (let offset = (unat(elf64_sh_offset     sh)) in
    (let size2   = (unat(elf64_sh_size   sh)) in
    (let name1   = (unat(elf64_sh_name    sh)) in
    (let typ1    = (unat(elf64_sh_type    sh)) in
    (let filesz = (if typ1 = sht_nobits then( 0 :: nat) else size2) in
    (let flags  = (unat(elf64_sh_flags   sh)) in
    (let base   = (unat(elf64_sh_addr    sh)) in
    (let link   = (unat(elf64_sh_link    sh)) in
    (let info   = (unat(elf64_sh_info    sh)) in
    (let align  = (unat(elf64_sh_addralign   sh)) in
    (let entry_size = (unat(elf64_sh_entsize   sh)) in
    (let name_string = ((case  (get_string_at name1 shstrtab) of Success n => n | Fail _ => ('''') )) in 
      (if filesz =( 0 :: nat) then
        error_return Byte_sequence.empty
      else
        Byte_sequence.offset_and_cut offset filesz bs0) >>= (\<lambda> relevant . 
      error_return  (| elf64_section_name = name1, elf64_section_type = typ1,
 elf64_section_flags = flags, elf64_section_addr = base, elf64_section_offset = offset,
 elf64_section_size = size2,
 elf64_section_link = link, elf64_section_info = info,
 elf64_section_align = align,
 elf64_section_entsize = entry_size, elf64_section_body = relevant,
 elf64_section_name_as_string = name_string  |))))))))))))))
  ) sht )"


(*val find_first_not_in_range : natural -> list (natural * natural) -> natural*)
function (sequential,domintros)  find_first_not_in_range  :: " nat \<Rightarrow>(nat*nat)list \<Rightarrow> nat "  where 
     " find_first_not_in_range start ranges = (
  (case  List.filter (\<lambda> (x, y) .  (start \<ge> x) \<and> (start \<le> y)) ranges of
      [] => start
    | _  => find_first_not_in_range (start +( 1 :: nat)) ranges
  ))" 
by pat_completeness auto


(*val find_first_in_range : natural -> list (natural * natural) -> natural*)
function (sequential,domintros)  find_first_in_range  :: " nat \<Rightarrow>(nat*nat)list \<Rightarrow> nat "  where 
     " find_first_in_range start ranges = (
  (case  List.filter (\<lambda> (x, y) .  (start \<ge> x) \<and> (start \<le> y)) ranges of
      [] => find_first_in_range (start +( 1 :: nat)) ranges
    | _  => start
  ))" 
by pat_completeness auto


(*val compute_differences : natural -> natural -> list (natural * natural) -> error (list (natural * natural))*)
function (sequential,domintros)  compute_differences  :: " nat \<Rightarrow> nat \<Rightarrow>(nat*nat)list \<Rightarrow>((nat*nat)list)error "  where 
     " compute_differences start max1 ranges = (
  if start = max1 then
    error_return []
  else if start > max1 then
    error_fail (''compute_differences: passed maximum'')
  else
    (let first1 = (find_first_not_in_range start ranges) in
      if first1 \<ge> max1 then
        error_return []
      else
        (let last1 = (find_first_in_range first1 ranges) in
          if last1 > max1 then
            error_return [(first1, max1)]
          else
            compute_differences last1 max1 ranges >>= (\<lambda> tail . 
            error_return ((first1, last1)# tail)))))" 
by pat_completeness auto


(*val obtain_elf32_bits_and_bobs : elf32_header -> elf32_program_header_table -> elf32_interpreted_segments
  -> elf32_section_header_table -> elf32_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
definition obtain_elf32_bits_and_bobs  :: " elf32_header \<Rightarrow>(elf32_program_header_table_entry)list \<Rightarrow>(elf32_interpreted_segment)list \<Rightarrow>(elf32_section_header_table_entry)list \<Rightarrow>(elf32_interpreted_section)list \<Rightarrow> byte_sequence \<Rightarrow>((nat*byte_sequence)list)error "  where 
     " obtain_elf32_bits_and_bobs hdr segs interp_segs sects interp_sects bs0 = (
  (let hdr_off_len  = (( 0 :: nat), unat(elf32_ehsize   hdr)) in
  (let pht_off      = (unat(elf32_phoff   hdr)) in
  (let pht_len      = (unat(elf32_phentsize   hdr) * unat(elf32_phnum   hdr)) in
  (let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  (let sht_off      = (unat(elf32_shoff   hdr)) in
  (let sht_len      = (unat(elf32_shentsize   hdr) * unat(elf32_shnum   hdr)) in
  (let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if List.length interp_segs = List.length segs then
      (let seg_zip = (List.zip segs interp_segs) in
      if List.length interp_sects = List.length sects then
        (let sect_zip = (List.zip sects interp_sects) in
        (let seg_off_len  =          
(List.map (\<lambda> (seg, interp_seg) . 
            (let start = (unat(elf32_p_offset   seg)) in
            (let len   = ((elf32_segment_size   interp_seg)) in
            (start, (start + len))))) seg_zip)
        in
        (let sect_off_len =          
(List.map (\<lambda> (sect1, interp_sect) . 
            (let start = (unat(elf32_sh_offset   sect1)) in
            (let len   = ((elf32_section_size   interp_sect)) in
            (start, (start + len))))) sect_zip)
        in
        (let pre_layout   = (hdr_off_len # (pht_off_len # (sht_off_len # (seg_off_len @ sect_off_len)))) in
        (let layout       =          
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) . 
            natural_ordering off_x off_y
          ) pre_layout)
        in
          compute_differences(( 0 :: nat)) (Byte_sequence.length0 bs0) layout >>= (\<lambda> diffs . 
            mapM (\<lambda> (start, len) . 
              Byte_sequence.offset_and_cut start (len - start) bs0 >>= (\<lambda> rel . 
              error_return (start, rel))
            ) diffs))))))
      else
        error_fail (''obtain_elf32_bits_and_bobs: section header table and interpreted section differ in length''))
    else
      error_fail (''obtain_elf32_bits_and_bobs: program header table and interpreted segments differ in length'')))))))))"


(*val obtain_elf64_bits_and_bobs : elf64_header -> elf64_program_header_table -> elf64_interpreted_segments
  -> elf64_section_header_table -> elf64_interpreted_sections -> byte_sequence -> error (list (natural * byte_sequence))*)
definition obtain_elf64_bits_and_bobs  :: " elf64_header \<Rightarrow>(elf64_program_header_table_entry)list \<Rightarrow>(elf64_interpreted_segment)list \<Rightarrow>(elf64_section_header_table_entry)list \<Rightarrow>(elf64_interpreted_section)list \<Rightarrow> byte_sequence \<Rightarrow>((nat*byte_sequence)list)error "  where 
     " obtain_elf64_bits_and_bobs hdr segs interp_segs sects interp_sects bs0 = (
  (let hdr_off_len  = (( 0 :: nat), unat(elf64_ehsize   hdr)) in
  
  (let pht_off      = (unat(elf64_phoff   hdr)) in
  (let pht_len      = (unat(elf64_phentsize   hdr) * unat(elf64_phnum   hdr)) in
  (let pht_off_len  = (pht_off, (pht_off + pht_len)) in
  (let sht_off      = (unat(elf64_shoff   hdr)) in
  (let sht_len      = (unat(elf64_shentsize   hdr) * unat(elf64_shnum   hdr)) in
  (let sht_off_len  = (sht_off, (sht_off + sht_len)) in
    if List.length interp_segs = List.length segs then
      (let seg_zip = (List.zip segs interp_segs) in
      if List.length interp_sects = List.length sects then
        (let sect_zip = (List.zip sects interp_sects) in
        (let seg_off_len  =          
(List.map (\<lambda> (seg, interp_seg) . 
            (let start = (unat(elf64_p_offset   seg)) in
            (let len   = ((elf64_segment_size   interp_seg)) in
            (start, (start + len))))) seg_zip)
        in
        (let sect_off_len =          
(List.map (\<lambda> (sect1, interp_sect) . 
            (let start = (unat(elf64_sh_offset   sect1)) in
            (let len   = ((elf64_section_size   interp_sect)) in
            (start, (start + len))))) sect_zip)
        in
        (let pre_layout   = (hdr_off_len # (pht_off_len # (sht_off_len # (seg_off_len @ sect_off_len)))) in
        (let layout       =          
(Elf_Types_Local.merge_sort (\<lambda> (off_x, _) (off_y, _) . 
            natural_ordering off_x off_y
          ) pre_layout)
        in
          compute_differences(( 0 :: nat)) (Byte_sequence.length0 bs0) layout >>= (\<lambda> diffs . 
            mapM (\<lambda> (start, finish) . 
              Byte_sequence.offset_and_cut start (finish - start) bs0 >>= (\<lambda> rel . 
              error_return (start, rel))
            ) diffs))))))
      else
        error_fail (''obtain_elf64_bits_and_bobs: section header table and interpreted section differ in length''))
    else
      error_fail (''obtain_elf64_bits_and_bobs: program header table and interpreted segments differ in length'')))))))))"


(*val read_elf32_file : byte_sequence -> error elf32_file*)
definition read_elf32_file  :: " byte_sequence \<Rightarrow>(elf32_file)error "  where 
     " read_elf32_file bs0 = (
  read_elf32_header bs0 >>= (\<lambda> (hdr, bs1) . 
  obtain_elf32_program_header_table hdr bs0 >>= (\<lambda> pht  . 
  obtain_elf32_section_header_table hdr bs0 >>= (\<lambda> sht  . 
  obtain_elf32_section_header_string_table hdr sht bs0 >>= (\<lambda> shstrtab . 
  obtain_elf32_interpreted_segments pht bs0 >>= (\<lambda> segs . 
  obtain_elf32_interpreted_sections shstrtab sht bs0 >>= (\<lambda> sects . 
  obtain_elf32_bits_and_bobs hdr pht segs sht sects bs0 >>= (\<lambda> bits_and_bobs . 
  error_return (| elf32_file_header = hdr,
              elf32_file_program_header_table = pht,
              elf32_file_section_header_table = sht,
              elf32_file_interpreted_segments = segs,
              elf32_file_interpreted_sections = sects,
              elf32_file_bits_and_bobs = bits_and_bobs |)))))))))"


(*val read_elf64_file : byte_sequence -> error elf64_file*)
definition read_elf64_file  :: " byte_sequence \<Rightarrow>(elf64_file)error "  where 
     " read_elf64_file bs0 = (
  read_elf64_header bs0 >>= (\<lambda> (hdr, bs1) . 
  obtain_elf64_program_header_table hdr bs0 >>= (\<lambda> pht  . 
  obtain_elf64_section_header_table hdr bs0 >>= (\<lambda> sht  . 
  obtain_elf64_section_header_string_table hdr sht bs0 >>= (\<lambda> shstrtab . 
  obtain_elf64_interpreted_segments pht bs0 >>= (\<lambda> segs . 
  obtain_elf64_interpreted_sections shstrtab sht bs0 >>= (\<lambda> sects . 
  obtain_elf64_bits_and_bobs hdr pht segs sht sects bs0 >>= (\<lambda> bits_and_bobs . 
  error_return (| elf64_file_header = hdr,
              elf64_file_program_header_table = pht,
              elf64_file_section_header_table = sht,
              elf64_file_interpreted_segments = segs,
              elf64_file_interpreted_sections = sects,
              elf64_file_bits_and_bobs = bits_and_bobs |)))))))))"


(*val get_elf32_file_section_header_string_table : elf32_file -> error string_table*)
definition get_elf32_file_section_header_string_table  :: " elf32_file \<Rightarrow>(string_table)error "  where 
     " get_elf32_file_section_header_string_table f3 = (
  (let hdr  = ((elf32_file_header   f3)) in
  (let sht  = ((elf32_file_section_header_table   f3)) in
  (let segs = ((elf32_file_interpreted_segments   f3)) in
  (let idx  = (unat(elf32_shstrndx   hdr)) in
  bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
    (case  Elf_Types_Local.index sht idx of
        None => error_fail (''obtain_elf32_string_table: invalid offset into section header table'')
      | Some sect1 =>
          (let offset = (unat(elf32_sh_offset   sect1)) in
          (let size2   = (unat(elf32_sh_size   sect1)) in
          Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> rel . 
          (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
          error_return (String_table.mk_string_table strings (0 :: 8 word))))))
    )))))))"


(*val get_elf64_file_section_header_string_table : elf64_file -> error string_table*)
definition get_elf64_file_section_header_string_table  :: " elf64_file \<Rightarrow>(string_table)error "  where 
     " get_elf64_file_section_header_string_table f3 = (
  (let hdr  = ((elf64_file_header   f3)) in
  (let sht  = ((elf64_file_section_header_table   f3)) in
  (let segs = ((elf64_file_interpreted_segments   f3)) in
  (let idx  = (unat(elf64_shstrndx   hdr)) in
  bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
    (case  Elf_Types_Local.index sht idx of
        None => error_fail (''obtain_elf64_string_table: invalid offset into section header table'')
      | Some sect1 =>
          (let offset = (unat(elf64_sh_offset     sect1)) in
          (let size2   = (unat(elf64_sh_size   sect1)) in
          Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> rel . 
          (let strings  = (Byte_sequence.string_of_byte_sequence rel) in
          error_return (String_table.mk_string_table strings (0 :: 8 word))))))
    )))))))"

    
(*val find_elf32_symbols_by_symtab_idx : natural -> elf32_file -> error (elf32_symbol_table * string_table * natural)*)
definition find_elf32_symbols_by_symtab_idx  :: " nat \<Rightarrow> elf32_file \<Rightarrow>((elf32_symbol_table_entry)list*string_table*nat)error "  where 
     " find_elf32_symbols_by_symtab_idx sec_idx f = (
    (case  index(elf32_file_interpreted_sections   f) ( sec_idx) of
        None => error_fail (''impossible: interpreted section found but not indexable'')
        | Some sec => error_return sec
    ) >>= (\<lambda> sec .  
    (case  index(elf32_file_interpreted_sections   f) ((elf32_section_link   sec)) of
        None => error_fail (''no associated strtab'')
        | Some strs => error_return strs
    ) >>= (\<lambda> strs .  
    (let strings = (Byte_sequence.string_of_byte_sequence(elf32_section_body   strs)) in
    (let strtab = (String_table.mk_string_table strings (0 :: 8 word)) in
    (let endian = (get_elf32_header_endianness(elf32_file_header   f)) in
    read_elf32_symbol_table endian(elf32_section_body   sec) >>= (\<lambda> symtab . 
    error_return (symtab, strtab, sec_idx))))))))"


(*val find_elf32_symtab_by_type : natural -> elf32_file -> error (elf32_symbol_table * string_table * natural)*)
definition find_elf32_symtab_by_type  :: " nat \<Rightarrow> elf32_file \<Rightarrow>(elf32_symbol_table*string_table*nat)error "  where 
     " find_elf32_symtab_by_type t f = (
    (let found_symtab_index = (find_index (\<lambda> sh . (elf32_section_type   sh) = t)(elf32_file_interpreted_sections   f)) in
    (case  found_symtab_index of 
        None => error_fail (''no such symtab'')
        | Some sec_idx => error_return sec_idx
    ) >>= (\<lambda> sec_idx .  find_elf32_symbols_by_symtab_idx sec_idx f)))"


(*val find_elf64_symbols_by_symtab_idx : natural -> elf64_file -> error (elf64_symbol_table * string_table * natural)*)
definition find_elf64_symbols_by_symtab_idx  :: " nat \<Rightarrow> elf64_file \<Rightarrow>((elf64_symbol_table_entry)list*string_table*nat)error "  where 
     " find_elf64_symbols_by_symtab_idx sec_idx f = (
    (case  index(elf64_file_interpreted_sections   f) ( sec_idx) of
        None => error_fail (''impossible: interpreted section found but not indexable'')
        | Some sec => error_return sec
    ) >>= (\<lambda> sec .  
    (case  index(elf64_file_interpreted_sections   f) ((elf64_section_link   sec)) of
        None => error_fail (''no associated strtab'')
        | Some strs => error_return strs
    ) >>= (\<lambda> strs .  
    (let strings = (Byte_sequence.string_of_byte_sequence(elf64_section_body   strs)) in
    (let strtab = (String_table.mk_string_table strings (0 :: 8 word)) in
    (let endian = (get_elf64_header_endianness(elf64_file_header   f)) in
    read_elf64_symbol_table endian(elf64_section_body   sec) >>= (\<lambda> symtab . 
    error_return (symtab, strtab, sec_idx))))))))"


(*val find_elf64_symtab_by_type : natural -> elf64_file -> error (elf64_symbol_table * string_table * natural)*)
definition find_elf64_symtab_by_type  :: " nat \<Rightarrow> elf64_file \<Rightarrow>(elf64_symbol_table*string_table*nat)error "  where 
     " find_elf64_symtab_by_type t f = (
    (let found_symtab_index = (find_index (\<lambda> sh . (elf64_section_type   sh) = t)(elf64_file_interpreted_sections   f)) in
    (case  found_symtab_index of 
        None => error_fail (''no such symtab'')
        | Some sec_idx => error_return sec_idx
    ) >>= (\<lambda> sec_idx .  find_elf64_symbols_by_symtab_idx sec_idx f)))"


(*val get_elf32_file_symbol_string_table : elf32_file -> error string_table*)
definition get_elf32_file_symbol_string_table  :: " elf32_file \<Rightarrow>(string_table)error "  where 
     " get_elf32_file_symbol_string_table f3 = (
  (let hdr     = ((elf32_file_header   f3)) in
  (let sht     = ((elf32_file_section_header_table   f3)) in
  (let segs    = ((elf32_file_interpreted_segments   f3)) in
  (let strtabs = (Missing_pervasives.mapMaybei (\<lambda> index1 sect1 . 
    if unat(elf32_sh_type   sect1) = sht_strtab then
      if index1 = unat(elf32_shstrndx   hdr) then
        None
      else
        Some sect1
    else
      None) sht)
  in
    bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
    mapM (\<lambda> sect1 . 
      (let offset  = (unat(elf32_sh_offset    sect1)) in
      (let size2    = (unat(elf32_sh_size   sect1)) in
      Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> bs1 . 
      (let strings = (Byte_sequence.string_of_byte_sequence bs1) in
      error_return (String_table.mk_string_table strings (0 :: 8 word))))))) strtabs
    >>= (\<lambda> strings . 
      String_table.concat_string_table strings)))))))"


(*val get_elf64_file_symbol_string_table : elf64_file -> error string_table*)
definition get_elf64_file_symbol_string_table  :: " elf64_file \<Rightarrow>(string_table)error "  where 
     " get_elf64_file_symbol_string_table f3 = (
  (let hdr     = ((elf64_file_header   f3)) in
  (let sht     = ((elf64_file_section_header_table   f3)) in
  (let segs    = ((elf64_file_interpreted_segments   f3)) in
  (let strtabs = (Missing_pervasives.mapMaybei (\<lambda> index1 sect1 . 
    if unat(elf64_sh_type   sect1) = sht_strtab then
      if index1 = unat(elf64_shstrndx   hdr) then
        None
      else
        Some sect1
    else
      None) sht)
  in
    bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
    mapM (\<lambda> sect1 . 
      (let offset  = (unat(elf64_sh_offset     sect1)) in
      (let size2    = (unat(elf64_sh_size   sect1)) in
      Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> bs1 . 
      (let strings = (Byte_sequence.string_of_byte_sequence bs1) in
      error_return (String_table.mk_string_table strings (0 :: 8 word))))))) strtabs
    >>= (\<lambda> strings . 
      String_table.concat_string_table strings)))))))"


(*val get_elf32_file_symbol_table : elf32_file -> error elf32_symbol_table*)
definition get_elf32_file_symbol_table  :: " elf32_file \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " get_elf32_file_symbol_table f3 = (
  (let hdr     = ((elf32_file_header   f3)) in
  (let sht     = ((elf32_file_section_header_table   f3)) in
  (let segs    = ((elf32_file_interpreted_segments   f3)) in
  (let endian  = (get_elf32_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf32_sh_type   sect1) = sht_symtab
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf32_sh_offset   symtab)) in
        (let size2   = (unat(elf32_sh_size   symtab)) in
        bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> relevant . 
        read_elf32_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf32_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB'')
    )))))))"


(*val get_elf64_file_symbol_table : elf64_file -> error elf64_symbol_table*)
definition get_elf64_file_symbol_table  :: " elf64_file \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " get_elf64_file_symbol_table f3 = (
  (let hdr     = ((elf64_file_header   f3)) in
  (let sht     = ((elf64_file_section_header_table   f3)) in
  (let segs    = ((elf64_file_interpreted_segments   f3)) in
  (let endian  = (get_elf64_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf64_sh_type   sect1) = sht_symtab
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf64_sh_offset     symtab)) in
        (let size2   = (unat(elf64_sh_size   symtab)) in
        bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> relevant . 
        read_elf64_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf64_symbol_table: an ELF file may only have one symbol table of type SHT_SYMTAB'')
    )))))))"


(*val get_elf32_file_dynamic_symbol_table : elf32_file -> error elf32_symbol_table*)
definition get_elf32_file_dynamic_symbol_table  :: " elf32_file \<Rightarrow>((elf32_symbol_table_entry)list)error "  where 
     " get_elf32_file_dynamic_symbol_table ef = (
  (let hdr     = ((elf32_file_header   ef)) in
  (let sht     = ((elf32_file_section_header_table   ef)) in
  (let segs    = ((elf32_file_interpreted_segments   ef)) in
  (let endian  = (get_elf32_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf32_sh_type   sect1) = sht_dynsym
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf32_sh_offset   symtab)) in
        (let size2   = (unat(elf32_sh_size   symtab)) in
        bytes_of_elf32_file ef >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> relevant . 
        read_elf32_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf32_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM'')
    )))))))"


(*val get_elf64_file_dynamic_symbol_table : elf64_file -> error elf64_symbol_table*)
definition get_elf64_file_dynamic_symbol_table  :: " elf64_file \<Rightarrow>((elf64_symbol_table_entry)list)error "  where 
     " get_elf64_file_dynamic_symbol_table ef = (
  (let hdr     = ((elf64_file_header   ef)) in
  (let sht     = ((elf64_file_section_header_table   ef)) in
  (let segs    = ((elf64_file_interpreted_segments   ef)) in
  (let endian  = (get_elf64_header_endianness hdr) in
  (let symtabs = (List.filter (\<lambda> sect1 . 
    unat(elf64_sh_type   sect1) = sht_dynsym
    ) sht)
  in
    (case  symtabs of
        [] => error_return []
      | [symtab] =>
        (let offset = (unat(elf64_sh_offset     symtab)) in
        (let size2   = (unat(elf64_sh_size   symtab)) in
        bytes_of_elf64_file ef >>= (\<lambda> bs0 . 
        Byte_sequence.offset_and_cut offset size2 bs0 >>= (\<lambda> relevant . 
        read_elf64_symbol_table endian relevant))))
      | _ =>
        error_fail (''obtain_elf64_dynamic_symbol_table: an ELF file may only have one symbol table of type SHT_DYNSYM'')
    )))))))"

    
(*val get_elf32_symbol_table_by_index : elf32_file -> natural -> error elf32_symbol_table*)
definition get_elf32_symbol_table_by_index  :: " elf32_file \<Rightarrow> nat \<Rightarrow>(elf32_symbol_table)error "  where 
     " get_elf32_symbol_table_by_index ef link = (
  (let hdr     = ((elf32_file_header   ef)) in
  (let sht     = ((elf32_file_section_header_table   ef)) in
  (let sects   = ((elf32_file_interpreted_sections   ef)) in
  (let endian  = (get_elf32_header_endianness hdr) in
    (case  index sects (id link) of
        None  => error_fail (''get_elf32_symbol_table_by_index: invalid index'')
      | Some sym =>
        read_elf32_symbol_table endian(elf32_section_body   sym)
    ))))))"

    
(*val get_elf32_string_table_by_index : elf32_file -> natural -> error string_table*)
definition get_elf32_string_table_by_index  :: " elf32_file \<Rightarrow> nat \<Rightarrow>(string_table)error "  where 
     " get_elf32_string_table_by_index ef link = (
  (let hdr     = ((elf32_file_header   ef)) in
  (let sht     = ((elf32_file_section_header_table   ef)) in
  (let sects   = ((elf32_file_interpreted_sections   ef)) in
    (case  index sects (id link) of
        None  => error_fail (''get_elf32_string_table_by_index: invalid index'')
      | Some sym => error_return (mk_string_table (Byte_sequence.string_of_byte_sequence(elf32_section_body   sym)) (0 :: 8 word))
    )))))"

    
(*val get_elf64_symbol_table_by_index : elf64_file -> natural -> error elf64_symbol_table*)
definition get_elf64_symbol_table_by_index  :: " elf64_file \<Rightarrow> nat \<Rightarrow>(elf64_symbol_table)error "  where 
     " get_elf64_symbol_table_by_index ef link = (
  (let hdr     = ((elf64_file_header   ef)) in
  (let sht     = ((elf64_file_section_header_table   ef)) in
  (let sects   = ((elf64_file_interpreted_sections   ef)) in
  (let endian  = (get_elf64_header_endianness hdr) in
    (case  index sects (id link) of
        None  => error_fail (''get_elf64_symbol_table_by_index: invalid index'')
      | Some sym =>
        read_elf64_symbol_table endian(elf64_section_body   sym)
    ))))))"

    
(*val get_elf64_string_table_by_index : elf64_file -> natural -> error string_table*)
definition get_elf64_string_table_by_index  :: " elf64_file \<Rightarrow> nat \<Rightarrow>(string_table)error "  where 
     " get_elf64_string_table_by_index ef link = (
  (let hdr     = ((elf64_file_header   ef)) in
  (let sht     = ((elf64_file_section_header_table   ef)) in
  (let sects   = ((elf64_file_interpreted_sections   ef)) in
    (case  index sects (id link) of
        None  => error_fail (''get_elf64_string_table_by_index: invalid index'')
      | Some sym => error_return (mk_string_table (Byte_sequence.string_of_byte_sequence(elf64_section_body   sym)) (0 :: 8 word))
    )))))"


datatype segment_provenance
  = FromELF
  | AutoGenerated

(** Segments, entry point, machine type *)
type_synonym elf32_executable_process_image ="
  ( (elf32_interpreted_segment * segment_provenance)list * nat * nat)"

(** Segments, entry point, machine type *)
type_synonym elf64_executable_process_image ="
  ( (elf64_interpreted_segment * segment_provenance)list * nat * nat)"

(*val get_elf32_executable_image : elf32_file -> error elf32_executable_process_image*)
definition get_elf32_executable_image  :: " elf32_file \<Rightarrow>((elf32_interpreted_segment*segment_provenance)list*nat*nat)error "  where 
     " get_elf32_executable_image f3 = (
  if is_elf32_executable_file(elf32_file_header   f3) then
    (let entr = ((elf32_entry  (elf32_file_header   f3))) in
    (let segs = ((elf32_file_interpreted_segments   f3)) in
    (let mach = ((elf32_machine  (elf32_file_header   f3))) in
      (case  List.filter (\<lambda> sg . (elf32_segment_type   sg) = elf_pt_load) segs of
          []    => error_fail (''get_elf32_executable_image: an executable ELF file must have at least one loadable segment'')
        | load  =>
            mapM (\<lambda> sg . 
              if(elf32_segment_memsz   sg) =( 0 :: nat) then
                error_return []
              else if(elf32_segment_memsz   sg) =(elf32_segment_size   sg) then
                error_return [(sg, FromELF)]
              else if(elf32_segment_size   sg) <(elf32_segment_memsz   sg) then
                (* Cannot be negative due to check in constructing [segs]. *)
                (let diff  = ((elf32_segment_memsz   sg) -(elf32_segment_size   sg)) in
                (let zeros1 = (Byte_sequence.zeros diff) in
                (let addr  = ((elf32_segment_base   sg) +(elf32_segment_size   sg)) in
                (let align = ((elf32_segment_align   sg)) in
                (let paddr = ((elf32_segment_paddr   sg)) in
                (let seg   = 
  ((| elf32_segment_body = zeros1, elf32_segment_type =(elf32_segment_type   sg),
   elf32_segment_size = diff, elf32_segment_memsz = diff,
   elf32_segment_base = addr, elf32_segment_paddr = paddr,
   elf32_segment_align = align,
   elf32_segment_offset =(elf32_segment_offset   sg), elf32_segment_flags =(elf32_segment_flags   sg)  |))
                in
                  error_return [(sg, FromELF), (seg, AutoGenerated)]))))))
              else
                error_fail (''get_elf32_executable_image: invariant invalidated'')) load >>= (\<lambda> bs_base . 
            error_return (List.concat bs_base, unat entr, unat mach))
      ))))
  else
    error_fail (''get_elf32_executable_image: not an ELF executable file''))"


(*val get_elf64_executable_image : elf64_file -> error elf64_executable_process_image*)
definition get_elf64_executable_image  :: " elf64_file \<Rightarrow>((elf64_interpreted_segment*segment_provenance)list*nat*nat)error "  where 
     " get_elf64_executable_image f3 = ( 
  if is_elf64_executable_file(elf64_file_header   f3) then
    (let entr = ((elf64_entry  (elf64_file_header   f3))) in
    (let segs = ((elf64_file_interpreted_segments   f3)) in
    (let mach = ((elf64_machine  (elf64_file_header   f3))) in
      (case  List.filter (\<lambda> sg . (elf64_segment_type   sg) = elf_pt_load) segs of
          []    => error_fail (''get_elf64_executable_image: an executable ELF file must have at least one loadable segment'')
        | load  =>
            mapM (\<lambda> sg . 
              if(elf64_segment_memsz   sg) =( 0 :: nat) then
                error_return []
              else if(elf64_segment_memsz   sg) =(elf64_segment_size   sg) then
                error_return [(sg, FromELF)]
              else if(elf64_segment_size   sg) <(elf64_segment_memsz   sg) then
                (* Cannot be negative due to check in constructing [segs]. *)
                (let diff  = ((elf64_segment_memsz   sg) -(elf64_segment_size   sg)) in
                (let zeros1 = (Byte_sequence.zeros diff) in
                (let addr  = ((elf64_segment_base   sg) +(elf64_segment_size   sg)) in
                (let align = ((elf64_segment_align   sg)) in
                (let paddr = ((elf64_segment_paddr   sg)) in
                (let seg   = 
  ((| elf64_segment_body = zeros1, elf64_segment_type =(elf64_segment_type   sg),
   elf64_segment_size = diff, elf64_segment_memsz = diff,
   elf64_segment_base = addr, elf64_segment_paddr = paddr,
   elf64_segment_align = align,
   elf64_segment_offset =(elf64_segment_offset   sg), elf64_segment_flags =(elf64_segment_flags   sg)  |))
                in
                  error_return [(sg, FromELF), (seg, AutoGenerated)]))))))
              else
                error_fail (''get_elf64_executable_image: invariant invalidated'')) load >>= (\<lambda> bs_base . 
            error_return (List.concat bs_base, unat entr, unat mach))
      ))))
  else
    error_fail (''elf64_get_executable_image: not an executable ELF file''))"


(** Name, (type, size, addr, chunk of data if relevant, binding) *)
type_synonym global_symbol_init_info
  =" (string * (nat * nat * nat *  byte_sequence option * nat)) list "

(*val get_elf32_file_global_symbol_init : elf32_file -> error global_symbol_init_info*)
definition get_elf32_file_global_symbol_init  :: " elf32_file \<Rightarrow>((string*(nat*nat*nat*(byte_sequence)option*nat))list)error "  where 
     " get_elf32_file_global_symbol_init f3 = (
  if is_elf32_executable_file(elf32_file_header   f3) then
    (let segs   = ((elf32_file_interpreted_segments   f3)) in
    bytes_of_elf32_file f3 >>= (\<lambda> bs0 . 
    get_elf32_file_symbol_table f3 >>= (\<lambda> symtab . 
    get_elf32_file_symbol_string_table f3 >>= (\<lambda> strtab . 
    Elf_symbol_table.get_elf32_symbol_image_address symtab strtab >>= (\<lambda> strs . 
      (let mapped = (mapM (\<lambda> (symbol, (typ1, size2, addr, bind)) . 
        if typ1 = Elf_symbol_table.stt_object then
          get_elf32_executable_image f3 >>= (\<lambda> (img, entry, mach) . 
          (let chunks =            
(List.filter (\<lambda> (chunk, _) .               
(addr \<ge>(elf32_segment_base   chunk)) \<and>
                ((addr + size2) \<le> ((elf32_segment_base   chunk) +(elf32_segment_size   chunk)))
            ) img)
          in
            (case  chunks of
                []    => error_fail (''get_elf32_global_symbol_init: global variable not present in executable image'')
              | [(x, _)]   =>
                (let rebase   = (addr -(elf32_segment_base   x)) in
                Byte_sequence.offset_and_cut rebase size2(elf32_segment_body   x) >>= (\<lambda> relevant . 
                  error_return (symbol, (typ1, size2, addr, Some relevant, bind))))
              | x # xs => error_fail (''get_elf32_global_symbol_init: invariant failed, global variable appears in multiple segments'')
            )))
        else
          error_return (symbol, (typ1, size2, addr, None, bind))) strs)
      in
        mapped))))))
  else
    error_fail (''get_elf32_file_global_symbol_init: not an executable ELF file''))"


(*val get_elf64_file_global_symbol_init : elf64_file -> error global_symbol_init_info*)
definition get_elf64_file_global_symbol_init  :: " elf64_file \<Rightarrow>((string*(nat*nat*nat*(byte_sequence)option*nat))list)error "  where 
     " get_elf64_file_global_symbol_init f3 = (
  if is_elf64_executable_file(elf64_file_header   f3) then
    (let segs   = ((elf64_file_interpreted_segments   f3)) in
    bytes_of_elf64_file f3 >>= (\<lambda> bs0 . 
    get_elf64_file_symbol_table f3 >>= (\<lambda> symtab . 
    get_elf64_file_symbol_string_table f3 >>= (\<lambda> strtab . 
    Elf_symbol_table.get_elf64_symbol_image_address symtab strtab >>= (\<lambda> strs . 
      (let mapped = (mapM (\<lambda> (symbol, (typ1, size2, addr, bind)) . 
        if typ1 = Elf_symbol_table.stt_object then
          get_elf64_executable_image f3 >>= (\<lambda> (img, entry, mach) . 
          (let chunks =            
(List.filter (\<lambda> (chunk, _) .               
(addr \<ge>(elf64_segment_base   chunk)) \<and>
                ((addr + size2) \<le> ((elf64_segment_base   chunk) +(elf64_segment_size   chunk)))
            ) img)
          in
            (case  chunks of
                []    => error_fail (''get_elf64_global_symbol_init: global variable not present in executable image'')
              | [(x, _)]   =>
                (let rebase   = (addr -(elf64_segment_base   x)) in
                Byte_sequence.offset_and_cut rebase size2(elf64_segment_body   x) >>= (\<lambda> relevant . 
                  error_return (symbol, (typ1, size2, addr, Some relevant, bind))))
              | x # xs => error_fail (''get_elf64_global_symbol_init: invariant failed, global variable appears in multiple segments'')
            )))
        else
          error_return (symbol, (typ1, size2, addr, None, bind))) strs)
      in
        mapped))))))
  else
    error_fail (''get_elf64_global_symbol_init: not an executable ELF file''))"


(*val string_of_elf32_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf32_file -> string*)

(*val string_of_elf64_file : hdr_print_bundle -> pht_print_bundle -> sht_print_bundle -> elf64_file -> string*)

(*val flag_is_set : natural -> natural -> bool*)
definition flag_is_set  :: " nat \<Rightarrow> nat \<Rightarrow> bool "  where 
     " flag_is_set flag v = ( 
    (* HACK: convert to elf64_xword first. Flags never live 
     * in objects bigger than 64 bits. *)
    Elf_Types_Local.uint64_land 
            (of_int (int v)) 
            (of_int (int flag))
    = (of_int (int flag)))"

end
