chapter {* Generated by Lem from memory_image.lem. *}

theory "Memory_image" 

imports 
 	 Main
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_set" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_function" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_sorting" 
	 "Missing_pervasives" 
	 "Byte_sequence" 
	 "Elf_types_native_uint" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_tuple" 
	 "Elf_header" 
	 "/home/dpm/Work/Programming/Cambridge/bitbucket/lem/isabelle-lib/Lem_map" 
	 "Elf_program_header_table" 
	 "Elf_section_header_table" 
	 "Elf_interpreted_section" 
	 "Elf_interpreted_segment" 
	 "Elf_symbol_table" 
	 "Elf_file" 
	 "Elf_relocation" 
	 "Multimap" 

begin 

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*open import Set*)
(*open import Multimap*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*open import Show*)

(*open import Byte_sequence*)
(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_segment*)
(*open import Elf_interpreted_section*)
(*open import Elf_program_header_table*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)

(*open import Missing_pervasives*)

(* Now we can define memory images *)

type_synonym byte_pattern_element ="  Elf_Types_Local.byte option "
type_synonym byte_pattern =" byte_pattern_element list "

(* An element might have an address/offset, and it has some contents. *)
record memory_image_element = 
 startpos ::"  nat option " 
                             
 length1   ::"  nat option "
                             
 contents ::" byte_pattern "
                             


(* HMM -- ideally I want to fold these into the memory image notion
 * and the startpos thingy. *)
type_synonym allocated_symbols_map =" (string, (nat * nat)) Map.map " (* start, length *)

(* Instead of modelling address calculations (in linker scripts) like so:

type address_expr = natural -> allocated_symbols_map -> natural
                  ( pos     -> environment           -> result address )
                  
   ... we model it as expressions in terms of CursorPosition. HMM.
*) 

datatype expr_operand = Var " string "
                   | CursorPosition          (* only valid in certain expressions... HMM *)
                   | Constant " nat "
                   | UnOp " (expr_unary_operation * expr_operand)"
                   | BinOp " (expr_binary_operation * expr_operand * expr_operand)"
and
expr_unary_operation = Neg " expr_operand "
                           | BitwiseInverse " expr_operand "
and 
expr_binary_operation = Add " (expr_operand * expr_operand)"
                           | Sub " (expr_operand * expr_operand)"
                           | BitwiseAnd " (expr_operand * expr_operand)"
                           | BitwiseOr " (expr_operand * expr_operand)"

datatype expr_binary_relation = 
    Lt
    | Lte
    | Gt
    | Gte
    | Eq
    | Neq

datatype expr = 
    False0
    | True0
    | Not " expr "
    | And " (expr * expr)"
    | Or " (expr * expr)"
    | BinRel " (expr_binary_relation * expr_operand)"  (* LH operand is the expr's value *)

(*
val cond_expr : expr -> expr -> expr -> expr
let cond_expr expr1 expr2 expr3 = (Or((And(expr1, expr2)), (And((Not(expr1)), expr3))))
*)

(* Memory image elements all have identities. For convenience
 * we make the identities strings. The string contents are arbitrary,
 * and only their equality is relevant, but choosing friendly names
 * like ELF header is good practice.*)
type_synonym memory_image =" (string, memory_image_element) Map.map "
(* An element of an ELF image, in the linking phase, is either a section,
 * the ELF header, the section header table or the program header table.
 * 
 * PROBLEM: We'd like to use section names as the identifiers
 * for those elements that are sections.
 * but we can't, because they are not guaranteed to be unique. 
 * 
 * SOLUTION: Names that are unique in the file are used as keys. 
 * If not unique, the sections are treated as anonymous and given
 * gensym'd string ids (FIXME: implement this).
 *)

(* Currently, our elements have unique names, which are strings.
 * We *don't* want to encode any meaning onto these strings.
 * All meaning should be encoded into labelled ranges.
 * We want to be able to look up 
 *
 * - elements
 * - ranges within elements
 * 
 * ... by their *labels* -- or sometimes just *part* of their labels.
 *)

(* ELF file features with which we can label ranges of the memory image. *)
datatype elf_file_feature = 
    ElfHeader " elf64_header "
    | ElfSectionHeaderTable " elf64_section_header_table " (* do we want to expand these? *)
    | ElfProgramHeaderTable " elf64_program_header_table "
    | ElfSection " (nat * elf64_interpreted_section)" (* SHT idx *)
    | ElfSegment " (nat * elf64_interpreted_segment)" (* PHT idx *)

record symbol_reference
 = 
 ref_symname ::" string "                  (* symbol name *)
    
 ref_syment ::" elf64_symbol_table_entry " (* undefined (referencing) symbol *)
    
 ref_sym_scn ::" nat "                 (* symtab section idx *) 
    
 ref_sym_idx ::" nat "                 (* index into symbol table *)
    


definition symRefCompare  :: " symbol_reference \<Rightarrow> symbol_reference \<Rightarrow> ordering "  where 
     " symRefCompare x1 x2 = (        
(quadrupleCompare (\<lambda> x y. EQ) elf64_symbol_table_entry_compare (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) ((ref_symname   x1),(ref_syment   x1),(ref_sym_scn   x1),(ref_sym_idx   x1))
                ((ref_symname   x2),(ref_syment   x2),(ref_sym_scn   x2),(ref_sym_idx   x2))))"

                
definition instance_Basic_classes_Ord_Memory_image_symbol_reference_dict  :: "(symbol_reference)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_symbol_reference_dict = ((|

  compare_method = symRefCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefCompare f1 f2) ({GT, EQ})))|) )"


record reloc_site = 

      ref_relent  ::" elf64_relocation_a " 
    
 ref_rel_scn ::" nat "  (* the relocation section idx *)
    
 ref_rel_idx ::" nat "  (* the index of the relocation rec *)
    
 ref_src_scn ::" nat "  (* the section *from which* the reference logically comes *)



definition relocSiteCompare  :: " reloc_site \<Rightarrow> reloc_site \<Rightarrow> ordering "  where 
     " relocSiteCompare x1 x2 = (        
(tripleCompare elf64_relocation_a_compare (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) ((ref_relent   x1),(ref_rel_idx   x1),(ref_src_scn   x1))
                ((ref_relent   x2),(ref_rel_idx   x2),(ref_src_scn   x2))))"

                
definition instance_Basic_classes_Ord_Memory_image_reloc_site_dict  :: "(reloc_site)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_reloc_site_dict = ((|

  compare_method = relocSiteCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (relocSiteCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (relocSiteCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (relocSiteCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (relocSiteCompare f1 f2) ({GT, EQ})))|) )"


record symbol_reference_and_reloc_site = 

      ref         ::" symbol_reference "
    
 maybe_reloc ::"  reloc_site option "
    


definition symRefAndRelocSiteCompare  :: " symbol_reference_and_reloc_site \<Rightarrow> symbol_reference_and_reloc_site \<Rightarrow> ordering "  where 
     " symRefAndRelocSiteCompare x1 x2 = (        
(pairCompare symRefCompare (maybeCompare relocSiteCompare) ((ref   x1),(maybe_reloc   x1))
                ((ref   x2),(maybe_reloc   x2))))"


definition instance_Basic_classes_Ord_Memory_image_symbol_reference_and_reloc_site_dict  :: "(symbol_reference_and_reloc_site)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_symbol_reference_and_reloc_site_dict = ((|

  compare_method = symRefAndRelocSiteCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefAndRelocSiteCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefAndRelocSiteCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (symRefAndRelocSiteCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symRefAndRelocSiteCompare f1 f2) ({GT, EQ})))|) )"


record symbol_definition
 = 
 def_symname ::" string "
    
 def_syment ::" elf64_symbol_table_entry " (* definition's symtab entry *)
    
 def_sym_scn ::" nat "                 (* symtab section index, to disamiguate dynsym *)
    
 def_sym_idx ::" nat "                 (* index of symbol into the symtab *)
    


definition symDefCompare  :: " symbol_definition \<Rightarrow> symbol_definition \<Rightarrow> ordering "  where 
     " symDefCompare x1 x2 = (        
(quadrupleCompare (\<lambda> x y. EQ) elf64_symbol_table_entry_compare (genericCompare (op<) (op=)) (genericCompare (op<) (op=)) ((def_symname   x1),(def_syment   x1),(def_sym_scn   x1),(def_sym_idx   x1))
                ((def_symname   x2),(def_syment   x2),(def_sym_scn   x2),(def_sym_idx   x2))))"


definition instance_Basic_classes_Ord_Memory_image_symbol_definition_dict  :: "(symbol_definition)Ord_class "  where 
     " instance_Basic_classes_Ord_Memory_image_symbol_definition_dict = ((|

  compare_method = symDefCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (symDefCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symDefCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (symDefCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (symDefCompare f1 f2) ({GT, EQ})))|) )"


record 'a ToNaturalList_class=

    toNaturalList_method ::" 'a \<Rightarrow> nat list "



(* In order to store tags in a set, we need a total ordering
 * to be defined on them.
 * 
 * But also, in order to look up entries 
 * by tag constructor *alone* (e.g. ImageBase, EntryPoint, etc.)
 * we need a looser version of the same ordering.
 * 
 * So we factor it into a few stages.
 * 
 * - map tag constructors to integers. We'll use this to define the 
 * equivalence classes. Since we want to do queries of the form
 *
 *     FileFeature(ElfSection(_))
 *
 * to get all sections, say, we actually map to a *list* of integers,
 * where each constructor contributes one element to the list.
 * Since lists are lexicographically ordered, we get a total ordering
 * just as good as if we'd used only naturals.
 *)


(* We can also annotate arbitrary ranges of bytes within an element
 * with arbitrary metadata. 
 * 
 * Ideally we want to data-abstract this a bit. But it's hard to do
 * so without baking in ELF-specific and/or (moreover) per-ABI concepts, 
 * like PLTs and GOTs. Ideally we would use something like polymorphic
 * variants here. For now, this has to be the union of all the concepts
 * that we find in the various ABIs we care about. To avoid ELFy things
 * creeping in, we parameterise by 'a, and instantiate the 'a with the
 * relevant ELFy thing when we use it. OH, but then 'a is different for
 * every distinct ELF thing, which is no good. Can we define a mapping
 * from an umbrella ELF type to the relevant types in each case? *)
datatype 'abifeature range_tag = (*  forall 'abifeature . *)
                 ImageBase
               | EntryPoint
               | SymbolDef " symbol_definition "
               | SymbolRef " symbol_reference_and_reloc_site "
               | FileFeature " elf_file_feature " (* file feature other than symdef and reloc *)
               | AbiFeature " 'abifeature "

type_synonym range =" nat * nat " (* start, length *)

type_synonym element_range =" string * range "

record 'abifeature annotated_memory_image = 

      elements         ::" memory_image " 
    
 by_range         ::" (( element_range option), ( 'abifeature range_tag)) multimap "
    
 by_tag           ::" (( 'abifeature range_tag), ( element_range option)) multimap "



(* Basic ELFy and ABI-y things. *)
(* FIXME: shouldn't really be here, but need to be in some low-lying module, and 
 * keeping out of elf_* for now to avoid duplication into elf64_, elf32_. *)
definition elf_section_is_special  :: " elf64_interpreted_section \<Rightarrow> 'a \<Rightarrow> bool "  where 
     " elf_section_is_special s f = ( \<not> ((elf64_section_type   s) = sht_progbits)
                     \<and> \<not> ((elf64_section_type   s) = sht_nobits))"


(*val noop_reloc : forall 'abifeature. natural -> ((maybe elf64_symbol_table_entry -> natural) * (annotated_memory_image 'abifeature -> maybe natural))*)
definition noop_reloc  :: " nat \<Rightarrow>((elf64_symbol_table_entry)option \<Rightarrow> nat)*('abifeature annotated_memory_image \<Rightarrow>(nat)option)"  where 
     " noop_reloc r = ( ((\<lambda> r_type . ( 8 :: nat)), (\<lambda> sym_val .  None)))"


(* This record collects things that ABIs may or must define. 
 * 
 * Since we want to put all ABIs in a list and select one at run time, 
 * we can't maintain a type-level distinction between ABIs; we have to
 * use elf_memory_image any_abi_feature. To avoid a reference cycle,
 * stay polymorphic in the ABI feature type until we define specific ABIs.
 * In practice we'll use only any_abi_feature, because we need to pull
 * the ABI out of a list at run time.
 *)
type_synonym null_abi_feature =" unit "

record 'abifeature abi = (* forall 'abifeature. *)
   
 is_valid_elf_header ::" elf64_header \<Rightarrow> bool "
                        (* doesn't this generalise outrageously? is_valid_elf_file? *)
    (* Do we want existing, or is it a kind of addend? 
     * We do want it -- modelling both separately is necessary, 
     * because we model relocations bytewise, but some arches
     * do bitfield relocations (think ARM). *)
    
 reloc              ::" nat \<Rightarrow> (( elf64_symbol_table_entry option \<Rightarrow> nat) * ( 'abifeature annotated_memory_image \<Rightarrow>  nat option))"
                        (* number  ->  width   * (symaddr -> addend  -> existing-> relocated) *)
    
 section_is_special ::" elf64_interpreted_section \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> bool "
    
 section_is_large   ::" elf64_interpreted_section \<Rightarrow> 'abifeature annotated_memory_image \<Rightarrow> bool "
    
 maxpagesize        ::" nat "
    
 minpagesize        ::" nat "
    
 commonpagesize     ::" nat "
    
 symbol_is_generated_by_linker ::" string \<Rightarrow> bool "
    


(*val range_contains : (natural * natural) -> (natural * natural) -> bool*)
fun range_contains  :: " nat*nat \<Rightarrow> nat*nat \<Rightarrow> bool "  where 
     " range_contains (r1begin, r1len) (r2begin, r2len) = (    
( 
    (* r1 is at least as big as r2 *)r2begin \<ge> r1begin) \<and> ((r2begin + r2len) \<le> (r1begin + r1len)))" 
declare range_contains.simps [simp del]


(*val range_overlaps : (natural * natural) -> (natural * natural) -> bool*)
fun range_overlaps  :: " nat*nat \<Rightarrow> nat*nat \<Rightarrow> bool "  where 
     " range_overlaps (r1begin, r1len) (r2begin, r2len) = (
    ((r1begin < (r2begin + r2len)) \<and> ((r1begin + r1len) > r2begin))
     \<or> ((r2begin < (r1begin + r1len)) \<and> ((r2begin + r2len) > r1begin)))" 
declare range_overlaps.simps [simp del]

    
(*val is_partition : list (natural * natural) -> list (natural * natural) -> bool*)
definition is_partition  :: "(nat*nat)list \<Rightarrow>(nat*nat)list \<Rightarrow> bool "  where 
     " is_partition rs ranges = ( 
    (* 1. each element of the first list falls entirely within some element
     * from the second list. *)
    (let r_is_contained_by_some_range
     = (\<lambda> r .  List.foldl (op \<or>) False (List.map (\<lambda> range .  range_contains range r) ranges))
    in
    ((\<forall> x \<in> (set rs).  (\<lambda> r .  r_is_contained_by_some_range r) x))
    \<and>
    (* 2. elements of the first list do not overlap *)
    ((\<forall> x \<in> (set rs).  (\<lambda> r .  ((\<forall> x \<in> (set rs).  (\<lambda> r2 .  (r = (* should be ==? *) r2) \<or> (\<not> (range_overlaps r r2))) x))) x))))"


(*val     nat_range : natural -> natural -> list natural*)
function (sequential,domintros)  nat_range  :: " nat \<Rightarrow> nat \<Rightarrow>(nat)list "  where 
     " nat_range base len = (
    (case  len of 
        0 => []
    |   _ => base # (nat_range (base +( 1 :: nat)) (len -( 1 :: nat)))
    ))" 
by pat_completeness auto


(* Expand a sorted list of ranges into a list of bool, where the list contains
 * true if its index is included in one or more ranges, else false. *)
(*val expand_sorted_ranges : list (natural * natural) -> natural -> list bool -> list bool*)
function (sequential,domintros)  expand_sorted_ranges  :: "(nat*nat)list \<Rightarrow> nat \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " expand_sorted_ranges ([]) min_length accum = ( accum @ (
            (let pad_length = (max(( 0 :: nat)) (min_length - (List.length accum)))
            in
            (* let _ = Missing_pervasives.errln (
                padding ranges cares list with  ^ (show pad_length) ^ 
                 cares (accumulated  ^ (show (Missing_pervasives.length accum)) ^ 
                , min length  ^ (show min_length) ^ ))
            in *)
            List.replicate pad_length True)))"
|" expand_sorted_ranges ((base, len) # more) min_length accum = ( 
            (* pad the accum so that it reaches up to base *)
            (let up_to_base = (List.replicate (base - (List.length accum)) True)
            in
            (let up_to_end_of_range = (up_to_base @ (List.replicate len False))
            in
            expand_sorted_ranges more min_length (accum @ up_to_end_of_range))))" 
by pat_completeness auto


(*val expand_unsorted_ranges : list (natural * natural) -> natural -> list bool -> list bool*)
fun  expand_unsorted_ranges  :: "(nat*nat)list \<Rightarrow> nat \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " expand_unsorted_ranges unsorted_ranges min_length accum = (
    expand_sorted_ranges (sort_by (\<lambda> (base1, len1) .  (\<lambda> (base2, len2) .  base1 < base2)) unsorted_ranges) min_length accum )" 
declare expand_unsorted_ranges.simps [simp del]


(*val make_byte_pattern_revacc : list (maybe byte) -> list byte -> list bool -> list (maybe byte)*)
function (sequential,domintros)  make_byte_pattern_revacc  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " make_byte_pattern_revacc revacc ([]) cares = ( List.rev revacc )"
|" make_byte_pattern_revacc revacc (b # bs) cares = ( (case  cares of 
                care # more => make_byte_pattern_revacc ((if \<not> care then None else Some b) # revacc) bs more
              | _ => failwith (''make_byte_pattern: unequal length'')
              ))" 
by pat_completeness auto


(*val make_byte_pattern : list byte -> list bool -> list (maybe byte)*)
fun  make_byte_pattern  :: "(Elf_Types_Local.byte)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " make_byte_pattern bytes cares = ( 
    make_byte_pattern_revacc [] bytes cares )" 
declare make_byte_pattern.simps [simp del]


(*val relax_byte_pattern_revacc : list (maybe byte) -> list (maybe byte) -> list bool -> list (maybe byte)*)
function (sequential,domintros)  relax_byte_pattern_revacc  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " relax_byte_pattern_revacc revacc ([]) cares = ( List.rev revacc )"
|" relax_byte_pattern_revacc revacc (b # bs) cares = ( (case  cares of 
                care # more => relax_byte_pattern_revacc ((if \<not> care then None else b) # revacc) bs more
              | _ => failwith ((''relax_byte_pattern: unequal length''))
              ))" 
by pat_completeness auto

    
(*val relax_byte_pattern : list (maybe byte) -> list bool -> list (maybe byte)*)
fun  relax_byte_pattern  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(bool)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " relax_byte_pattern bytes cares = ( 
    relax_byte_pattern_revacc [] bytes cares )" 
declare relax_byte_pattern.simps [simp del]


(*val byte_option_matches_byte : maybe byte -> byte -> bool*)
fun byte_option_matches_byte  :: "(Elf_Types_Local.byte)option \<Rightarrow> Elf_Types_Local.byte \<Rightarrow> bool "  where 
     " byte_option_matches_byte None b = ( True )"
|" byte_option_matches_byte (Some some) b = ( some = b )" 
declare byte_option_matches_byte.simps [simp del]


(*val byte_list_matches_pattern : list (maybe byte) -> list byte -> bool*)
function (sequential,domintros)  byte_list_matches_pattern  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow> bool "  where 
     " byte_list_matches_pattern ([]) bytes = ( True )"
|" byte_list_matches_pattern (optbyte # more) bytes = ( (case  bytes of 
                [] => False
                | abyte # morebytes => 
                    byte_option_matches_byte optbyte abyte 
                 \<and> byte_list_matches_pattern more morebytes
            ))" 
by pat_completeness auto


(*val append_to_byte_pattern_at_offset : natural -> list (maybe byte) -> list (maybe byte) -> list (maybe byte)*)
definition append_to_byte_pattern_at_offset  :: " nat \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>((Elf_Types_Local.byte)option)list \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " append_to_byte_pattern_at_offset offset pat1 pat2 = (
    (let pad_length = (offset - List.length pat1)
    in
    if pad_length <( 0 :: nat) then failwith ([(CHR ''c''), (CHR ''a''), (CHR ''n''), (Char Nibble2 Nibble7), (CHR ''t''), (CHR '' ''), (CHR ''a''), (CHR ''p''), (CHR ''p''), (CHR ''e''), (CHR ''n''), (CHR ''d''), (CHR '' ''), (CHR ''a''), (CHR ''t''), (CHR '' ''), (CHR ''o''), (CHR ''f''), (CHR ''f''), (CHR ''s''), (CHR ''e''), (CHR ''t''), (CHR '' ''), (CHR ''a''), (CHR ''l''), (CHR ''r''), (CHR ''e''), (CHR ''a''), (CHR ''d''), (CHR ''y''), (CHR '' ''), (CHR ''u''), (CHR ''s''), (CHR ''e''), (CHR ''d'')])
    else (pat1 @ (List.replicate (id pad_length) None)) @ pat2))"


(*val accum_pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> nat -> list byte -> nat -> natural -> list natural -> list natural*)
function (sequential,domintros)  accum_pattern_possible_starts_in_one_byte_sequence  :: "((Elf_Types_Local.byte)option)list \<Rightarrow> nat \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow>(nat)list \<Rightarrow>(nat)list "  where 
     " accum_pattern_possible_starts_in_one_byte_sequence pattern pattern_len seq seq_len offset accum = (
    (* let _ = Missing_pervasives.errs (At offset  ^ (show offset) ^ ... )
    in *)
    (case  pattern of
        [] => (* let _ = Missing_pervasives.errs (terminating with hit (empty pattern)n) in *)
            offset # accum
        | bpe # more_bpes => (* nonempty, so check for nonempty seq *)
            (case  seq of 
                [] => (*let _ = Missing_pervasives.errs (terminating with miss (empty pattern)n) 
                    in *) accum (* ran out of bytes in the sequence, so no match *)
                | byte # more_bytes => (let matched_this_byte =                            
 (byte_option_matches_byte bpe byte)
                       in
                       (* let _ = Missing_pervasives.errs (Byte  ^ (show byte) ^  matched  ^ (show byte_pattern) ^ ?  ^ (show matched_this_byte) ^ ; ) 
                       in *)
                       (let sequence_long_enough = (seq_len \<ge> pattern_len) 
                       in
                       (* let _ = Missing_pervasives.errs (enough bytes remaining ( ^ (show seq_len) ^ ) to match rest of pattern ( ^ (show pattern_len) ^ )?  ^ (show sequence_long_enough) ^ ; ) 
                       in *)
                       (let matched_here = (matched_this_byte \<and> (sequence_long_enough \<and>
                        byte_list_matches_pattern more_bpes more_bytes))
                       in
                       (* let _ = Missing_pervasives.errs (matched pattern anchored here?  ^ (show matched_this_byte) ^ n) 
                       in *)
                       accum_pattern_possible_starts_in_one_byte_sequence 
                           pattern pattern_len 
                           more_bytes (seq_len -( 1 :: nat)) 
                           (offset +( 1 :: nat)) 
                           (if matched_here then offset # accum else accum))))
            )
    ))" 
by pat_completeness auto


(*val pattern_possible_starts_in_one_byte_sequence : list (maybe byte) -> list byte -> natural -> list natural*)
definition pattern_possible_starts_in_one_byte_sequence  :: "((Elf_Types_Local.byte)option)list \<Rightarrow>(Elf_Types_Local.byte)list \<Rightarrow> nat \<Rightarrow>(nat)list "  where 
     " pattern_possible_starts_in_one_byte_sequence pattern seq offset = (
    (* let _ = Missing_pervasives.errs (Looking for matches of  ^
        (show (List.length pattern)) ^ -byte pattern in  ^ (show (List.length seq)) ^ -byte regionn)
    in *)
    accum_pattern_possible_starts_in_one_byte_sequence pattern (List.length pattern) seq (List.length seq) offset [])"


(*val byte_pattern_of_byte_sequence : byte_sequence -> list (maybe byte)*)
fun byte_pattern_of_byte_sequence  :: " byte_sequence \<Rightarrow>((Elf_Types_Local.byte)option)list "  where 
     " byte_pattern_of_byte_sequence (Sequence(bs)) = ( List.map (\<lambda> b .  Some b) bs )" 
declare byte_pattern_of_byte_sequence.simps [simp del]


(*val compute_virtual_address_adjustment : natural -> natural -> natural -> natural*)
definition compute_virtual_address_adjustment  :: " nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat "  where 
     " compute_virtual_address_adjustment max_page_size offset vaddr = (
  (vaddr - offset) mod max_page_size )"

end
