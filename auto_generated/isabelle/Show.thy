header{*Generated by Lem from show.lem.*}

theory "Show" 

imports 
 	 Main
	 "Lem_function" 
	 "Lem_list" 
	 "Lem_maybe" 
	 "Lem_num" 
	 "Lem_string" 
	 "Lem_string_extra" 
	 "Missing_pervasives" 

begin 

(** [show.lem] exports the typeclass [Show] and associated functions for pretty
  * printing arbitrary values.
  *)

(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import String_extra*)

(*open import Missing_pervasives*)

(*class (Show 'a)
  val {ocaml} show : 'a -> string
end*)

(** [string_of_unit u] produces a string representation of unit [u].
  *)
(*val string_of_unit : unit -> string*)

(** [string_of_bool b] produces a string representation of boolean [b].
  *)
(*val string_of_bool : bool -> string*)

(** To give control over extraction as instances cannot be target specific, but
  * the functions they are bound to can be...
  *)
(*val string_of_string : string -> string*)

(** [string_of_pair p] produces a string representation of pair [p].
  *)
(*val string_of_pair : forall 'a 'b. Show 'a, Show 'b => ('a * 'b) -> string*)

(** [string_of_triple p] produces a string representation of triple [p].
  *)
(*val string_of_triple : forall 'a 'b 'c. Show 'a, Show 'b, Show 'c => ('a * 'b * 'c) -> string*)

(** [string_of_quad p] produces a string representation of quad [p].
  *)
(*val string_of_quad : forall 'a 'b 'c 'd. Show 'a, Show 'b, Show 'c, Show 'd => ('a * 'b * 'c * 'd) -> string*)

(** [string_of_list l] produces a string representation of list [l].
  *)
(*val string_of_list : forall 'a. Show 'a => list 'a -> string*)

(*val string_of_maybe : forall 'a. Show 'a => maybe 'a -> string*)

(*val string_of_nat : nat -> string*)
end
