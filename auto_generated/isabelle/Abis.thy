chapter {* Generated by Lem from abis/abis.lem. *}

theory "Abis" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_types_native_uint" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_header" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_interpreted_section" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_file" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Memory_image" 
	 "Abi_utilities" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_aarch64_relocation" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_amd64_relocation" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_amd64" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_aarch64_le" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_power64" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_power64_relocation" 

begin 

(** The [abis] module is the top-level module for all ABI related code, including
  * some generic functionality that works across all ABIs, and a primitive attempt
  * at abstracting over ABIs for purposes of linking.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Num*)
(*open import Maybe*)
(*open import List*)
(*open import Assert_extra*)

(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Memory_image*)

(*open import Abi_amd64*)
(*open import Abi_amd64_relocation*)

(*open import Abi_aarch64_le*)
(*open import Abi_aarch64_relocation*)

(*open import Abi_power64*)
(*open import Abi_power64_relocation*)

(*open import Abi_utilities*)
(*open import Elf_types_native_uint*)

(** Relocation operators and their validity on a given platform *)

(*val is_valid_abi_aarch64_relocation_operator : relocation_operator -> bool*)
fun is_valid_abi_aarch64_relocation_operator  :: " relocation_operator \<Rightarrow> bool "  where 
     " is_valid_abi_aarch64_relocation_operator Page = ( True )"
|" is_valid_abi_aarch64_relocation_operator G = ( True )"
|" is_valid_abi_aarch64_relocation_operator GDat = ( True )"
|" is_valid_abi_aarch64_relocation_operator GLDM = ( True )"
|" is_valid_abi_aarch64_relocation_operator DTPRel = ( True )"
|" is_valid_abi_aarch64_relocation_operator GTPRel = ( True )"
|" is_valid_abi_aarch64_relocation_operator TPRel = ( True )"
|" is_valid_abi_aarch64_relocation_operator GTLSDesc = ( True )"
|" is_valid_abi_aarch64_relocation_operator Delta = ( True )"
|" is_valid_abi_aarch64_relocation_operator LDM = ( True )"
|" is_valid_abi_aarch64_relocation_operator TLSDesc = ( True )"
|" is_valid_abi_aarch64_relocation_operator Indirect = ( True )"
|" is_valid_abi_aarch64_relocation_operator _ = ( False )" 
declare is_valid_abi_aarch64_relocation_operator.simps [simp del]

  
(*val is_valid_abi_aarch64_relocation_operator2 : relocation_operator2 -> bool*)
fun is_valid_abi_aarch64_relocation_operator2  :: " relocation_operator2 \<Rightarrow> bool "  where 
     " is_valid_abi_aarch64_relocation_operator2 GTLSIdx = ( True )" 
declare is_valid_abi_aarch64_relocation_operator2.simps [simp del]


(*val is_valid_abi_amd64_relocation_operator : relocation_operator -> bool*)
fun is_valid_abi_amd64_relocation_operator  :: " relocation_operator \<Rightarrow> bool "  where 
     " is_valid_abi_amd64_relocation_operator Indirect = ( True )"
|" is_valid_abi_amd64_relocation_operator _ = ( False )" 
declare is_valid_abi_amd64_relocation_operator.simps [simp del]

  
(*val is_valid_abi_amd64_relocation_operator2 : relocation_operator2 -> bool*)
definition is_valid_abi_amd64_relocation_operator2  :: " relocation_operator2 \<Rightarrow> bool "  where 
     " is_valid_abi_amd64_relocation_operator2 _ = ( False )"


(*val is_valid_abi_power64_relocation_operator : relocation_operator -> bool*)
definition is_valid_abi_power64_relocation_operator  :: " relocation_operator \<Rightarrow> bool "  where 
     " is_valid_abi_power64_relocation_operator op1 = ( False )"
 (* TODO *)

(*val is_valid_abi_power64_relocation_operator2 : relocation_operator2 -> bool*)
definition is_valid_abi_power64_relocation_operator2  :: " relocation_operator2 \<Rightarrow> bool "  where 
     " is_valid_abi_power64_relocation_operator2 _ = ( False )"


(** Misc. ABI related stuff *)

datatype any_abi_feature = Amd64AbiFeature " amd64_abi_feature "
                     | Aarch64LeAbiFeature " aarch64_le_abi_feature "

(*val anyAbiFeatureToNaturalList : any_abi_feature -> list natural*)
fun anyAbiFeatureToNaturalList  :: " any_abi_feature \<Rightarrow>(nat)list "  where 
     " anyAbiFeatureToNaturalList (Amd64AbiFeature(af)) = (( 0 :: nat) # (amd64AbiFeatureConstructorToNaturalList af))"
|" anyAbiFeatureToNaturalList (Aarch64LeAbiFeature(af)) = (( 1 :: nat) # (aarch64LeAbiFeatureConstructorToNaturalList af))" 
declare anyAbiFeatureToNaturalList.simps [simp del]


definition instance_Memory_image_ToNaturalList_Abis_any_abi_feature_dict  :: "(any_abi_feature)ToNaturalList_class "  where 
     " instance_Memory_image_ToNaturalList_Abis_any_abi_feature_dict = ((|

  toNaturalList_method = anyAbiFeatureToNaturalList |) )"


(*val anyAbiFeatureCompare : any_abi_feature -> any_abi_feature -> Basic_classes.ordering*)
definition anyAbiFeatureCompare  :: " any_abi_feature \<Rightarrow> any_abi_feature \<Rightarrow> ordering "  where 
     " anyAbiFeatureCompare f1 f2 = ( 
    (case  (anyAbiFeatureToNaturalList f1, anyAbiFeatureToNaturalList f2) of
        ([], []) => failwith (''impossible: any-ABI feature has empty natural list (case 0)'')
    |   (_, [])  => failwith (''impossible: any-ABI feature has empty natural list (case 1)'')
    |   ([], _)  => failwith (''impossible: any-ABI feature has empty natural list (case 2)'')
    |   ((hd1 # tl1), (hd2 # tl2)) => 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                (case  (f1, f2) of
                    (Amd64AbiFeature(af1), Amd64AbiFeature(af2)) => Abi_amd64.abiFeatureCompare0 af1 af2
                   |(Aarch64LeAbiFeature(af1), Aarch64LeAbiFeature(af2)) => abiFeatureCompare af1 af2
                   | _ => failwith (''impossible: tag constructors not equal but natural list heads were equal'')
                )
    ))"


definition instance_Basic_classes_Ord_Abis_any_abi_feature_dict  :: "(any_abi_feature)Ord_class "  where 
     " instance_Basic_classes_Ord_Abis_any_abi_feature_dict = ((|

  compare_method = anyAbiFeatureCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (anyAbiFeatureCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (anyAbiFeatureCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (anyAbiFeatureCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (anyAbiFeatureCompare f1 f2) ({GT, EQ})))|) )"


definition make_elf64_header  :: " nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> 'a \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> nat \<Rightarrow> elf64_header "  where 
     " make_elf64_header data osabi abiv ma t entry shoff phoff phnum shnum shstrndx = (
      (| elf64_ident    = [elf_mn_mag0, elf_mn_mag1, elf_mn_mag2, elf_mn_mag3, 
                           Elf_Types_Local.unsigned_char_of_nat elf_class_64, 
                           Elf_Types_Local.unsigned_char_of_nat data,
                           Elf_Types_Local.unsigned_char_of_nat elf_ev_current,
                           Elf_Types_Local.unsigned_char_of_nat osabi,
                           Elf_Types_Local.unsigned_char_of_nat abiv,
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)),
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)),
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)),
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)),
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)),
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat)),
                           Elf_Types_Local.unsigned_char_of_nat(( 0 :: nat))]
       , elf64_type     = (Elf_Types_Local.uint16_of_nat t)
       , elf64_machine  = (Elf_Types_Local.uint16_of_nat ma)
       , elf64_version  = (Elf_Types_Local.uint32_of_nat elf_ev_current)
       , elf64_entry    = (Elf_Types_Local.uint64_of_nat(( 0 :: nat)))
       , elf64_phoff    = (Elf_Types_Local.uint64_of_nat phoff)
       , elf64_shoff    = (Elf_Types_Local.uint64_of_nat shoff)
       , elf64_flags    = (Elf_Types_Local.uint32_of_nat(( 0 :: nat)))
       , elf64_ehsize   = (Elf_Types_Local.uint16_of_nat(( 64 :: nat)))
       , elf64_phentsize= (Elf_Types_Local.uint16_of_nat(( 56 :: nat)))
       , elf64_phnum    = (Elf_Types_Local.uint16_of_nat phnum)
       , elf64_shentsize= (Elf_Types_Local.uint16_of_nat(( 64 :: nat)))
       , elf64_shnum    = (Elf_Types_Local.uint16_of_nat shnum)
       , elf64_shstrndx = (Elf_Types_Local.uint16_of_nat shstrndx)
       |) )"


(* null_abi captures ABI details common to all ELF-based, System V-based systems.
 * HACK: for now, specialise to 64-bit ABIs. *)
(*val null_abi : abi any_abi_feature*) 
definition null_abi  :: "(any_abi_feature)abi "  where 
     " null_abi = ( (|
      is_valid_elf_header = is_valid_elf64_header
    , make_elf_header = (make_elf64_header elf_data_2lsb elf_osabi_none(( 0 :: nat)) elf_ma_none)
    , reloc = noop_reloc
    , section_is_special = elf_section_is_special
    , section_is_large = (\<lambda> s .  (\<lambda> f .  False))
    , maxpagesize =((( 2 :: nat) *( 256 :: nat)) *( 4096 :: nat)) (* 2MB; bit of a guess, based on gdb and prelink code *)
    , minpagesize =(( 1024 :: nat)) (* bit of a guess again *)
    , commonpagesize =(( 4096 :: nat))
    , symbol_is_generated_by_linker = (\<lambda> symname .  symname = (''_GLOBAL_OFFSET_TABLE_''))
    |) )"


(*val sysv_amd64_std_abi : abi any_abi_feature*)
definition sysv_amd64_std_abi  :: "(any_abi_feature)abi "  where 
     " sysv_amd64_std_abi = ( 
   (| is_valid_elf_header = header_is_amd64
    , make_elf_header = (make_elf64_header elf_data_2lsb elf_osabi_none(( 0 :: nat)) elf_ma_x86_64)
    , reloc = (amd64_reloc instance_Basic_classes_Ord_Abis_any_abi_feature_dict
    instance_Memory_image_ToNaturalList_Abis_any_abi_feature_dict)
    , section_is_special = section_is_special0
    , section_is_large = (\<lambda> s .  (\<lambda> f .  flag_is_set shf_x86_64_large(elf64_section_flags   s)))
    , maxpagesize =(( 65536 :: nat))
    , minpagesize =(( 4096 :: nat))
    , commonpagesize =(( 4096 :: nat))
      (* XXX: DPM, changed from explicit reference to null_abi field due to problems in HOL4. *)
    , symbol_is_generated_by_linker = (\<lambda> symname .  symname = (''_GLOBAL_OFFSET_TABLE_''))
    |) )"


(*val sysv_aarch64_le_std_abi : abi any_abi_feature*)
definition sysv_aarch64_le_std_abi  :: "(any_abi_feature)abi "  where 
     " sysv_aarch64_le_std_abi = ( 
   (| is_valid_elf_header = header_is_aarch64_le
    , make_elf_header = (make_elf64_header elf_data_2lsb elf_osabi_none(( 0 :: nat)) elf_ma_aarch64)
    , reloc = aarch64_le_reloc
    , section_is_special = section_is_special0
    , section_is_large = (\<lambda> _ .  (\<lambda> _ .  False))
    , maxpagesize =((( 2 :: nat) *( 256 :: nat)) *( 4096 :: nat)) (* 2MB; bit of a guess, based on gdb and prelink code *)
    , minpagesize =(( 1024 :: nat)) (* bit of a guess again *)
    , commonpagesize =(( 4096 :: nat))
    , symbol_is_generated_by_linker = (\<lambda> symname .  symname = (''_GLOBAL_OFFSET_TABLE_''))
    |) )"


(*val all_abis : list (abi any_abi_feature)*)
definition all_abis  :: "((any_abi_feature)abi)list "  where 
     " all_abis = ( [sysv_amd64_std_abi, sysv_aarch64_le_std_abi, null_abi])"


end
