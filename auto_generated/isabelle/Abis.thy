chapter {* Generated by Lem from abis/abis.lem. *}

theory "Abis" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_header" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_interpreted_section" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Elf_file" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Memory_image" 
	 "Abi_utilities" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_aarch64_relocation" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_amd64_relocation" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_amd64" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_aarch64_le" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_power64" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/linksem/auto_generated/isabelle/Abi_power64_relocation" 

begin 

(** The [abis] module is the top-level module for all ABI related code, including
  * some generic functionality that works across all ABIs, and a primitive attempt
  * at abstracting over ABIs for purposes of linking.
  *)

(*open import Basic_classes*)
(*open import Bool*)
(*open import Num*)
(*open import Maybe*)
(*open import List*)
(*open import Assert_extra*)

(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_section*)
(*open import Memory_image*)

(*open import Abi_amd64*)
(*open import Abi_amd64_relocation*)

(*open import Abi_aarch64_le*)
(*open import Abi_aarch64_relocation*)

(*open import Abi_power64*)
(*open import Abi_power64_relocation*)

(*open import Abi_utilities*)

(** Relocation operators and their validity on a given platform *)

(*val is_valid_abi_aarch64_relocation_operator : relocation_operator -> bool*)
fun is_valid_abi_aarch64_relocation_operator  :: " relocation_operator \<Rightarrow> bool "  where 
     " is_valid_abi_aarch64_relocation_operator Page = ( True )"
|" is_valid_abi_aarch64_relocation_operator G = ( True )"
|" is_valid_abi_aarch64_relocation_operator GDat = ( True )"
|" is_valid_abi_aarch64_relocation_operator GLDM = ( True )"
|" is_valid_abi_aarch64_relocation_operator DTPRel = ( True )"
|" is_valid_abi_aarch64_relocation_operator GTPRel = ( True )"
|" is_valid_abi_aarch64_relocation_operator TPRel = ( True )"
|" is_valid_abi_aarch64_relocation_operator GTLSDesc = ( True )"
|" is_valid_abi_aarch64_relocation_operator Delta = ( True )"
|" is_valid_abi_aarch64_relocation_operator LDM = ( True )"
|" is_valid_abi_aarch64_relocation_operator TLSDesc = ( True )"
|" is_valid_abi_aarch64_relocation_operator Indirect = ( True )"
|" is_valid_abi_aarch64_relocation_operator _ = ( False )" 
declare is_valid_abi_aarch64_relocation_operator.simps [simp del]

  
(*val is_valid_abi_aarch64_relocation_operator2 : relocation_operator2 -> bool*)
fun is_valid_abi_aarch64_relocation_operator2  :: " relocation_operator2 \<Rightarrow> bool "  where 
     " is_valid_abi_aarch64_relocation_operator2 GTLSIdx = ( True )" 
declare is_valid_abi_aarch64_relocation_operator2.simps [simp del]


(*val is_valid_abi_amd64_relocation_operator : relocation_operator -> bool*)
fun is_valid_abi_amd64_relocation_operator  :: " relocation_operator \<Rightarrow> bool "  where 
     " is_valid_abi_amd64_relocation_operator Indirect = ( True )"
|" is_valid_abi_amd64_relocation_operator _ = ( False )" 
declare is_valid_abi_amd64_relocation_operator.simps [simp del]

  
(*val is_valid_abi_amd64_relocation_operator2 : relocation_operator2 -> bool*)
definition is_valid_abi_amd64_relocation_operator2  :: " relocation_operator2 \<Rightarrow> bool "  where 
     " is_valid_abi_amd64_relocation_operator2 _ = ( False )"


(*val is_valid_abi_power64_relocation_operator : relocation_operator -> bool*)
definition is_valid_abi_power64_relocation_operator  :: " relocation_operator \<Rightarrow> bool "  where 
     " is_valid_abi_power64_relocation_operator op1 = ( False )"
 (* TODO *)

(*val is_valid_abi_power64_relocation_operator2 : relocation_operator2 -> bool*)
definition is_valid_abi_power64_relocation_operator2  :: " relocation_operator2 \<Rightarrow> bool "  where 
     " is_valid_abi_power64_relocation_operator2 _ = ( False )"


(** Misc. ABI related stuff *)

datatype any_abi_feature = Amd64AbiFeature " amd64_abi_feature "
                     | Aarch64LeAbiFeature " aarch64_le_abi_feature "

(* null_abi captures ABI details common to all ELF-based, System V-based systems. *)
(*val null_abi : abi any_abi_feature*) 
definition null_abi  :: "(any_abi_feature)abi "  where 
     " null_abi = ( (|
      is_valid_elf_header = is_valid_elf64_header
    , reloc = noop_reloc
    , section_is_special = elf_section_is_special
    , section_is_large = (\<lambda> s .  (\<lambda> f .  False))
    , maxpagesize =((( 2 :: nat) *( 256 :: nat)) *( 4096 :: nat)) (* 2MB; bit of a guess, based on gdb and prelink code *)
    , minpagesize =(( 1024 :: nat)) (* bit of a guess again *)
    , commonpagesize =(( 4096 :: nat))
    , symbol_is_generated_by_linker = (\<lambda> symname .  symname = (''_GLOBAL_OFFSET_TABLE_''))
    |) )"


(*val sysv_amd64_std_abi : abi any_abi_feature*)
definition sysv_amd64_std_abi  :: "(any_abi_feature)abi "  where 
     " sysv_amd64_std_abi = ( 
   (| is_valid_elf_header = header_is_amd64
    , reloc = (\<lambda> r .  (width_of_x86_64_relocation r, (\<lambda> _ .  None)))
    , section_is_special = section_is_special0
    , section_is_large = (\<lambda> s .  (\<lambda> f .  flag_is_set shf_x86_64_large(elf64_section_flags   s)))
    , maxpagesize =(( 65536 :: nat))
    , minpagesize =(( 4096 :: nat))
    , commonpagesize =(( 4096 :: nat))
    , symbol_is_generated_by_linker =(symbol_is_generated_by_linker   null_abi)
    |) )"


(*val sysv_aarch64_le_std_abi : abi any_abi_feature*)
definition sysv_aarch64_le_std_abi  :: "(any_abi_feature)abi "  where 
     " sysv_aarch64_le_std_abi = ( 
   (| is_valid_elf_header = header_is_aarch64_le
    , reloc = (\<lambda> r .  (width_of_aarch64_relocation r, (\<lambda> _ .  None)))
    , section_is_special = section_is_special0
    , section_is_large = (\<lambda> _ .  (\<lambda> _ .  False))
    , maxpagesize =(maxpagesize   null_abi)
    , minpagesize =(minpagesize   null_abi)
    , commonpagesize =(commonpagesize   null_abi)
    , symbol_is_generated_by_linker =(symbol_is_generated_by_linker   null_abi)
    |) )"


(*val all_abis : list (abi any_abi_feature)*)
definition all_abis  :: "((any_abi_feature)abi)list "  where 
     " all_abis = ( [sysv_amd64_std_abi, sysv_aarch64_le_std_abi, null_abi])"


(*
val amd64AbiFeatureConstructorToNaturalList : amd64_abi_feature -> list natural
val aarch64AbiFeatureConstructorToNaturalList : aarch64_le_abi_feature -> list natural
*)

(*val anyAbiFeatureConstructorToNaturalList : any_abi_feature -> list natural*)
fun anyAbiFeatureConstructorToNaturalList  :: " any_abi_feature \<Rightarrow>(nat)list "  where 
     " anyAbiFeatureConstructorToNaturalList (Amd64AbiFeature(aaf)) = (( 0 :: nat) # (amd64AbiFeatureConstructorToNaturalList aaf))"
|" anyAbiFeatureConstructorToNaturalList (Aarch64LeAbiFeature(aaf)) = (( 1 :: nat) # (aarch64LeAbiFeatureConstructorToNaturalList aaf))" 
declare anyAbiFeatureConstructorToNaturalList.simps [simp del]


definition anyAbiFeatureCompare  :: " any_abi_feature \<Rightarrow> any_abi_feature \<Rightarrow> ordering "  where 
     " anyAbiFeatureCompare f1 f2 = ( 
    (case  ((anyAbiFeatureConstructorToNaturalList f1), (anyAbiFeatureConstructorToNaturalList f2)) of
        ([], []) => failwith (''impossible: elf file feature has empty natural list (case 0)'')
    |   (_, [])  => failwith (''impossible: elf file feature has empty natural list (case 1)'')
    |   ([], _)  => failwith (''impossible: elf file feature has empty natural list (case 2)'')
    |   ((hd1 # tl1), (hd2 # tl2)) => 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                (case  (f1, f2) of
                    (Amd64AbiFeature(x1), Amd64AbiFeature(x2)) => Abi_amd64.abiFeatureCompare0 x1 x2
                    | (Aarch64LeAbiFeature(x1), Aarch64LeAbiFeature(x2)) => abiFeatureCompare x1 x2
                    | _ => failwith (''impossible: tag constructors not equal but natural list heads were equal'')
                )
    ))"


definition instance_Basic_classes_Ord_Abis_any_abi_feature_dict  :: "(any_abi_feature)Ord_class "  where 
     " instance_Basic_classes_Ord_Abis_any_abi_feature_dict = ((|

  compare_method = anyAbiFeatureCompare,

  isLess_method = (\<lambda> f1 .  (\<lambda> f2 .  (anyAbiFeatureCompare f1 f2 = LT))),

  isLessEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (anyAbiFeatureCompare f1 f2) ({LT, EQ}))),

  isGreater_method = (\<lambda> f1 .  (\<lambda> f2 .  (anyAbiFeatureCompare f1 f2 = GT))),

  isGreaterEqual_method = (\<lambda> f1 .  (\<lambda> f2 .  (op \<in>) (anyAbiFeatureCompare f1 f2) ({GT, EQ})))|) )"


fun anyAbiFeatureToNaturalList  :: " any_abi_feature \<Rightarrow>(nat)list "  where 
     " anyAbiFeatureToNaturalList (Amd64AbiFeature(aaf)) = ( amd64AbiFeatureConstructorToNaturalList aaf )"
|" anyAbiFeatureToNaturalList (Aarch64LeAbiFeature(aaf)) = ( aarch64LeAbiFeatureConstructorToNaturalList aaf )" 
declare anyAbiFeatureToNaturalList.simps [simp del]


definition instance_Memory_image_ToNaturalList_Abis_any_abi_feature_dict  :: "(any_abi_feature)ToNaturalList_class "  where 
     " instance_Memory_image_ToNaturalList_Abis_any_abi_feature_dict = ((|

  toNaturalList_method = anyAbiFeatureToNaturalList |) )"

end
