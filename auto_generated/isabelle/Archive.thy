chapter {* Generated by Lem from archive.lem. *}

theory "Archive" 

imports 
 	 Main
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_num" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_list" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_basic_classes" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_bool" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_maybe" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_string" 
	 "/auto/homes/dpm36/Work/Cambridge/bitbucket/lem/isabelle-lib/Lem_assert_extra" 
	 "Show" 
	 "Missing_pervasives" 
	 "Error" 
	 "Byte_sequence" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Num*)
(*open import Maybe*)
(*open import String*)
(*open import Show*)
(*open import Assert_extra*)

(*open import Missing_pervasives*)
(*open import Byte_sequence*)
(*open import Error*)

record archive_entry_header =
  
 name      ::" string "
   
 timestamp ::" nat "
   
 uid       ::" nat "
   
 gid       ::" nat "
   
 mode      ::" nat "
   
 size0      ::" nat " (* 1GB should be enough *)
   


type_synonym archive_global_header =" char
  list "

(*val string_of_byte_sequence : byte_sequence -> string*)
fun string_of_byte_sequence0  :: " byte_sequence \<Rightarrow> string "  where 
     " string_of_byte_sequence0 (Sequence bs) = ( (List.map Elf_Types_Local.char_of_unsigned_char bs))" 
declare string_of_byte_sequence0.simps [simp del]

(*val read_archive_entry_header : natural -> byte_sequence -> error (archive_entry_header * natural * byte_sequence)*)
definition read_archive_entry_header  :: " nat \<Rightarrow> byte_sequence \<Rightarrow>(archive_entry_header*nat*byte_sequence)error "  where 
     " read_archive_entry_header seq_length seq = (
  (let magic_bytes = ([unat ((96 :: 16 word)) (* 0x60 *), unat(( 10 :: 16 word)) (* 0x0a *)]) in
    (
        (let header_length =(( 60 :: nat)) in
        (* let _ = Missing_pervasives.errs (Archive entry header?  ^ (show (take 16 bs)) ^ ? ) in *)
        partition_with_length header_length seq_length seq >>= (\<lambda> (header1, rest) .  
        offset_and_cut(( 58 :: nat))(( 2 :: nat)) header1 >>= (\<lambda> magic .  
        offset_and_cut(( 0 :: nat))(( 16 :: nat)) header1 >>= (\<lambda> name1 .  
        offset_and_cut(( 16 :: nat))(( 12 :: nat)) header1 >>= (\<lambda> timestamp_str .  
        offset_and_cut(( 28 :: nat))(( 6 :: nat))  header1 >>= (\<lambda> uid_str .  
        offset_and_cut(( 34 :: nat))(( 6 :: nat))  header1 >>= (\<lambda> gid_str .  
        offset_and_cut(( 40 :: nat))(( 8 :: nat))  header1 >>= (\<lambda> mode_str .  
        offset_and_cut(( 48 :: nat))(( 10 :: nat)) header1 >>= (\<lambda> size_str .  
        (let size2 = (natural_of_decimal_string (string_of_byte_sequence0 size_str)) in 
                (* let _ = Missing_pervasives.errln (: yes, size  ^ (show size)) in *)
        error_return ((| name = (string_of_byte_sequence0 name1), timestamp = (( 0 :: nat) :: nat) (* FIXME *),
          uid =(( 0 :: nat)) (* FIXME *) , gid =(( 0 :: nat)) (* FIXME *) , mode =(( 0 :: nat)) (* FIXME *),
            size0 = (id size2) (* FIXME *) |), (seq_length - header_length), rest)))))))))))
    )))"


(*val read_archive_global_header : byte_sequence -> error (archive_global_header * byte_sequence)*)
fun read_archive_global_header  :: " byte_sequence \<Rightarrow>((char)list*byte_sequence)error "  where 
     " read_archive_global_header (Sequence bs) = (
            (* let _ = Missing_pervasives.errs (Archive?  ^ (show (take 16 bs)) ^ ? )
            in*)
      (let chars = (List.map Elf_Types_Local.char_of_unsigned_char (take(( 8 :: nat)) bs)) in 
        if  chars = ([(CHR ''!''), (CHR ''<''), (CHR ''a''), (CHR ''r''), (CHR ''c''), (CHR ''h''), (CHR ''>''), (Char Nibble0 NibbleA)]) then
          (* let _ = Missing_pervasives.errln : yes in *)
          error_return (chars, Sequence(List.drop(( 8 :: nat)) bs))
        else
          (* let _ = Missing_pervasives.errln : no in *)
          error_fail (''read_archive_global_header: not an archive'')))" 
declare read_archive_global_header.simps [simp del]


(*val accum_archive_contents : (list (string * byte_sequence)) -> maybe string -> natural -> byte_sequence -> error (list (string * byte_sequence))*)
function (sequential,domintros)  accum_archive_contents  :: "(string*byte_sequence)list \<Rightarrow>(string)option \<Rightarrow> nat \<Rightarrow> byte_sequence \<Rightarrow>((string*byte_sequence)list)error "  where 
     " accum_archive_contents accum extended_filenames whole_seq_length whole_seq = ( 
  (* let _ = Missing_pervasives.errs Can read a header?  in *)
  (case read_archive_entry_header whole_seq_length whole_seq of
    Fail _ \<Rightarrow> (error_return accum)
  | Success (hdr, (seq_length :: nat), seq) \<Rightarrow> 
    (case  seq of
        Sequence next_bs =>
        (* let _ = Missing_pervasives.errln (yes; next_bs has length  ^ (show (List.length next_bs))) in *)
        (let amount_to_drop =          
(if ((size0   hdr) mod( 2 :: nat)) =( 0 :: nat) then
            ((size0   hdr))
          else
            ((size0   hdr)) +( 1 :: nat))
        in
        if amount_to_drop =( 0 :: nat) then
          error_fail (''accum_archive_contents: amount to drop from byte sequence is 0'')
        else
        (*let _ = Missing_pervasives.errln (amount_to_drop is  ^ (show amount_to_drop)) in*)
        (let chunk = (Sequence(List.take(size0   hdr) next_bs))
        in
        (*let _ = Missing_pervasives.errs (Processing archive header named  ^ hdr.name)
        in*)
        (let (new_accum, (new_extended_filenames ::  string option)) =          
((let name1 = ((name   hdr)) in
            if name1 = [(CHR ''/''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' ''), (CHR '' '')] then
              (* SystemV symbol lookup table; we skip this *) (accum, extended_filenames)
            else
              (case name1 of
                [] \<Rightarrow> ((((name hdr), chunk) # accum), extended_filenames)
              | x#xs \<Rightarrow>
                  if x = CHR ''/'' then
                    (case xs of
                      [] \<Rightarrow>
                   (let index1 = (natural_of_decimal_string ( xs)) in
                     (case  extended_filenames of 
                         None => failwith (''corrupt archive: reference to non-existent extended filenames'')
                       | Some s => 
                           (let table_suffix = ((case  Elf_Types_Local.string_suffix index1 s of Some x => x | None => ('''') )) in
                           (let index1 = ((case  string_index_of (CHR ''/'') table_suffix of Some x => x | None => ( (List.length table_suffix)) )) in 
                           (let ext_name = ((case  string_prefix index1 table_suffix of Some x => x | None => ('''') )) in
                           (*let _ = Missing_pervasives.errln (Got ext_name  ^ ext_name) in*)
                             (((ext_name, chunk) # accum), extended_filenames))))
                     ))
                    | y#ys \<Rightarrow>
                      if y = CHR ''/'' then
                        (* extended filenames chunk *) (accum, Some(string_of_byte_sequence0 chunk))
                      else
                                           (let index1 = (natural_of_decimal_string ( ys)) in
                     (case  extended_filenames of 
                         None => failwith (''corrupt archive: reference to non-existent extended filenames'')
                       | Some s => 
                           (let table_suffix = ((case  Elf_Types_Local.string_suffix index1 s of Some x => x | None => ('''') )) in
                           (let index1 = ((case  string_index_of (CHR ''/'') table_suffix of Some x => x | None => ( (List.length table_suffix)) )) in 
                           (let ext_name = ((case  string_prefix index1 table_suffix of Some x => x | None => ('''') )) in
                           (*let _ = Missing_pervasives.errln (Got ext_name  ^ ext_name) in*)
                             (((ext_name, chunk) # accum), extended_filenames))))
                     )))
                  else
                    ((((name   hdr), chunk) # accum), extended_filenames))))
        in
          (case (Byte_sequence.dropbytes amount_to_drop seq) of
            Fail _ \<Rightarrow> (error_return accum)
          | Success new_seq \<Rightarrow> accum_archive_contents new_accum new_extended_filenames (seq_length - amount_to_drop) new_seq))))
    )))" 
by pat_completeness auto

lemma offset_and_cut_length [simp]:
  assumes "offset_and_cut off len bs0 = Success bs1"
  shows "length0 bs1 = len"
sorry

lemma partition_with_length_length [simp]:
  assumes "partition_with_length off len bs0 = Success (bs1, bs2)"
  shows "length0 bs1 = off \<and> length0 bs2 = len"
sorry

lemma read_archive_entry_header_length [simp]:
  assumes "read_archive_entry_header len bs = Success (hdr, sz, bs1)"
  shows "Byte_sequence.length0 bs1 < Byte_sequence.length0 bs"
using assms unfolding read_archive_entry_header_def
  sorry

lemma dropbytes_length:
  fixes len :: "nat" and bs bs1 :: "byte_sequence"
  assumes "0 < len" and "dropbytes len bs = Success bs1"
  shows "length0 bs1 < length0 bs"
sorry

lemma lt_technical1:
  fixes q :: nat
  assumes "0 < q"
  shows "0 < 2 * q"
using assms by auto

lemma lt_technical2:
  fixes m :: nat
  shows "0 < Suc m"
by auto

termination accum_archive_contents
  apply(relation "measure (\<lambda>(_,_,_,l). Byte_sequence.length0 l)")
  apply auto
  apply(case_tac "read_archive_entry_header whole_seq_length whole_seq", simp)
  apply(case_tac x1, simp)
  apply(erule conjE)+
  apply(clarify)
  apply(auto simp only: Let_def)
  apply(case_tac "name a = ''/               ''", simp)
  apply(erule conjE)+
  apply clarify
  apply(case_tac "size0 a mod 2 = 0")
  apply simp
  apply(frule read_archive_entry_header_length)
  apply(frule dropbytes_length, assumption)
  apply auto
  apply(frule read_archive_entry_header_length)
  apply(frule lt_technical1)
  apply(frule dropbytes_length, assumption)
  apply linarith
  apply(subgoal_tac "0 < Suc (size0 a)")
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply simp
  apply(case_tac "name a", simp)
  apply(erule conjE)+
  apply(case_tac "size0 a mod 2", simp)
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply simp
  apply(subgoal_tac "0 < Suc (size0 a)")
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply simp
  apply(case_tac "size0 a mod 2", simp)
  apply(case_tac "ab = CHR ''/''", simp)
  apply(case_tac "list", simp)
  apply(case_tac "extended_filenames", simp)
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply simp
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply simp
  apply(subgoal_tac "0 < Suc (size0 a)")
  apply(frule dropbytes_length, assumption)
  apply(frule read_archive_entry_header_length)
  apply linarith
  apply simp
done

termination dropbytes
  apply(relation "measure (\<lambda>(m, l). Byte_sequence.length0 l)")
  apply auto
  apply(simp add: naturalZero_def)
  apply(simp add: length0.simps)
done
  

(*val read_archive : byte_sequence -> error (list (string * byte_sequence))*)
definition read_archive  :: " byte_sequence \<Rightarrow>((string*byte_sequence)list)error "  where 
     " read_archive bs = ( 
    read_archive_global_header bs >>= (\<lambda> (hdr, seq) .  
    (let result = (accum_archive_contents [] None (Byte_sequence.length0 seq) seq)  in 
    (* let _ = Missing_pervasives.errln Finished reading archive in *)
    (case  result of
        Success r => Success (List.rev r)
        | Fail x => Fail x
    ))))"

end
