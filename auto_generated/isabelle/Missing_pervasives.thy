header{*Generated by Lem from missing_pervasives.lem.*}

theory "Missing_pervasives" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_bool" 
	 "Lem_list" 
	 "Lem_maybe" 
	 "Lem_num" 
	 "Lem_string" 
	 "$ISABELLE_HOME/src/HOL/Word/Word" 
	 "Elf_Types_Local" 

begin 

(*open import Basic_classes*)
(*open import Bool*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)

(*open import {isabelle} `$ISABELLE_HOME/src/HOL/Word/Word`*)
(*open import {isabelle} `Elf_Types_Local`*)

(*type byte*)

(*val char_of_byte : byte -> char*)

(*val natural_of_bool : bool -> natural*)
fun natural_of_bool  :: " bool \<Rightarrow> nat "  where 
     " natural_of_bool True = (( 1 :: nat))"
|" natural_of_bool False = (( 0 :: nat))" 
declare natural_of_bool.simps [simp del]


(*type ordering
  = Equal
  | Less
  | Greater*)

(*val natural_ordering : natural -> natural -> ordering*)
definition natural_ordering  :: " nat \<Rightarrow> nat \<Rightarrow> Elf_Types_Local.ordering "  where 
     " natural_ordering left right = (
  if left = right then
    Equal
  else if left < right then
    Less
  else
    Greater )"


(*val sort_by : forall 'a. ('a -> 'a -> ordering) -> list 'a -> list 'a*)

(** [intercalate sep xs] places [sep] between all elements of [xs]. *)
(*val intercalate : forall 'a. 'a -> list 'a -> list 'a*)
function (sequential,domintros)  intercalate  :: " 'a \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " intercalate sep ([]) = ( [])"
|" intercalate sep ([x]) = ( [x])"
|" intercalate sep (x # xs) = ( x #(sep # intercalate sep xs))" 
by pat_completeness auto


(** [mapMaybei f xs] maps a function expecting an index (the position in the list
  * [xs] that it is currently viewing) and producing a [maybe] type across a list.
  * Elements that produce [Nothing] under [f] are discarded in the output, whilst
  * those producing [Just e] for some [e] are kept.
  *)
(*val mapMaybei' : forall 'a 'b. (natural -> 'a -> maybe 'b) -> natural -> list 'a -> list 'b*)
function (sequential,domintros)  mapMaybei'  :: "(nat \<Rightarrow> 'a \<Rightarrow> 'b option)\<Rightarrow> nat \<Rightarrow> 'a list \<Rightarrow> 'b list "  where 
     " mapMaybei' f idx ([]) = ( [])"
|" mapMaybei' f idx (x # xs) = (
      (case  f idx x of
        None => mapMaybei' f (( 1 :: nat) + idx) xs
      | Some e  => e # mapMaybei' f (( 1 :: nat) + idx) xs
      ))" 
by pat_completeness auto


(*val mapMaybei : forall 'a 'b. (natural -> 'a -> maybe 'b) -> list 'a -> list 'b*)
    
definition mapMaybei  :: "(nat \<Rightarrow> 'a \<Rightarrow> 'b option)\<Rightarrow> 'a list \<Rightarrow> 'b list "  where 
     " mapMaybei f xs = (
  mapMaybei' f(( 0 :: nat)) xs )"


(** [unlines xs] concatenates a list of strings [xs], placing each entry
  * on a new line.
  *)
(*val unlines : list string -> string*)
definition unlines  :: "(string)list \<Rightarrow> string "  where 
     " unlines xs = (
  List.foldr (op@) (intercalate ([(Char Nibble0 NibbleA)]) xs) (''''))"


(** [bracket xs] concatenates a list of strings [xs], separating each entry with a
  * space, and bracketing the resulting string.
  *)
(*val bracket : list string -> string*)
definition bracket  :: "(string)list \<Rightarrow> string "  where 
     " bracket xs = (
  (''('') @ (List.foldr (op@) (intercalate ('' '') xs) ('''') @ ('')'')))"


(** [null_char] is the null character. *)
(*val null_char : byte*)

(** [split_string_on_char s c] splits a string [s] into a list of substrings
  * on character [c], otherwise returning the singleton list containing [s]
  * if [c] is not found in [s].
  *)
(*val split_string_on_char : string -> char -> list string*)

(** [print s] prints [s] to stdout. *)
(*val print : string -> unit*)

(** [string_of_nat m] produces a string representation of natural number [m]. *)
(*val string_of_nat : nat -> string*)

(** [string_suffix i s] chops [i] characters off [s], returning a new string.
  * Fails if the index is negative, or beyond the end of the string.
  *)
(*val string_suffix : natural -> string -> maybe string*)

(*val index : forall 'a. natural -> list 'a -> maybe 'a*)end
