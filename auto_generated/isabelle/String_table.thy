header{*Generated by Lem from string_table.lem.*}

theory "String_table" 

imports 
 	 Main
	 "Lem_basic_classes" 
	 "Lem_list" 
	 "Lem_maybe" 
	 "Lem_num" 
	 "Lem_string" 
	 "Error" 
	 "Missing_pervasives" 
	 "Show" 

begin 

(*open import Basic_classes*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)

(*open import Error*)
(*open import Missing_pervasives*)
(*open import Show*)

datatype string_table
  = Strings " (char * string)"

(** [mk_string_table base sep] constructs a string table using [base] as the
  * base string and [sep] as the delimiting character to use to split [base]
  * when trying to access the string stored in the table using the functions below.
  *)
(*val mk_string_table : string -> char -> string_table*)
definition mk_string_table  :: " string \<Rightarrow> char \<Rightarrow> string_table "  where 
     " mk_string_table base sep = (
  Strings (sep, base))"


(** [empty] is the empty string table with an arbitrary choice of delimiter.
  *)
(*val empty : string_table*)
definition empty0  :: " string_table "  where 
     " empty0 = ( Strings (Elf_Types_Local.char_of_unsigned_char (0 :: 8 word), ('''')))"


(** [get_delimiating_character tbl] returns the delimiting character associated
  * with the string table [tbl], used to split the strings.
  *)
(*val get_delimiting_character : string_table -> char*)
fun get_delimiting_character  :: " string_table \<Rightarrow> char "  where 
     " get_delimiting_character (Strings (sep, base)) = ( sep )" 
declare get_delimiting_character.simps [simp del]


(** [get_base_string tbl] returns the base string of the string table [tbl].
  *)
(*val get_base_string : string_table -> string*)
fun get_base_string  :: " string_table \<Rightarrow> string "  where 
     " get_base_string (Strings (sep, base)) = ( base )" 
declare get_base_string.simps [simp del]


(** [concat xs] concatenates several string tables into one providing they all
  * have the same delimiting character.
  *)
(*val concat : list string_table -> error string_table*)
fun concat_string_table  :: "(string_table)list \<Rightarrow>(string_table)error "  where 
     " concat_string_table ([]) = ( error_return empty0 )"
|" concat_string_table (x # xs) = (
      (let delim = (get_delimiting_character x) in
        if (((\<forall> x0 \<in> (set (x # xs)).  (\<lambda> x .  get_delimiting_character x = delim) x0))) then
          (let base = (List.foldr (op@) (List.map get_base_string (x # xs)) ('''')) in
            error_return (mk_string_table base delim))
        else
          error_fail (''concat: string tables must have same delimiting characters'')))" 
declare concat_string_table.simps [simp del]


(** [get_strings tbl] obtains the strings stored in the table, separated using
  * the designated separator as a delimiting character.
  *)
(*val get_strings : string_table -> list string*)
fun get_strings  :: " string_table \<Rightarrow>(string)list "  where 
     " get_strings (Strings (sep, base)) = (
        Elf_Types_Local.split_string_on_char base sep )" 
declare get_strings.simps [simp del]


(** [size tbl] returns the number of strings separated by the designated
  * separator in the string table [tbl].
  *)
(*val size : string_table -> nat*)
definition size  :: " string_table \<Rightarrow> nat "  where 
     " size tbl = (
  List.length (get_strings tbl))"


(** [get_string_at index tbl] returns the string starting at character [index]
  * from the start of the base string until the first occurrence of the delimiting
  * character.
  *)
(*val get_string_at : natural -> string_table -> error string*)
definition get_string_at  :: " nat \<Rightarrow> string_table \<Rightarrow>(string)error "  where 
     " get_string_at index1 tbl = (
  (case  Elf_Types_Local.string_suffix index1 (get_base_string tbl) of
      None     => Fail (''get_string_at: invalid index into string'')
    | Some suffix =>
        (let delim = (get_delimiting_character tbl) in
        (let tbl   = (mk_string_table suffix delim) in
          (case  get_strings tbl of
              []    => Fail (''get_string_at: empty string returned'')
            | x # xs => error_return x
          )))
  ))"


record 'a HasElf32SectionHeaderStringTable_class=

  get_elf32_section_header_string_table_method ::" 'a \<Rightarrow> string_table "



record 'a HasElf64SectionHeaderStringTable_class=

  get_elf64_section_header_string_table_method ::" 'a \<Rightarrow> string_table "

end
