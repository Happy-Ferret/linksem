(*Generated by Lem from memory_image_orderings.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_setTheory lem_functionTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory showTheory lem_sortingTheory missing_pervasivesTheory byte_sequenceTheory elf_types_native_uintTheory lem_tupleTheory elf_headerTheory lem_mapTheory elf_program_header_tableTheory elf_section_header_tableTheory elf_interpreted_sectionTheory elf_interpreted_segmentTheory elf_symbol_tableTheory elf_fileTheory elf_relocationTheory multimapTheory memory_imageTheory;

val _ = numLib.prefer_num();



val _ = new_theory "memory_image_orderings"

(*open import Basic_classes*)
(*open import Function*)
(*open import String*)
(*open import Tuple*)
(*open import Bool*)
(*open import List*)
(*open import Sorting*)
(*open import Map*)
(*open import Set*)
(*open import Multimap*)
(*open import Num*)
(*open import Maybe*)
(*open import Assert_extra*)
(*open import Show*)

(*open import Byte_sequence*)
(*open import Elf_file*)
(*open import Elf_header*)
(*open import Elf_interpreted_segment*)
(*open import Elf_interpreted_section*)
(*open import Elf_program_header_table*)
(*open import Elf_section_header_table*)
(*open import Elf_symbol_table*)
(*open import Elf_types_native_uint*)
(*open import Elf_relocation*)
(*open import Memory_image*)
(* open import Abis *)

(*open import Missing_pervasives*)


(*val elfFileFeatureConstructorToNaturalList : elf_file_feature -> list natural*)
val _ = Define `
 (elfFileFeatureConstructorToNaturalList f = ((case f of
    ElfHeader(_) => [ 0]
    | ElfSectionHeaderTable(_) => [ 1]
    | ElfProgramHeaderTable(_) => [ 2]
    | ElfSection(_) => [ 3]
    | ElfSegment(_) => [ 4]
)))`;


val _ = Define `
(instance_Memory_image_ToNaturalList_Memory_image_elf_file_feature_dict =(<|

  toNaturalList_method := elfFileFeatureConstructorToNaturalList|>))`;


(*val elfFileFeatureCompare : elf_file_feature -> elf_file_feature -> Basic_classes.ordering*)
val _ = Define `
 (elfFileFeatureCompare f1 f2 =    
 ((case (elfFileFeatureConstructorToNaturalList f1, elfFileFeatureConstructorToNaturalList f2) of
        ([], []) => failwith "impossible: elf file feature has empty natural list (case 0)"
    |   (_, [])  => failwith "impossible: elf file feature has empty natural list (case 1)"
    |   ([], _)  => failwith "impossible: elf file feature has empty natural list (case 2)"
    |   ((hd1 :: tl1), (hd2 :: tl2)) => 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                (case (f1, f2) of
                    (ElfHeader(x1), ElfHeader(x2)) => elf64_header_compare x1 x2
                    | (ElfSectionHeaderTable(x1), ElfSectionHeaderTable(x2)) => (lexicographic_compare compare_elf64_section_header_table_entry x1 x2)
                    | (ElfProgramHeaderTable(x1), ElfProgramHeaderTable(x2)) => (lexicographic_compare compare_elf64_program_header_table_entry x1 x2)
                    | (ElfSection(x1), ElfSection(x2)) => (pairCompare (genericCompare (<) (=)) compare_elf64_interpreted_section x1 x2)
                    | (ElfSegment(x1), ElfSegment(x2)) => (pairCompare (genericCompare (<) (=)) compare_elf64_interpreted_segment x1 x2)
                    | _ => failwith "impossible: tag constructors not equal but natural list heads were equal"
                )
    )))`;


val _ = Define `
(instance_Basic_classes_Ord_Memory_image_elf_file_feature_dict =(<|

  compare_method := elfFileFeatureCompare;

  isLess_method := (\ f1 .  (\ f2 .  (elfFileFeatureCompare f1 f2 = LT)));

  isLessEqual_method := (\ f1 .  (\ f2 .  (IN) (elfFileFeatureCompare f1 f2) ({LT; EQ})));

  isGreater_method := (\ f1 .  (\ f2 .  (elfFileFeatureCompare f1 f2 = GT)));

  isGreaterEqual_method := (\ f1 .  (\ f2 .  (IN) (elfFileFeatureCompare f1 f2) ({GT; EQ})))|>))`;


(*val tagConstructorToNaturalList : forall 'abifeature. ToNaturalList 'abifeature => range_tag 'abifeature -> list natural*)
val _ = Define `
 (tagConstructorToNaturalList dict_Memory_image_ToNaturalList_abifeature t = ((case t of 
    ImageBase => [ 0]
    | EntryPoint => [ 1]
    | SymbolDef(_) => [ 2]
    | SymbolRef(_) => [ 3]
    | FileFeature(f) => 4 :: (elfFileFeatureConstructorToNaturalList f)
    | AbiFeature(af) => 5 :: (
  dict_Memory_image_ToNaturalList_abifeature.toNaturalList_method af)
)))`;


val _ = Define `
(instance_Memory_image_ToNaturalList_Memory_image_range_tag_dict dict_Memory_image_ToNaturalList_abifeature =(<|

  toNaturalList_method := 
  (tagConstructorToNaturalList dict_Memory_image_ToNaturalList_abifeature)|>))`;


(*val tagEquiv : forall 'abifeature. ToNaturalList 'abifeature => range_tag 'abifeature -> range_tag 'abifeature -> bool*)
val _ = Define `
 (tagEquiv dict_Memory_image_ToNaturalList_abifeature k1 k2 =    
 (EQ = ((lexicographic_compare (genericCompare (<) (=)) (tagConstructorToNaturalList 
  dict_Memory_image_ToNaturalList_abifeature k1) (tagConstructorToNaturalList 
  dict_Memory_image_ToNaturalList_abifeature k2)))))`;


(*val tagCompare : forall 'abifeature. ToNaturalList 'abifeature, Ord 'abifeature => range_tag 'abifeature -> range_tag 'abifeature -> Basic_classes.ordering*)
val _ = Define `
 (tagCompare dict_Memory_image_ToNaturalList_abifeature dict_Basic_classes_Ord_abifeature k1 k2 =    
 ((case ((tagConstructorToNaturalList 
  dict_Memory_image_ToNaturalList_abifeature k1), (tagConstructorToNaturalList 
  dict_Memory_image_ToNaturalList_abifeature k2)) of
        ([], []) => failwith "impossible: tag has empty natural list (case 0)"
    |   (_, [])  => failwith "impossible: tag has empty natural list (case 1)"
    |   ([], _)  => failwith "impossible: tag has empty natural list (case 2)"
    |   ((hd1 :: tl1), (hd2 :: tl2)) => 
            if hd1 < hd2 then LT else if hd1 > hd2 then GT else
                (case (k1, k2) of
                    (ImageBase, ImageBase) => EQ
                    | (EntryPoint, EntryPoint) => EQ
                    | (SymbolDef(x1), SymbolDef(x2)) => symDefCompare x1 x2
                    | (SymbolRef(x1), SymbolRef(x2)) => symRefAndRelocSiteCompare x1 x2
                    | (FileFeature(x1), FileFeature(x2)) => elfFileFeatureCompare x1 x2
                    | (AbiFeature(x1), AbiFeature(x2)) => 
  dict_Basic_classes_Ord_abifeature.compare_method x1 x2
                    | _ => failwith "impossible: tag constructors not equal but natural list heads were equal"
                )
    )))`;


val _ = Define `
(instance_Basic_classes_Ord_Memory_image_range_tag_dict dict_Basic_classes_Ord_abifeature dict_Memory_image_ToNaturalList_abifeature =(<|

  compare_method := 
  (tagCompare dict_Memory_image_ToNaturalList_abifeature
     dict_Basic_classes_Ord_abifeature);

  isLess_method := (\ tag1 .  (\ tag2 .  (tagCompare 
  dict_Memory_image_ToNaturalList_abifeature dict_Basic_classes_Ord_abifeature tag1 tag2 = LT)));

  isLessEqual_method := (\ tag1 .  (\ tag2 .  (IN) (tagCompare 
  dict_Memory_image_ToNaturalList_abifeature dict_Basic_classes_Ord_abifeature tag1 tag2) ({LT; EQ})));

  isGreater_method := (\ tag1 .  (\ tag2 .  (tagCompare 
  dict_Memory_image_ToNaturalList_abifeature dict_Basic_classes_Ord_abifeature tag1 tag2 = GT)));

  isGreaterEqual_method := (\ tag1 .  (\ tag2 .  (IN) (tagCompare 
  dict_Memory_image_ToNaturalList_abifeature dict_Basic_classes_Ord_abifeature tag1 tag2) ({GT; EQ})))|>))`;


(* ------- end of Ord / compare / ConstructorToNaturalList functions *)


(*val unique_tag_matching : forall 'abifeature. Ord 'abifeature, ToNaturalList 'abifeature => range_tag 'abifeature -> annotated_memory_image 'abifeature -> range_tag 'abifeature*)
val _ = Define `
 (unique_tag_matching dict_Basic_classes_Ord_abifeature dict_Memory_image_ToNaturalList_abifeature tag img =    
 ((case multimap$lookupBy0 
  (instance_Basic_classes_Ord_Memory_image_range_tag_dict
     dict_Basic_classes_Ord_abifeature
     dict_Memory_image_ToNaturalList_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      lem_string_extra$instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (tagEquiv dict_Memory_image_ToNaturalList_abifeature) tag img.by_tag of
        [] => failwith "no tag match found"
        | [(t, r)] => t
        | x => failwith ("more than one tag match") (* (ranges: " ^ 
            (show (List.map (fun (t, r) -> r) x))
            ^  ") when asserted unique")" *)
    )))`;

    
(*val tagged_ranges_matching_tag : forall 'abifeature. Ord 'abifeature, ToNaturalList 'abifeature => range_tag 'abifeature -> annotated_memory_image 'abifeature -> list (range_tag 'abifeature * maybe element_range)*)
val _ = Define `
 (tagged_ranges_matching_tag dict_Basic_classes_Ord_abifeature dict_Memory_image_ToNaturalList_abifeature tag img =    
 (multimap$lookupBy0 (instance_Basic_classes_Ord_Memory_image_range_tag_dict
   dict_Basic_classes_Ord_abifeature
   dict_Memory_image_ToNaturalList_abifeature) (instance_Basic_classes_Ord_Maybe_maybe_dict
   (instance_Basic_classes_Ord_tup2_dict
      lem_string_extra$instance_Basic_classes_Ord_string_dict
      (instance_Basic_classes_Ord_tup2_dict
         instance_Basic_classes_Ord_Num_natural_dict
         instance_Basic_classes_Ord_Num_natural_dict)))  (tagEquiv dict_Memory_image_ToNaturalList_abifeature) tag img.by_tag))`;


(*val element_range_compare : element_range -> element_range -> Basic_classes.ordering*)
val _ = Define `
 (element_range_compare = (pairCompare (\ x y. EQ) (pairCompare (genericCompare (<) (=)) (genericCompare (<) (=)))))`;


(*val unique_tag_matching_at_range_exact : forall 'abifeature. Ord 'abifeature, ToNaturalList 'abifeature =>
    maybe element_range
    -> range_tag 'abifeature
    -> annotated_memory_image 'abifeature
    -> range_tag 'abifeature*)
val _ = Define `
 (unique_tag_matching_at_range_exact dict_Basic_classes_Ord_abifeature dict_Memory_image_ToNaturalList_abifeature r tag img = 
  (
  (* 1. find tags a unique range labelled as ELF section header table. *) (case 
  UNZIP
    (multimap$lookupBy0
       (instance_Basic_classes_Ord_Maybe_maybe_dict
          (instance_Basic_classes_Ord_tup2_dict
             lem_string_extra$instance_Basic_classes_Ord_string_dict
             (instance_Basic_classes_Ord_tup2_dict
                instance_Basic_classes_Ord_Num_natural_dict
                instance_Basic_classes_Ord_Num_natural_dict)))
       (instance_Basic_classes_Ord_Memory_image_range_tag_dict
          dict_Basic_classes_Ord_abifeature
          dict_Memory_image_ToNaturalList_abifeature) (=) r img.by_range) of
      (_, (allRangeMatches : ( 'abifeature range_tag) list)) =>
  let (tagAlsoMatches : ( 'abifeature range_tag) list) = (FILTER
                                                            (\ x .  tagEquiv
                                                                    dict_Memory_image_ToNaturalList_abifeature
                                                                    x 
                                                                    tag)
                                                            allRangeMatches)
  in
  (case tagAlsoMatches of
      [] => failwith "no range/tag match when asserted to exist"
    | [x] => x
    | _ => failwith "multiple range/tag match when asserted unique"
  )
  )))`;

val _ = export_theory()

