(*Generated by Lem from multimap.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_setTheory lem_functionTheory lem_basic_classesTheory lem_boolTheory lem_maybeTheory lem_stringTheory lem_assert_extraTheory showTheory lem_set_extraTheory missing_pervasivesTheory multimapTheory;

val _ = numLib.prefer_num();



open lemLib;
(* val _ = lemLib.run_interactive := true; *)
val _ = new_theory "multimapAuxiliary"


(****************************************************)
(*                                                  *)
(* Assertions                                       *)
(*                                                  *)
(****************************************************)

val _ = lem_assertion "lowest_simple" ``findLowestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (<) ({ ( 1, 0); ( 2, 0); ( 3, 0); ( 4, 0); ( 5, 0); ( 6, 0) } : (num # num) set) NONE = SOME ( 3, 0)``;

val _ = lem_assertion "lowest_empty" ``findLowestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (<) ({} : (num # num) set) NONE = NONE``;

val _ = lem_assertion "lowest_onepast" ``findLowestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (<) ({ ( 6, 0) } : (num # num) set) NONE = NONE``;

val _ = lem_assertion "lowest_oneprev" ``findLowestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (<) ({ ( 2, 0) } : (num # num) set) NONE = NONE``;

val _ = lem_assertion "highest_simple" ``findHighestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (>) ({ ( 1, 0); ( 2, 0); ( 3, 0); ( 4, 0); ( 5, 0); ( 6, 0) } : (num # num) set) NONE = SOME ( 5, 0)``;

val _ = lem_assertion "highest_empty" ``findHighestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (>) ({} : (num # num) set) NONE = NONE``;

val _ = lem_assertion "highest_onepast" ``findHighestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (>) ({ ( 6, 0) } : (num # num) set) NONE = NONE``;

val _ = lem_assertion "highest_oneprev" ``findHighestEquiv 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) (>) ({ ( 2, 0) } : (num # num) set) NONE = NONE``;

val _ = lem_assertion "lookup_simple" ``lookupBy0 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) ({ ( 1, 0); ( 2, 0); ( 3, 0); ( 4, 0); ( 5, 0); ( 6, 0) } : (num # num) set)
= ([( 3, 0); ( 4, 0); ( 5, 0)] : (num # num) list)``;

val _ = lem_assertion "lookup_empty" ``lookupBy0 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) ({} : (num # num) set) = ([]: (num # num) list)``;

val _ = lem_assertion "lookup_singleton" ``lookupBy0 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) ({( 5, 0)} : (num # num) set) = ([( 5, 0)]: (num # num) list)``;

val _ = lem_assertion "lookup_onepast" ``lookupBy0 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) ({ ( 6, 0) } : (num # num) set) = ([] : (num # num) list)``;

val _ = lem_assertion "lookup_oneprev" ``lookupBy0 
  instance_Basic_classes_Ord_Num_natural_dict instance_Basic_classes_Ord_Num_natural_dict testEquiv( 4) ({ ( 2, 0) } : (num # num) set) = ([] : (num # num) list)``;


(****************************************************)
(*                                                  *)
(* Termination Proofs                               *)
(*                                                  *)
(****************************************************)

(* val gst = Defn.tgoal_no_defn (findLowestEquiv_def, findLowestEquiv_ind) *)
val (findLowestEquiv_rw, findLowestEquiv_ind_rw) =
  Defn.tprove_no_defn ((findLowestEquiv_def, findLowestEquiv_ind),
    (* the termination proof *)
  )
val findLowestEquiv_rw = save_thm ("findLowestEquiv_rw", findLowestEquiv_rw);
val findLowestEquiv_ind_rw = save_thm ("findLowestEquiv_ind_rw", findLowestEquiv_ind_rw);


(* val gst = Defn.tgoal_no_defn (findHighestEquiv_def, findHighestEquiv_ind) *)
val (findHighestEquiv_rw, findHighestEquiv_ind_rw) =
  Defn.tprove_no_defn ((findHighestEquiv_def, findHighestEquiv_ind),
    (* the termination proof *)
  )
val findHighestEquiv_rw = save_thm ("findHighestEquiv_rw", findHighestEquiv_rw);
val findHighestEquiv_ind_rw = save_thm ("findHighestEquiv_ind_rw", findHighestEquiv_ind_rw);




val _ = export_theory()

