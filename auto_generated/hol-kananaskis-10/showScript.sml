(*Generated by Lem from show.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_listTheory lem_functionTheory lem_maybeTheory lem_stringTheory lem_string_extraTheory;

val _ = numLib.prefer_num();



val _ = new_theory "show"

(** [show.lem] exports the typeclass [Show] and associated functions for pretty
  * printing arbitrary values.
  *)

(*open import Function*)
(*open import List*)
(*open import Maybe*)
(*open import Num*)
(*open import String*)
(*open import String_extra*)

(*class (Show 'a)
  val {ocaml} show : 'a -> string
end*)

(** [string_of_unit u] produces a string representation of unit [u].
  *)
(*val string_of_unit : unit -> string*)

(** [string_of_bool b] produces a string representation of boolean [b].
  *)
(*val string_of_bool : bool -> string*)

(** To give control over extraction as instances cannot be target specific, but
  * the functions they are bound to can be...
  *)
(*val string_of_string : string -> string*)

(** [string_of_pair p] produces a string representation of pair [p].
  *)
(*val string_of_pair : forall 'a 'b. Show 'a, Show 'b => ('a * 'b) -> string*)

(** [string_of_triple p] produces a string representation of triple [p].
  *)
(*val string_of_triple : forall 'a 'b 'c. Show 'a, Show 'b, Show 'c => ('a * 'b * 'c) -> string*)

(** [string_of_quad p] produces a string representation of quad [p].
  *)
(*val string_of_quad : forall 'a 'b 'c 'd. Show 'a, Show 'b, Show 'c, Show 'd => ('a * 'b * 'c * 'd) -> string*)

(** [string_of_maybe m] produces a string representation of maybe value [m].
  *)
(*val string_of_maybe : forall 'a. Show 'a => maybe 'a -> string*)

(** [show_else s m] produces a string representation of maybe [m], using [s] 
  * in the case [m] = Nothing. *)
(*val show_else : forall 'a. Show 'a => string -> maybe 'a -> string*)

(** [string_of_nat m] produces a string representation of nat value [m].
  *)
(*val string_of_nat : nat -> string*)

(*val string_of_integer : integer -> string*)
val _ = export_theory()

